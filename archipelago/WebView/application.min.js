var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __toCommonJS = (from) => {
  const moduleCache = __toCommonJS.moduleCache ??= new WeakMap;
  var cached = moduleCache.get(from);
  if (cached)
    return cached;
  var to = __defProp({}, "__esModule", { value: true });
  var desc = { enumerable: false };
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key))
        __defProp(to, key, {
          get: () => from[key],
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
  }
  moduleCache.set(from, to);
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = (id) => {
  return import.meta.require(id);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// node_modules/xterm/lib/xterm.js
var require_xterm = __commonJS((exports, module) => {
  (function(e, t) {
    if (typeof exports == "object" && typeof module == "object")
      module.exports = t();
    else if (typeof define == "function" && define.amd)
      define([], t);
    else {
      var i = t();
      for (var s in i)
        (typeof exports == "object" ? exports : e)[s] = i[s];
    }
  })(globalThis, () => (() => {
    var e = { 4567: function(e2, t2, i2) {
      var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : s3 === null ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          o2 = Reflect.decorate(e3, t3, i3, s3);
        else
          for (var a2 = e3.length - 1;a2 >= 0; a2--)
            (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i3, s3) {
          t3(i3, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.AccessibilityManager = undefined;
      const n = i2(9042), o = i2(9924), a = i2(844), h = i2(4725), c = i2(2585);
      let l = t2.AccessibilityManager = class extends a.Disposable {
        constructor(e3, t3, i3, s3) {
          super(), this._terminal = e3, this._coreBrowserService = i3, this._renderService = s3, this._liveRegionLineCount = 0, this._charsToConsume = [], this._charsToAnnounce = "", this._accessibilityContainer = this._coreBrowserService.mainDocument.createElement("div"), this._accessibilityContainer.classList.add("xterm-accessibility"), this._rowContainer = this._coreBrowserService.mainDocument.createElement("div"), this._rowContainer.setAttribute("role", "list"), this._rowContainer.classList.add("xterm-accessibility-tree"), this._rowElements = [];
          for (let e4 = 0;e4 < this._terminal.rows; e4++)
            this._rowElements[e4] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[e4]);
          if (this._topBoundaryFocusListener = (e4) => this._handleBoundaryFocus(e4, 0), this._bottomBoundaryFocusListener = (e4) => this._handleBoundaryFocus(e4, 1), this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions(), this._accessibilityContainer.appendChild(this._rowContainer), this._liveRegion = this._coreBrowserService.mainDocument.createElement("div"), this._liveRegion.classList.add("live-region"), this._liveRegion.setAttribute("aria-live", "assertive"), this._accessibilityContainer.appendChild(this._liveRegion), this._liveRegionDebouncer = this.register(new o.TimeBasedDebouncer(this._renderRows.bind(this))), !this._terminal.element)
            throw new Error("Cannot enable accessibility before Terminal.open");
          this._terminal.element.insertAdjacentElement("afterbegin", this._accessibilityContainer), this.register(this._terminal.onResize((e4) => this._handleResize(e4.rows))), this.register(this._terminal.onRender((e4) => this._refreshRows(e4.start, e4.end))), this.register(this._terminal.onScroll(() => this._refreshRows())), this.register(this._terminal.onA11yChar((e4) => this._handleChar(e4))), this.register(this._terminal.onLineFeed(() => this._handleChar("\n"))), this.register(this._terminal.onA11yTab((e4) => this._handleTab(e4))), this.register(this._terminal.onKey((e4) => this._handleKey(e4.key))), this.register(this._terminal.onBlur(() => this._clearLiveRegion())), this.register(this._renderService.onDimensionsChange(() => this._refreshRowsDimensions())), this.register(this._coreBrowserService.onDprChange(() => this._refreshRowsDimensions())), this._refreshRows(), this.register((0, a.toDisposable)(() => {
            this._accessibilityContainer.remove(), this._rowElements.length = 0;
          }));
        }
        _handleTab(e3) {
          for (let t3 = 0;t3 < e3; t3++)
            this._handleChar(" ");
        }
        _handleChar(e3) {
          this._liveRegionLineCount < 21 && (this._charsToConsume.length > 0 ? this._charsToConsume.shift() !== e3 && (this._charsToAnnounce += e3) : this._charsToAnnounce += e3, e3 === "\n" && (this._liveRegionLineCount++, this._liveRegionLineCount === 21 && (this._liveRegion.textContent += n.tooMuchOutput)));
        }
        _clearLiveRegion() {
          this._liveRegion.textContent = "", this._liveRegionLineCount = 0;
        }
        _handleKey(e3) {
          this._clearLiveRegion(), /\p{Control}/u.test(e3) || this._charsToConsume.push(e3);
        }
        _refreshRows(e3, t3) {
          this._liveRegionDebouncer.refresh(e3, t3, this._terminal.rows);
        }
        _renderRows(e3, t3) {
          const i3 = this._terminal.buffer, s3 = i3.lines.length.toString();
          for (let r2 = e3;r2 <= t3; r2++) {
            const e4 = i3.translateBufferLineToString(i3.ydisp + r2, true), t4 = (i3.ydisp + r2 + 1).toString(), n2 = this._rowElements[r2];
            n2 && (e4.length === 0 ? n2.innerText = "\xA0" : n2.textContent = e4, n2.setAttribute("aria-posinset", t4), n2.setAttribute("aria-setsize", s3));
          }
          this._announceCharacters();
        }
        _announceCharacters() {
          this._charsToAnnounce.length !== 0 && (this._liveRegion.textContent += this._charsToAnnounce, this._charsToAnnounce = "");
        }
        _handleBoundaryFocus(e3, t3) {
          const i3 = e3.target, s3 = this._rowElements[t3 === 0 ? 1 : this._rowElements.length - 2];
          if (i3.getAttribute("aria-posinset") === (t3 === 0 ? "1" : `${this._terminal.buffer.lines.length}`))
            return;
          if (e3.relatedTarget !== s3)
            return;
          let r2, n2;
          if (t3 === 0 ? (r2 = i3, n2 = this._rowElements.pop(), this._rowContainer.removeChild(n2)) : (r2 = this._rowElements.shift(), n2 = i3, this._rowContainer.removeChild(r2)), r2.removeEventListener("focus", this._topBoundaryFocusListener), n2.removeEventListener("focus", this._bottomBoundaryFocusListener), t3 === 0) {
            const e4 = this._createAccessibilityTreeNode();
            this._rowElements.unshift(e4), this._rowContainer.insertAdjacentElement("afterbegin", e4);
          } else {
            const e4 = this._createAccessibilityTreeNode();
            this._rowElements.push(e4), this._rowContainer.appendChild(e4);
          }
          this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._terminal.scrollLines(t3 === 0 ? -1 : 1), this._rowElements[t3 === 0 ? 1 : this._rowElements.length - 2].focus(), e3.preventDefault(), e3.stopImmediatePropagation();
        }
        _handleResize(e3) {
          this._rowElements[this._rowElements.length - 1].removeEventListener("focus", this._bottomBoundaryFocusListener);
          for (let e4 = this._rowContainer.children.length;e4 < this._terminal.rows; e4++)
            this._rowElements[e4] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[e4]);
          for (;this._rowElements.length > e3; )
            this._rowContainer.removeChild(this._rowElements.pop());
          this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions();
        }
        _createAccessibilityTreeNode() {
          const e3 = this._coreBrowserService.mainDocument.createElement("div");
          return e3.setAttribute("role", "listitem"), e3.tabIndex = -1, this._refreshRowDimensions(e3), e3;
        }
        _refreshRowsDimensions() {
          if (this._renderService.dimensions.css.cell.height) {
            this._accessibilityContainer.style.width = `${this._renderService.dimensions.css.canvas.width}px`, this._rowElements.length !== this._terminal.rows && this._handleResize(this._terminal.rows);
            for (let e3 = 0;e3 < this._terminal.rows; e3++)
              this._refreshRowDimensions(this._rowElements[e3]);
          }
        }
        _refreshRowDimensions(e3) {
          e3.style.height = `${this._renderService.dimensions.css.cell.height}px`;
        }
      };
      t2.AccessibilityManager = l = s2([r(1, c.IInstantiationService), r(2, h.ICoreBrowserService), r(3, h.IRenderService)], l);
    }, 3614: (e2, t2) => {
      function i2(e3) {
        return e3.replace(/\r?\n/g, "\r");
      }
      function s2(e3, t3) {
        return t3 ? "[200~" + e3 + "[201~" : e3;
      }
      function r(e3, t3, r2, n2) {
        e3 = s2(e3 = i2(e3), r2.decPrivateModes.bracketedPasteMode && n2.rawOptions.ignoreBracketedPasteMode !== true), r2.triggerDataEvent(e3, true), t3.value = "";
      }
      function n(e3, t3, i3) {
        const s3 = i3.getBoundingClientRect(), r2 = e3.clientX - s3.left - 10, n2 = e3.clientY - s3.top - 10;
        t3.style.width = "20px", t3.style.height = "20px", t3.style.left = `${r2}px`, t3.style.top = `${n2}px`, t3.style.zIndex = "1000", t3.focus();
      }
      Object.defineProperty(t2, "__esModule", { value: true }), t2.rightClickHandler = t2.moveTextAreaUnderMouseCursor = t2.paste = t2.handlePasteEvent = t2.copyHandler = t2.bracketTextForPaste = t2.prepareTextForTerminal = undefined, t2.prepareTextForTerminal = i2, t2.bracketTextForPaste = s2, t2.copyHandler = function(e3, t3) {
        e3.clipboardData && e3.clipboardData.setData("text/plain", t3.selectionText), e3.preventDefault();
      }, t2.handlePasteEvent = function(e3, t3, i3, s3) {
        e3.stopPropagation(), e3.clipboardData && r(e3.clipboardData.getData("text/plain"), t3, i3, s3);
      }, t2.paste = r, t2.moveTextAreaUnderMouseCursor = n, t2.rightClickHandler = function(e3, t3, i3, s3, r2) {
        n(e3, t3, i3), r2 && s3.rightClickSelect(e3), t3.value = s3.selectionText, t3.select();
      };
    }, 7239: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.ColorContrastCache = undefined;
      const s2 = i2(1505);
      t2.ColorContrastCache = class {
        constructor() {
          this._color = new s2.TwoKeyMap, this._css = new s2.TwoKeyMap;
        }
        setCss(e3, t3, i3) {
          this._css.set(e3, t3, i3);
        }
        getCss(e3, t3) {
          return this._css.get(e3, t3);
        }
        setColor(e3, t3, i3) {
          this._color.set(e3, t3, i3);
        }
        getColor(e3, t3) {
          return this._color.get(e3, t3);
        }
        clear() {
          this._color.clear(), this._css.clear();
        }
      };
    }, 3656: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.addDisposableDomListener = undefined, t2.addDisposableDomListener = function(e3, t3, i2, s2) {
        e3.addEventListener(t3, i2, s2);
        let r = false;
        return { dispose: () => {
          r || (r = true, e3.removeEventListener(t3, i2, s2));
        } };
      };
    }, 6465: function(e2, t2, i2) {
      var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : s3 === null ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          o2 = Reflect.decorate(e3, t3, i3, s3);
        else
          for (var a2 = e3.length - 1;a2 >= 0; a2--)
            (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i3, s3) {
          t3(i3, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.Linkifier2 = undefined;
      const n = i2(3656), o = i2(8460), a = i2(844), h = i2(2585);
      let c = t2.Linkifier2 = class extends a.Disposable {
        get currentLink() {
          return this._currentLink;
        }
        constructor(e3) {
          super(), this._bufferService = e3, this._linkProviders = [], this._linkCacheDisposables = [], this._isMouseOut = true, this._wasResized = false, this._activeLine = -1, this._onShowLinkUnderline = this.register(new o.EventEmitter), this.onShowLinkUnderline = this._onShowLinkUnderline.event, this._onHideLinkUnderline = this.register(new o.EventEmitter), this.onHideLinkUnderline = this._onHideLinkUnderline.event, this.register((0, a.getDisposeArrayDisposable)(this._linkCacheDisposables)), this.register((0, a.toDisposable)(() => {
            this._lastMouseEvent = undefined;
          })), this.register(this._bufferService.onResize(() => {
            this._clearCurrentLink(), this._wasResized = true;
          }));
        }
        registerLinkProvider(e3) {
          return this._linkProviders.push(e3), { dispose: () => {
            const t3 = this._linkProviders.indexOf(e3);
            t3 !== -1 && this._linkProviders.splice(t3, 1);
          } };
        }
        attachToDom(e3, t3, i3) {
          this._element = e3, this._mouseService = t3, this._renderService = i3, this.register((0, n.addDisposableDomListener)(this._element, "mouseleave", () => {
            this._isMouseOut = true, this._clearCurrentLink();
          })), this.register((0, n.addDisposableDomListener)(this._element, "mousemove", this._handleMouseMove.bind(this))), this.register((0, n.addDisposableDomListener)(this._element, "mousedown", this._handleMouseDown.bind(this))), this.register((0, n.addDisposableDomListener)(this._element, "mouseup", this._handleMouseUp.bind(this)));
        }
        _handleMouseMove(e3) {
          if (this._lastMouseEvent = e3, !this._element || !this._mouseService)
            return;
          const t3 = this._positionFromMouseEvent(e3, this._element, this._mouseService);
          if (!t3)
            return;
          this._isMouseOut = false;
          const i3 = e3.composedPath();
          for (let e4 = 0;e4 < i3.length; e4++) {
            const t4 = i3[e4];
            if (t4.classList.contains("xterm"))
              break;
            if (t4.classList.contains("xterm-hover"))
              return;
          }
          this._lastBufferCell && t3.x === this._lastBufferCell.x && t3.y === this._lastBufferCell.y || (this._handleHover(t3), this._lastBufferCell = t3);
        }
        _handleHover(e3) {
          if (this._activeLine !== e3.y || this._wasResized)
            return this._clearCurrentLink(), this._askForLink(e3, false), void (this._wasResized = false);
          this._currentLink && this._linkAtPosition(this._currentLink.link, e3) || (this._clearCurrentLink(), this._askForLink(e3, true));
        }
        _askForLink(e3, t3) {
          this._activeProviderReplies && t3 || (this._activeProviderReplies?.forEach((e4) => {
            e4?.forEach((e5) => {
              e5.link.dispose && e5.link.dispose();
            });
          }), this._activeProviderReplies = new Map, this._activeLine = e3.y);
          let i3 = false;
          for (const [s3, r2] of this._linkProviders.entries())
            if (t3) {
              const t4 = this._activeProviderReplies?.get(s3);
              t4 && (i3 = this._checkLinkProviderResult(s3, e3, i3));
            } else
              r2.provideLinks(e3.y, (t4) => {
                if (this._isMouseOut)
                  return;
                const r3 = t4?.map((e4) => ({ link: e4 }));
                this._activeProviderReplies?.set(s3, r3), i3 = this._checkLinkProviderResult(s3, e3, i3), this._activeProviderReplies?.size === this._linkProviders.length && this._removeIntersectingLinks(e3.y, this._activeProviderReplies);
              });
        }
        _removeIntersectingLinks(e3, t3) {
          const i3 = new Set;
          for (let s3 = 0;s3 < t3.size; s3++) {
            const r2 = t3.get(s3);
            if (r2)
              for (let t4 = 0;t4 < r2.length; t4++) {
                const s4 = r2[t4], n2 = s4.link.range.start.y < e3 ? 0 : s4.link.range.start.x, o2 = s4.link.range.end.y > e3 ? this._bufferService.cols : s4.link.range.end.x;
                for (let e4 = n2;e4 <= o2; e4++) {
                  if (i3.has(e4)) {
                    r2.splice(t4--, 1);
                    break;
                  }
                  i3.add(e4);
                }
              }
          }
        }
        _checkLinkProviderResult(e3, t3, i3) {
          if (!this._activeProviderReplies)
            return i3;
          const s3 = this._activeProviderReplies.get(e3);
          let r2 = false;
          for (let t4 = 0;t4 < e3; t4++)
            this._activeProviderReplies.has(t4) && !this._activeProviderReplies.get(t4) || (r2 = true);
          if (!r2 && s3) {
            const e4 = s3.find((e5) => this._linkAtPosition(e5.link, t3));
            e4 && (i3 = true, this._handleNewLink(e4));
          }
          if (this._activeProviderReplies.size === this._linkProviders.length && !i3)
            for (let e4 = 0;e4 < this._activeProviderReplies.size; e4++) {
              const s4 = this._activeProviderReplies.get(e4)?.find((e5) => this._linkAtPosition(e5.link, t3));
              if (s4) {
                i3 = true, this._handleNewLink(s4);
                break;
              }
            }
          return i3;
        }
        _handleMouseDown() {
          this._mouseDownLink = this._currentLink;
        }
        _handleMouseUp(e3) {
          if (!this._element || !this._mouseService || !this._currentLink)
            return;
          const t3 = this._positionFromMouseEvent(e3, this._element, this._mouseService);
          t3 && this._mouseDownLink === this._currentLink && this._linkAtPosition(this._currentLink.link, t3) && this._currentLink.link.activate(e3, this._currentLink.link.text);
        }
        _clearCurrentLink(e3, t3) {
          this._element && this._currentLink && this._lastMouseEvent && (!e3 || !t3 || this._currentLink.link.range.start.y >= e3 && this._currentLink.link.range.end.y <= t3) && (this._linkLeave(this._element, this._currentLink.link, this._lastMouseEvent), this._currentLink = undefined, (0, a.disposeArray)(this._linkCacheDisposables));
        }
        _handleNewLink(e3) {
          if (!this._element || !this._lastMouseEvent || !this._mouseService)
            return;
          const t3 = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
          t3 && this._linkAtPosition(e3.link, t3) && (this._currentLink = e3, this._currentLink.state = { decorations: { underline: e3.link.decorations === undefined || e3.link.decorations.underline, pointerCursor: e3.link.decorations === undefined || e3.link.decorations.pointerCursor }, isHovered: true }, this._linkHover(this._element, e3.link, this._lastMouseEvent), e3.link.decorations = {}, Object.defineProperties(e3.link.decorations, { pointerCursor: { get: () => this._currentLink?.state?.decorations.pointerCursor, set: (e4) => {
            this._currentLink?.state && this._currentLink.state.decorations.pointerCursor !== e4 && (this._currentLink.state.decorations.pointerCursor = e4, this._currentLink.state.isHovered && this._element?.classList.toggle("xterm-cursor-pointer", e4));
          } }, underline: { get: () => this._currentLink?.state?.decorations.underline, set: (t4) => {
            this._currentLink?.state && this._currentLink?.state?.decorations.underline !== t4 && (this._currentLink.state.decorations.underline = t4, this._currentLink.state.isHovered && this._fireUnderlineEvent(e3.link, t4));
          } } }), this._renderService && this._linkCacheDisposables.push(this._renderService.onRenderedViewportChange((e4) => {
            if (!this._currentLink)
              return;
            const t4 = e4.start === 0 ? 0 : e4.start + 1 + this._bufferService.buffer.ydisp, i3 = this._bufferService.buffer.ydisp + 1 + e4.end;
            if (this._currentLink.link.range.start.y >= t4 && this._currentLink.link.range.end.y <= i3 && (this._clearCurrentLink(t4, i3), this._lastMouseEvent && this._element)) {
              const e5 = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
              e5 && this._askForLink(e5, false);
            }
          })));
        }
        _linkHover(e3, t3, i3) {
          this._currentLink?.state && (this._currentLink.state.isHovered = true, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(t3, true), this._currentLink.state.decorations.pointerCursor && e3.classList.add("xterm-cursor-pointer")), t3.hover && t3.hover(i3, t3.text);
        }
        _fireUnderlineEvent(e3, t3) {
          const i3 = e3.range, s3 = this._bufferService.buffer.ydisp, r2 = this._createLinkUnderlineEvent(i3.start.x - 1, i3.start.y - s3 - 1, i3.end.x, i3.end.y - s3 - 1, undefined);
          (t3 ? this._onShowLinkUnderline : this._onHideLinkUnderline).fire(r2);
        }
        _linkLeave(e3, t3, i3) {
          this._currentLink?.state && (this._currentLink.state.isHovered = false, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(t3, false), this._currentLink.state.decorations.pointerCursor && e3.classList.remove("xterm-cursor-pointer")), t3.leave && t3.leave(i3, t3.text);
        }
        _linkAtPosition(e3, t3) {
          const i3 = e3.range.start.y * this._bufferService.cols + e3.range.start.x, s3 = e3.range.end.y * this._bufferService.cols + e3.range.end.x, r2 = t3.y * this._bufferService.cols + t3.x;
          return i3 <= r2 && r2 <= s3;
        }
        _positionFromMouseEvent(e3, t3, i3) {
          const s3 = i3.getCoords(e3, t3, this._bufferService.cols, this._bufferService.rows);
          if (s3)
            return { x: s3[0], y: s3[1] + this._bufferService.buffer.ydisp };
        }
        _createLinkUnderlineEvent(e3, t3, i3, s3, r2) {
          return { x1: e3, y1: t3, x2: i3, y2: s3, cols: this._bufferService.cols, fg: r2 };
        }
      };
      t2.Linkifier2 = c = s2([r(0, h.IBufferService)], c);
    }, 9042: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.tooMuchOutput = t2.promptLabel = undefined, t2.promptLabel = "Terminal input", t2.tooMuchOutput = "Too much output to announce, navigate to rows manually to read";
    }, 3730: function(e2, t2, i2) {
      var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : s3 === null ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          o2 = Reflect.decorate(e3, t3, i3, s3);
        else
          for (var a2 = e3.length - 1;a2 >= 0; a2--)
            (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i3, s3) {
          t3(i3, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.OscLinkProvider = undefined;
      const n = i2(511), o = i2(2585);
      let a = t2.OscLinkProvider = class {
        constructor(e3, t3, i3) {
          this._bufferService = e3, this._optionsService = t3, this._oscLinkService = i3;
        }
        provideLinks(e3, t3) {
          const i3 = this._bufferService.buffer.lines.get(e3 - 1);
          if (!i3)
            return void t3(undefined);
          const s3 = [], r2 = this._optionsService.rawOptions.linkHandler, o2 = new n.CellData, a2 = i3.getTrimmedLength();
          let c = -1, l = -1, d = false;
          for (let t4 = 0;t4 < a2; t4++)
            if (l !== -1 || i3.hasContent(t4)) {
              if (i3.loadCell(t4, o2), o2.hasExtendedAttrs() && o2.extended.urlId) {
                if (l === -1) {
                  l = t4, c = o2.extended.urlId;
                  continue;
                }
                d = o2.extended.urlId !== c;
              } else
                l !== -1 && (d = true);
              if (d || l !== -1 && t4 === a2 - 1) {
                const i4 = this._oscLinkService.getLinkData(c)?.uri;
                if (i4) {
                  const n2 = { start: { x: l + 1, y: e3 }, end: { x: t4 + (d || t4 !== a2 - 1 ? 0 : 1), y: e3 } };
                  let o3 = false;
                  if (!r2?.allowNonHttpProtocols)
                    try {
                      const e4 = new URL(i4);
                      ["http:", "https:"].includes(e4.protocol) || (o3 = true);
                    } catch (e4) {
                      o3 = true;
                    }
                  o3 || s3.push({ text: i4, range: n2, activate: (e4, t5) => r2 ? r2.activate(e4, t5, n2) : h(0, t5), hover: (e4, t5) => r2?.hover?.(e4, t5, n2), leave: (e4, t5) => r2?.leave?.(e4, t5, n2) });
                }
                d = false, o2.hasExtendedAttrs() && o2.extended.urlId ? (l = t4, c = o2.extended.urlId) : (l = -1, c = -1);
              }
            }
          t3(s3);
        }
      };
      function h(e3, t3) {
        if (confirm(`Do you want to navigate to ${t3}?\n\nWARNING: This link could potentially be dangerous`)) {
          const e4 = window.open();
          if (e4) {
            try {
              e4.opener = null;
            } catch {
            }
            e4.location.href = t3;
          } else
            console.warn("Opening link blocked as opener could not be cleared");
        }
      }
      t2.OscLinkProvider = a = s2([r(0, o.IBufferService), r(1, o.IOptionsService), r(2, o.IOscLinkService)], a);
    }, 6193: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.RenderDebouncer = undefined, t2.RenderDebouncer = class {
        constructor(e3, t3) {
          this._parentWindow = e3, this._renderCallback = t3, this._refreshCallbacks = [];
        }
        dispose() {
          this._animationFrame && (this._parentWindow.cancelAnimationFrame(this._animationFrame), this._animationFrame = undefined);
        }
        addRefreshCallback(e3) {
          return this._refreshCallbacks.push(e3), this._animationFrame || (this._animationFrame = this._parentWindow.requestAnimationFrame(() => this._innerRefresh())), this._animationFrame;
        }
        refresh(e3, t3, i2) {
          this._rowCount = i2, e3 = e3 !== undefined ? e3 : 0, t3 = t3 !== undefined ? t3 : this._rowCount - 1, this._rowStart = this._rowStart !== undefined ? Math.min(this._rowStart, e3) : e3, this._rowEnd = this._rowEnd !== undefined ? Math.max(this._rowEnd, t3) : t3, this._animationFrame || (this._animationFrame = this._parentWindow.requestAnimationFrame(() => this._innerRefresh()));
        }
        _innerRefresh() {
          if (this._animationFrame = undefined, this._rowStart === undefined || this._rowEnd === undefined || this._rowCount === undefined)
            return void this._runRefreshCallbacks();
          const e3 = Math.max(this._rowStart, 0), t3 = Math.min(this._rowEnd, this._rowCount - 1);
          this._rowStart = undefined, this._rowEnd = undefined, this._renderCallback(e3, t3), this._runRefreshCallbacks();
        }
        _runRefreshCallbacks() {
          for (const e3 of this._refreshCallbacks)
            e3(0);
          this._refreshCallbacks = [];
        }
      };
    }, 3236: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.Terminal = undefined;
      const s2 = i2(3614), r = i2(3656), n = i2(6465), o = i2(9042), a = i2(3730), h = i2(1680), c = i2(3107), l = i2(5744), d = i2(2950), _ = i2(1296), u = i2(428), f = i2(4269), v = i2(5114), g = i2(8934), p = i2(3230), m = i2(9312), S = i2(4725), C = i2(6731), b = i2(8055), y = i2(8969), w = i2(8460), E = i2(844), k = i2(6114), L = i2(8437), D = i2(2584), R = i2(7399), x = i2(5941), A = i2(9074), B = i2(2585), T = i2(5435), M = i2(4567);

      class O extends y.CoreTerminal {
        get onFocus() {
          return this._onFocus.event;
        }
        get onBlur() {
          return this._onBlur.event;
        }
        get onA11yChar() {
          return this._onA11yCharEmitter.event;
        }
        get onA11yTab() {
          return this._onA11yTabEmitter.event;
        }
        get onWillOpen() {
          return this._onWillOpen.event;
        }
        constructor(e3 = {}) {
          super(e3), this.browser = k, this._keyDownHandled = false, this._keyDownSeen = false, this._keyPressHandled = false, this._unprocessedDeadKey = false, this._accessibilityManager = this.register(new E.MutableDisposable), this._onCursorMove = this.register(new w.EventEmitter), this.onCursorMove = this._onCursorMove.event, this._onKey = this.register(new w.EventEmitter), this.onKey = this._onKey.event, this._onRender = this.register(new w.EventEmitter), this.onRender = this._onRender.event, this._onSelectionChange = this.register(new w.EventEmitter), this.onSelectionChange = this._onSelectionChange.event, this._onTitleChange = this.register(new w.EventEmitter), this.onTitleChange = this._onTitleChange.event, this._onBell = this.register(new w.EventEmitter), this.onBell = this._onBell.event, this._onFocus = this.register(new w.EventEmitter), this._onBlur = this.register(new w.EventEmitter), this._onA11yCharEmitter = this.register(new w.EventEmitter), this._onA11yTabEmitter = this.register(new w.EventEmitter), this._onWillOpen = this.register(new w.EventEmitter), this._setup(), this.linkifier2 = this.register(this._instantiationService.createInstance(n.Linkifier2)), this.linkifier2.registerLinkProvider(this._instantiationService.createInstance(a.OscLinkProvider)), this._decorationService = this._instantiationService.createInstance(A.DecorationService), this._instantiationService.setService(B.IDecorationService, this._decorationService), this.register(this._inputHandler.onRequestBell(() => this._onBell.fire())), this.register(this._inputHandler.onRequestRefreshRows((e4, t3) => this.refresh(e4, t3))), this.register(this._inputHandler.onRequestSendFocus(() => this._reportFocus())), this.register(this._inputHandler.onRequestReset(() => this.reset())), this.register(this._inputHandler.onRequestWindowsOptionsReport((e4) => this._reportWindowsOptions(e4))), this.register(this._inputHandler.onColor((e4) => this._handleColorEvent(e4))), this.register((0, w.forwardEvent)(this._inputHandler.onCursorMove, this._onCursorMove)), this.register((0, w.forwardEvent)(this._inputHandler.onTitleChange, this._onTitleChange)), this.register((0, w.forwardEvent)(this._inputHandler.onA11yChar, this._onA11yCharEmitter)), this.register((0, w.forwardEvent)(this._inputHandler.onA11yTab, this._onA11yTabEmitter)), this.register(this._bufferService.onResize((e4) => this._afterResize(e4.cols, e4.rows))), this.register((0, E.toDisposable)(() => {
            this._customKeyEventHandler = undefined, this.element?.parentNode?.removeChild(this.element);
          }));
        }
        _handleColorEvent(e3) {
          if (this._themeService)
            for (const t3 of e3) {
              let e4, i3 = "";
              switch (t3.index) {
                case 256:
                  e4 = "foreground", i3 = "10";
                  break;
                case 257:
                  e4 = "background", i3 = "11";
                  break;
                case 258:
                  e4 = "cursor", i3 = "12";
                  break;
                default:
                  e4 = "ansi", i3 = "4;" + t3.index;
              }
              switch (t3.type) {
                case 0:
                  const s3 = b.color.toColorRGB(e4 === "ansi" ? this._themeService.colors.ansi[t3.index] : this._themeService.colors[e4]);
                  this.coreService.triggerDataEvent(`${D.C0.ESC}]${i3};${(0, x.toRgbString)(s3)}${D.C1_ESCAPED.ST}`);
                  break;
                case 1:
                  if (e4 === "ansi")
                    this._themeService.modifyColors((e5) => e5.ansi[t3.index] = b.rgba.toColor(...t3.color));
                  else {
                    const i4 = e4;
                    this._themeService.modifyColors((e5) => e5[i4] = b.rgba.toColor(...t3.color));
                  }
                  break;
                case 2:
                  this._themeService.restoreColor(t3.index);
              }
            }
        }
        _setup() {
          super._setup(), this._customKeyEventHandler = undefined;
        }
        get buffer() {
          return this.buffers.active;
        }
        focus() {
          this.textarea && this.textarea.focus({ preventScroll: true });
        }
        _handleScreenReaderModeOptionChange(e3) {
          e3 ? !this._accessibilityManager.value && this._renderService && (this._accessibilityManager.value = this._instantiationService.createInstance(M.AccessibilityManager, this)) : this._accessibilityManager.clear();
        }
        _handleTextAreaFocus(e3) {
          this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(D.C0.ESC + "[I"), this.updateCursorStyle(e3), this.element.classList.add("focus"), this._showCursor(), this._onFocus.fire();
        }
        blur() {
          return this.textarea?.blur();
        }
        _handleTextAreaBlur() {
          this.textarea.value = "", this.refresh(this.buffer.y, this.buffer.y), this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(D.C0.ESC + "[O"), this.element.classList.remove("focus"), this._onBlur.fire();
        }
        _syncTextArea() {
          if (!this.textarea || !this.buffer.isCursorInViewport || this._compositionHelper.isComposing || !this._renderService)
            return;
          const e3 = this.buffer.ybase + this.buffer.y, t3 = this.buffer.lines.get(e3);
          if (!t3)
            return;
          const i3 = Math.min(this.buffer.x, this.cols - 1), s3 = this._renderService.dimensions.css.cell.height, r2 = t3.getWidth(i3), n2 = this._renderService.dimensions.css.cell.width * r2, o2 = this.buffer.y * this._renderService.dimensions.css.cell.height, a2 = i3 * this._renderService.dimensions.css.cell.width;
          this.textarea.style.left = a2 + "px", this.textarea.style.top = o2 + "px", this.textarea.style.width = n2 + "px", this.textarea.style.height = s3 + "px", this.textarea.style.lineHeight = s3 + "px", this.textarea.style.zIndex = "-5";
        }
        _initGlobal() {
          this._bindKeys(), this.register((0, r.addDisposableDomListener)(this.element, "copy", (e4) => {
            this.hasSelection() && (0, s2.copyHandler)(e4, this._selectionService);
          }));
          const e3 = (e4) => (0, s2.handlePasteEvent)(e4, this.textarea, this.coreService, this.optionsService);
          this.register((0, r.addDisposableDomListener)(this.textarea, "paste", e3)), this.register((0, r.addDisposableDomListener)(this.element, "paste", e3)), k.isFirefox ? this.register((0, r.addDisposableDomListener)(this.element, "mousedown", (e4) => {
            e4.button === 2 && (0, s2.rightClickHandler)(e4, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
          })) : this.register((0, r.addDisposableDomListener)(this.element, "contextmenu", (e4) => {
            (0, s2.rightClickHandler)(e4, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
          })), k.isLinux && this.register((0, r.addDisposableDomListener)(this.element, "auxclick", (e4) => {
            e4.button === 1 && (0, s2.moveTextAreaUnderMouseCursor)(e4, this.textarea, this.screenElement);
          }));
        }
        _bindKeys() {
          this.register((0, r.addDisposableDomListener)(this.textarea, "keyup", (e3) => this._keyUp(e3), true)), this.register((0, r.addDisposableDomListener)(this.textarea, "keydown", (e3) => this._keyDown(e3), true)), this.register((0, r.addDisposableDomListener)(this.textarea, "keypress", (e3) => this._keyPress(e3), true)), this.register((0, r.addDisposableDomListener)(this.textarea, "compositionstart", () => this._compositionHelper.compositionstart())), this.register((0, r.addDisposableDomListener)(this.textarea, "compositionupdate", (e3) => this._compositionHelper.compositionupdate(e3))), this.register((0, r.addDisposableDomListener)(this.textarea, "compositionend", () => this._compositionHelper.compositionend())), this.register((0, r.addDisposableDomListener)(this.textarea, "input", (e3) => this._inputEvent(e3), true)), this.register(this.onRender(() => this._compositionHelper.updateCompositionElements()));
        }
        open(e3) {
          if (!e3)
            throw new Error("Terminal requires a parent element.");
          if (e3.isConnected || this._logService.debug("Terminal.open was called on an element that was not attached to the DOM"), this.element?.ownerDocument.defaultView && this._coreBrowserService)
            return void (this.element.ownerDocument.defaultView !== this._coreBrowserService.window && (this._coreBrowserService.window = this.element.ownerDocument.defaultView));
          this._document = e3.ownerDocument, this.options.documentOverride && this.options.documentOverride instanceof Document && (this._document = this.optionsService.rawOptions.documentOverride), this.element = this._document.createElement("div"), this.element.dir = "ltr", this.element.classList.add("terminal"), this.element.classList.add("xterm"), e3.appendChild(this.element);
          const t3 = this._document.createDocumentFragment();
          this._viewportElement = this._document.createElement("div"), this._viewportElement.classList.add("xterm-viewport"), t3.appendChild(this._viewportElement), this._viewportScrollArea = this._document.createElement("div"), this._viewportScrollArea.classList.add("xterm-scroll-area"), this._viewportElement.appendChild(this._viewportScrollArea), this.screenElement = this._document.createElement("div"), this.screenElement.classList.add("xterm-screen"), this._helperContainer = this._document.createElement("div"), this._helperContainer.classList.add("xterm-helpers"), this.screenElement.appendChild(this._helperContainer), t3.appendChild(this.screenElement), this.textarea = this._document.createElement("textarea"), this.textarea.classList.add("xterm-helper-textarea"), this.textarea.setAttribute("aria-label", o.promptLabel), k.isChromeOS || this.textarea.setAttribute("aria-multiline", "false"), this.textarea.setAttribute("autocorrect", "off"), this.textarea.setAttribute("autocapitalize", "off"), this.textarea.setAttribute("spellcheck", "false"), this.textarea.tabIndex = 0, this._coreBrowserService = this.register(this._instantiationService.createInstance(v.CoreBrowserService, this.textarea, e3.ownerDocument.defaultView ?? window, this._document ?? typeof window != "undefined" ? window.document : null)), this._instantiationService.setService(S.ICoreBrowserService, this._coreBrowserService), this.register((0, r.addDisposableDomListener)(this.textarea, "focus", (e4) => this._handleTextAreaFocus(e4))), this.register((0, r.addDisposableDomListener)(this.textarea, "blur", () => this._handleTextAreaBlur())), this._helperContainer.appendChild(this.textarea), this._charSizeService = this._instantiationService.createInstance(u.CharSizeService, this._document, this._helperContainer), this._instantiationService.setService(S.ICharSizeService, this._charSizeService), this._themeService = this._instantiationService.createInstance(C.ThemeService), this._instantiationService.setService(S.IThemeService, this._themeService), this._characterJoinerService = this._instantiationService.createInstance(f.CharacterJoinerService), this._instantiationService.setService(S.ICharacterJoinerService, this._characterJoinerService), this._renderService = this.register(this._instantiationService.createInstance(p.RenderService, this.rows, this.screenElement)), this._instantiationService.setService(S.IRenderService, this._renderService), this.register(this._renderService.onRenderedViewportChange((e4) => this._onRender.fire(e4))), this.onResize((e4) => this._renderService.resize(e4.cols, e4.rows)), this._compositionView = this._document.createElement("div"), this._compositionView.classList.add("composition-view"), this._compositionHelper = this._instantiationService.createInstance(d.CompositionHelper, this.textarea, this._compositionView), this._helperContainer.appendChild(this._compositionView), this.element.appendChild(t3);
          try {
            this._onWillOpen.fire(this.element);
          } catch {
          }
          this._renderService.hasRenderer() || this._renderService.setRenderer(this._createRenderer()), this._mouseService = this._instantiationService.createInstance(g.MouseService), this._instantiationService.setService(S.IMouseService, this._mouseService), this.viewport = this._instantiationService.createInstance(h.Viewport, this._viewportElement, this._viewportScrollArea), this.viewport.onRequestScrollLines((e4) => this.scrollLines(e4.amount, e4.suppressScrollEvent, 1)), this.register(this._inputHandler.onRequestSyncScrollBar(() => this.viewport.syncScrollArea())), this.register(this.viewport), this.register(this.onCursorMove(() => {
            this._renderService.handleCursorMove(), this._syncTextArea();
          })), this.register(this.onResize(() => this._renderService.handleResize(this.cols, this.rows))), this.register(this.onBlur(() => this._renderService.handleBlur())), this.register(this.onFocus(() => this._renderService.handleFocus())), this.register(this._renderService.onDimensionsChange(() => this.viewport.syncScrollArea())), this._selectionService = this.register(this._instantiationService.createInstance(m.SelectionService, this.element, this.screenElement, this.linkifier2)), this._instantiationService.setService(S.ISelectionService, this._selectionService), this.register(this._selectionService.onRequestScrollLines((e4) => this.scrollLines(e4.amount, e4.suppressScrollEvent))), this.register(this._selectionService.onSelectionChange(() => this._onSelectionChange.fire())), this.register(this._selectionService.onRequestRedraw((e4) => this._renderService.handleSelectionChanged(e4.start, e4.end, e4.columnSelectMode))), this.register(this._selectionService.onLinuxMouseSelection((e4) => {
            this.textarea.value = e4, this.textarea.focus(), this.textarea.select();
          })), this.register(this._onScroll.event((e4) => {
            this.viewport.syncScrollArea(), this._selectionService.refresh();
          })), this.register((0, r.addDisposableDomListener)(this._viewportElement, "scroll", () => this._selectionService.refresh())), this.linkifier2.attachToDom(this.screenElement, this._mouseService, this._renderService), this.register(this._instantiationService.createInstance(c.BufferDecorationRenderer, this.screenElement)), this.register((0, r.addDisposableDomListener)(this.element, "mousedown", (e4) => this._selectionService.handleMouseDown(e4))), this.coreMouseService.areMouseEventsActive ? (this._selectionService.disable(), this.element.classList.add("enable-mouse-events")) : this._selectionService.enable(), this.options.screenReaderMode && (this._accessibilityManager.value = this._instantiationService.createInstance(M.AccessibilityManager, this)), this.register(this.optionsService.onSpecificOptionChange("screenReaderMode", (e4) => this._handleScreenReaderModeOptionChange(e4))), this.options.overviewRulerWidth && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(l.OverviewRulerRenderer, this._viewportElement, this.screenElement))), this.optionsService.onSpecificOptionChange("overviewRulerWidth", (e4) => {
            !this._overviewRulerRenderer && e4 && this._viewportElement && this.screenElement && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(l.OverviewRulerRenderer, this._viewportElement, this.screenElement)));
          }), this._charSizeService.measure(), this.refresh(0, this.rows - 1), this._initGlobal(), this.bindMouse();
        }
        _createRenderer() {
          return this._instantiationService.createInstance(_.DomRenderer, this._document, this.element, this.screenElement, this._viewportElement, this._helperContainer, this.linkifier2);
        }
        bindMouse() {
          const e3 = this, t3 = this.element;
          function i3(t4) {
            const i4 = e3._mouseService.getMouseReportCoords(t4, e3.screenElement);
            if (!i4)
              return false;
            let s4, r2;
            switch (t4.overrideType || t4.type) {
              case "mousemove":
                r2 = 32, t4.buttons === undefined ? (s4 = 3, t4.button !== undefined && (s4 = t4.button < 3 ? t4.button : 3)) : s4 = 1 & t4.buttons ? 0 : 4 & t4.buttons ? 1 : 2 & t4.buttons ? 2 : 3;
                break;
              case "mouseup":
                r2 = 0, s4 = t4.button < 3 ? t4.button : 3;
                break;
              case "mousedown":
                r2 = 1, s4 = t4.button < 3 ? t4.button : 3;
                break;
              case "wheel":
                if (e3.viewport.getLinesScrolled(t4) === 0)
                  return false;
                r2 = t4.deltaY < 0 ? 0 : 1, s4 = 4;
                break;
              default:
                return false;
            }
            return !(r2 === undefined || s4 === undefined || s4 > 4) && e3.coreMouseService.triggerMouseEvent({ col: i4.col, row: i4.row, x: i4.x, y: i4.y, button: s4, action: r2, ctrl: t4.ctrlKey, alt: t4.altKey, shift: t4.shiftKey });
          }
          const s3 = { mouseup: null, wheel: null, mousedrag: null, mousemove: null }, n2 = { mouseup: (e4) => (i3(e4), e4.buttons || (this._document.removeEventListener("mouseup", s3.mouseup), s3.mousedrag && this._document.removeEventListener("mousemove", s3.mousedrag)), this.cancel(e4)), wheel: (e4) => (i3(e4), this.cancel(e4, true)), mousedrag: (e4) => {
            e4.buttons && i3(e4);
          }, mousemove: (e4) => {
            e4.buttons || i3(e4);
          } };
          this.register(this.coreMouseService.onProtocolChange((e4) => {
            e4 ? (this.optionsService.rawOptions.logLevel === "debug" && this._logService.debug("Binding to mouse events:", this.coreMouseService.explainEvents(e4)), this.element.classList.add("enable-mouse-events"), this._selectionService.disable()) : (this._logService.debug("Unbinding from mouse events."), this.element.classList.remove("enable-mouse-events"), this._selectionService.enable()), 8 & e4 ? s3.mousemove || (t3.addEventListener("mousemove", n2.mousemove), s3.mousemove = n2.mousemove) : (t3.removeEventListener("mousemove", s3.mousemove), s3.mousemove = null), 16 & e4 ? s3.wheel || (t3.addEventListener("wheel", n2.wheel, { passive: false }), s3.wheel = n2.wheel) : (t3.removeEventListener("wheel", s3.wheel), s3.wheel = null), 2 & e4 ? s3.mouseup || (s3.mouseup = n2.mouseup) : (this._document.removeEventListener("mouseup", s3.mouseup), s3.mouseup = null), 4 & e4 ? s3.mousedrag || (s3.mousedrag = n2.mousedrag) : (this._document.removeEventListener("mousemove", s3.mousedrag), s3.mousedrag = null);
          })), this.coreMouseService.activeProtocol = this.coreMouseService.activeProtocol, this.register((0, r.addDisposableDomListener)(t3, "mousedown", (e4) => {
            if (e4.preventDefault(), this.focus(), this.coreMouseService.areMouseEventsActive && !this._selectionService.shouldForceSelection(e4))
              return i3(e4), s3.mouseup && this._document.addEventListener("mouseup", s3.mouseup), s3.mousedrag && this._document.addEventListener("mousemove", s3.mousedrag), this.cancel(e4);
          })), this.register((0, r.addDisposableDomListener)(t3, "wheel", (e4) => {
            if (!s3.wheel) {
              if (!this.buffer.hasScrollback) {
                const t4 = this.viewport.getLinesScrolled(e4);
                if (t4 === 0)
                  return;
                const i4 = D.C0.ESC + (this.coreService.decPrivateModes.applicationCursorKeys ? "O" : "[") + (e4.deltaY < 0 ? "A" : "B");
                let s4 = "";
                for (let e5 = 0;e5 < Math.abs(t4); e5++)
                  s4 += i4;
                return this.coreService.triggerDataEvent(s4, true), this.cancel(e4, true);
              }
              return this.viewport.handleWheel(e4) ? this.cancel(e4) : undefined;
            }
          }, { passive: false })), this.register((0, r.addDisposableDomListener)(t3, "touchstart", (e4) => {
            if (!this.coreMouseService.areMouseEventsActive)
              return this.viewport.handleTouchStart(e4), this.cancel(e4);
          }, { passive: true })), this.register((0, r.addDisposableDomListener)(t3, "touchmove", (e4) => {
            if (!this.coreMouseService.areMouseEventsActive)
              return this.viewport.handleTouchMove(e4) ? undefined : this.cancel(e4);
          }, { passive: false }));
        }
        refresh(e3, t3) {
          this._renderService?.refreshRows(e3, t3);
        }
        updateCursorStyle(e3) {
          this._selectionService?.shouldColumnSelect(e3) ? this.element.classList.add("column-select") : this.element.classList.remove("column-select");
        }
        _showCursor() {
          this.coreService.isCursorInitialized || (this.coreService.isCursorInitialized = true, this.refresh(this.buffer.y, this.buffer.y));
        }
        scrollLines(e3, t3, i3 = 0) {
          i3 === 1 ? (super.scrollLines(e3, t3, i3), this.refresh(0, this.rows - 1)) : this.viewport?.scrollLines(e3);
        }
        paste(e3) {
          (0, s2.paste)(e3, this.textarea, this.coreService, this.optionsService);
        }
        attachCustomKeyEventHandler(e3) {
          this._customKeyEventHandler = e3;
        }
        registerLinkProvider(e3) {
          return this.linkifier2.registerLinkProvider(e3);
        }
        registerCharacterJoiner(e3) {
          if (!this._characterJoinerService)
            throw new Error("Terminal must be opened first");
          const t3 = this._characterJoinerService.register(e3);
          return this.refresh(0, this.rows - 1), t3;
        }
        deregisterCharacterJoiner(e3) {
          if (!this._characterJoinerService)
            throw new Error("Terminal must be opened first");
          this._characterJoinerService.deregister(e3) && this.refresh(0, this.rows - 1);
        }
        get markers() {
          return this.buffer.markers;
        }
        registerMarker(e3) {
          return this.buffer.addMarker(this.buffer.ybase + this.buffer.y + e3);
        }
        registerDecoration(e3) {
          return this._decorationService.registerDecoration(e3);
        }
        hasSelection() {
          return !!this._selectionService && this._selectionService.hasSelection;
        }
        select(e3, t3, i3) {
          this._selectionService.setSelection(e3, t3, i3);
        }
        getSelection() {
          return this._selectionService ? this._selectionService.selectionText : "";
        }
        getSelectionPosition() {
          if (this._selectionService && this._selectionService.hasSelection)
            return { start: { x: this._selectionService.selectionStart[0], y: this._selectionService.selectionStart[1] }, end: { x: this._selectionService.selectionEnd[0], y: this._selectionService.selectionEnd[1] } };
        }
        clearSelection() {
          this._selectionService?.clearSelection();
        }
        selectAll() {
          this._selectionService?.selectAll();
        }
        selectLines(e3, t3) {
          this._selectionService?.selectLines(e3, t3);
        }
        _keyDown(e3) {
          if (this._keyDownHandled = false, this._keyDownSeen = true, this._customKeyEventHandler && this._customKeyEventHandler(e3) === false)
            return false;
          const t3 = this.browser.isMac && this.options.macOptionIsMeta && e3.altKey;
          if (!t3 && !this._compositionHelper.keydown(e3))
            return this.options.scrollOnUserInput && this.buffer.ybase !== this.buffer.ydisp && this.scrollToBottom(), false;
          t3 || e3.key !== "Dead" && e3.key !== "AltGraph" || (this._unprocessedDeadKey = true);
          const i3 = (0, R.evaluateKeyboardEvent)(e3, this.coreService.decPrivateModes.applicationCursorKeys, this.browser.isMac, this.options.macOptionIsMeta);
          if (this.updateCursorStyle(e3), i3.type === 3 || i3.type === 2) {
            const t4 = this.rows - 1;
            return this.scrollLines(i3.type === 2 ? -t4 : t4), this.cancel(e3, true);
          }
          return i3.type === 1 && this.selectAll(), !!this._isThirdLevelShift(this.browser, e3) || (i3.cancel && this.cancel(e3, true), !i3.key || !!(e3.key && !e3.ctrlKey && !e3.altKey && !e3.metaKey && e3.key.length === 1 && e3.key.charCodeAt(0) >= 65 && e3.key.charCodeAt(0) <= 90) || (this._unprocessedDeadKey ? (this._unprocessedDeadKey = false, true) : (i3.key !== D.C0.ETX && i3.key !== D.C0.CR || (this.textarea.value = ""), this._onKey.fire({ key: i3.key, domEvent: e3 }), this._showCursor(), this.coreService.triggerDataEvent(i3.key, true), !this.optionsService.rawOptions.screenReaderMode || e3.altKey || e3.ctrlKey ? this.cancel(e3, true) : void (this._keyDownHandled = true))));
        }
        _isThirdLevelShift(e3, t3) {
          const i3 = e3.isMac && !this.options.macOptionIsMeta && t3.altKey && !t3.ctrlKey && !t3.metaKey || e3.isWindows && t3.altKey && t3.ctrlKey && !t3.metaKey || e3.isWindows && t3.getModifierState("AltGraph");
          return t3.type === "keypress" ? i3 : i3 && (!t3.keyCode || t3.keyCode > 47);
        }
        _keyUp(e3) {
          this._keyDownSeen = false, this._customKeyEventHandler && this._customKeyEventHandler(e3) === false || (function(e4) {
            return e4.keyCode === 16 || e4.keyCode === 17 || e4.keyCode === 18;
          }(e3) || this.focus(), this.updateCursorStyle(e3), this._keyPressHandled = false);
        }
        _keyPress(e3) {
          let t3;
          if (this._keyPressHandled = false, this._keyDownHandled)
            return false;
          if (this._customKeyEventHandler && this._customKeyEventHandler(e3) === false)
            return false;
          if (this.cancel(e3), e3.charCode)
            t3 = e3.charCode;
          else if (e3.which === null || e3.which === undefined)
            t3 = e3.keyCode;
          else {
            if (e3.which === 0 || e3.charCode === 0)
              return false;
            t3 = e3.which;
          }
          return !(!t3 || (e3.altKey || e3.ctrlKey || e3.metaKey) && !this._isThirdLevelShift(this.browser, e3) || (t3 = String.fromCharCode(t3), this._onKey.fire({ key: t3, domEvent: e3 }), this._showCursor(), this.coreService.triggerDataEvent(t3, true), this._keyPressHandled = true, this._unprocessedDeadKey = false, 0));
        }
        _inputEvent(e3) {
          if (e3.data && e3.inputType === "insertText" && (!e3.composed || !this._keyDownSeen) && !this.optionsService.rawOptions.screenReaderMode) {
            if (this._keyPressHandled)
              return false;
            this._unprocessedDeadKey = false;
            const t3 = e3.data;
            return this.coreService.triggerDataEvent(t3, true), this.cancel(e3), true;
          }
          return false;
        }
        resize(e3, t3) {
          e3 !== this.cols || t3 !== this.rows ? super.resize(e3, t3) : this._charSizeService && !this._charSizeService.hasValidSize && this._charSizeService.measure();
        }
        _afterResize(e3, t3) {
          this._charSizeService?.measure(), this.viewport?.syncScrollArea(true);
        }
        clear() {
          if (this.buffer.ybase !== 0 || this.buffer.y !== 0) {
            this.buffer.clearAllMarkers(), this.buffer.lines.set(0, this.buffer.lines.get(this.buffer.ybase + this.buffer.y)), this.buffer.lines.length = 1, this.buffer.ydisp = 0, this.buffer.ybase = 0, this.buffer.y = 0;
            for (let e3 = 1;e3 < this.rows; e3++)
              this.buffer.lines.push(this.buffer.getBlankLine(L.DEFAULT_ATTR_DATA));
            this._onScroll.fire({ position: this.buffer.ydisp, source: 0 }), this.viewport?.reset(), this.refresh(0, this.rows - 1);
          }
        }
        reset() {
          this.options.rows = this.rows, this.options.cols = this.cols;
          const e3 = this._customKeyEventHandler;
          this._setup(), super.reset(), this._selectionService?.reset(), this._decorationService.reset(), this.viewport?.reset(), this._customKeyEventHandler = e3, this.refresh(0, this.rows - 1);
        }
        clearTextureAtlas() {
          this._renderService?.clearTextureAtlas();
        }
        _reportFocus() {
          this.element?.classList.contains("focus") ? this.coreService.triggerDataEvent(D.C0.ESC + "[I") : this.coreService.triggerDataEvent(D.C0.ESC + "[O");
        }
        _reportWindowsOptions(e3) {
          if (this._renderService)
            switch (e3) {
              case T.WindowsOptionsReportType.GET_WIN_SIZE_PIXELS:
                const e4 = this._renderService.dimensions.css.canvas.width.toFixed(0), t3 = this._renderService.dimensions.css.canvas.height.toFixed(0);
                this.coreService.triggerDataEvent(`${D.C0.ESC}[4;${t3};${e4}t`);
                break;
              case T.WindowsOptionsReportType.GET_CELL_SIZE_PIXELS:
                const i3 = this._renderService.dimensions.css.cell.width.toFixed(0), s3 = this._renderService.dimensions.css.cell.height.toFixed(0);
                this.coreService.triggerDataEvent(`${D.C0.ESC}[6;${s3};${i3}t`);
            }
        }
        cancel(e3, t3) {
          if (this.options.cancelEvents || t3)
            return e3.preventDefault(), e3.stopPropagation(), false;
        }
      }
      t2.Terminal = O;
    }, 9924: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.TimeBasedDebouncer = undefined, t2.TimeBasedDebouncer = class {
        constructor(e3, t3 = 1000) {
          this._renderCallback = e3, this._debounceThresholdMS = t3, this._lastRefreshMs = 0, this._additionalRefreshRequested = false;
        }
        dispose() {
          this._refreshTimeoutID && clearTimeout(this._refreshTimeoutID);
        }
        refresh(e3, t3, i2) {
          this._rowCount = i2, e3 = e3 !== undefined ? e3 : 0, t3 = t3 !== undefined ? t3 : this._rowCount - 1, this._rowStart = this._rowStart !== undefined ? Math.min(this._rowStart, e3) : e3, this._rowEnd = this._rowEnd !== undefined ? Math.max(this._rowEnd, t3) : t3;
          const s2 = Date.now();
          if (s2 - this._lastRefreshMs >= this._debounceThresholdMS)
            this._lastRefreshMs = s2, this._innerRefresh();
          else if (!this._additionalRefreshRequested) {
            const e4 = s2 - this._lastRefreshMs, t4 = this._debounceThresholdMS - e4;
            this._additionalRefreshRequested = true, this._refreshTimeoutID = window.setTimeout(() => {
              this._lastRefreshMs = Date.now(), this._innerRefresh(), this._additionalRefreshRequested = false, this._refreshTimeoutID = undefined;
            }, t4);
          }
        }
        _innerRefresh() {
          if (this._rowStart === undefined || this._rowEnd === undefined || this._rowCount === undefined)
            return;
          const e3 = Math.max(this._rowStart, 0), t3 = Math.min(this._rowEnd, this._rowCount - 1);
          this._rowStart = undefined, this._rowEnd = undefined, this._renderCallback(e3, t3);
        }
      };
    }, 1680: function(e2, t2, i2) {
      var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : s3 === null ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          o2 = Reflect.decorate(e3, t3, i3, s3);
        else
          for (var a2 = e3.length - 1;a2 >= 0; a2--)
            (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i3, s3) {
          t3(i3, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.Viewport = undefined;
      const n = i2(3656), o = i2(4725), a = i2(8460), h = i2(844), c = i2(2585);
      let l = t2.Viewport = class extends h.Disposable {
        constructor(e3, t3, i3, s3, r2, o2, h2, c2) {
          super(), this._viewportElement = e3, this._scrollArea = t3, this._bufferService = i3, this._optionsService = s3, this._charSizeService = r2, this._renderService = o2, this._coreBrowserService = h2, this.scrollBarWidth = 0, this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._wheelPartialScroll = 0, this._refreshAnimationFrame = null, this._ignoreNextScrollEvent = false, this._smoothScrollState = { startTime: 0, origin: -1, target: -1 }, this._onRequestScrollLines = this.register(new a.EventEmitter), this.onRequestScrollLines = this._onRequestScrollLines.event, this.scrollBarWidth = this._viewportElement.offsetWidth - this._scrollArea.offsetWidth || 15, this.register((0, n.addDisposableDomListener)(this._viewportElement, "scroll", this._handleScroll.bind(this))), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate((e4) => this._activeBuffer = e4.activeBuffer)), this._renderDimensions = this._renderService.dimensions, this.register(this._renderService.onDimensionsChange((e4) => this._renderDimensions = e4)), this._handleThemeChange(c2.colors), this.register(c2.onChangeColors((e4) => this._handleThemeChange(e4))), this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.syncScrollArea())), setTimeout(() => this.syncScrollArea());
        }
        _handleThemeChange(e3) {
          this._viewportElement.style.backgroundColor = e3.background.css;
        }
        reset() {
          this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._coreBrowserService.window.requestAnimationFrame(() => this.syncScrollArea());
        }
        _refresh(e3) {
          if (e3)
            return this._innerRefresh(), void (this._refreshAnimationFrame !== null && this._coreBrowserService.window.cancelAnimationFrame(this._refreshAnimationFrame));
          this._refreshAnimationFrame === null && (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._innerRefresh()));
        }
        _innerRefresh() {
          if (this._charSizeService.height > 0) {
            this._currentRowHeight = this._renderDimensions.device.cell.height / this._coreBrowserService.dpr, this._currentDeviceCellHeight = this._renderDimensions.device.cell.height, this._lastRecordedViewportHeight = this._viewportElement.offsetHeight;
            const e4 = Math.round(this._currentRowHeight * this._lastRecordedBufferLength) + (this._lastRecordedViewportHeight - this._renderDimensions.css.canvas.height);
            this._lastRecordedBufferHeight !== e4 && (this._lastRecordedBufferHeight = e4, this._scrollArea.style.height = this._lastRecordedBufferHeight + "px");
          }
          const e3 = this._bufferService.buffer.ydisp * this._currentRowHeight;
          this._viewportElement.scrollTop !== e3 && (this._ignoreNextScrollEvent = true, this._viewportElement.scrollTop = e3), this._refreshAnimationFrame = null;
        }
        syncScrollArea(e3 = false) {
          if (this._lastRecordedBufferLength !== this._bufferService.buffer.lines.length)
            return this._lastRecordedBufferLength = this._bufferService.buffer.lines.length, void this._refresh(e3);
          this._lastRecordedViewportHeight === this._renderService.dimensions.css.canvas.height && this._lastScrollTop === this._activeBuffer.ydisp * this._currentRowHeight && this._renderDimensions.device.cell.height === this._currentDeviceCellHeight || this._refresh(e3);
        }
        _handleScroll(e3) {
          if (this._lastScrollTop = this._viewportElement.scrollTop, !this._viewportElement.offsetParent)
            return;
          if (this._ignoreNextScrollEvent)
            return this._ignoreNextScrollEvent = false, void this._onRequestScrollLines.fire({ amount: 0, suppressScrollEvent: true });
          const t3 = Math.round(this._lastScrollTop / this._currentRowHeight) - this._bufferService.buffer.ydisp;
          this._onRequestScrollLines.fire({ amount: t3, suppressScrollEvent: true });
        }
        _smoothScroll() {
          if (this._isDisposed || this._smoothScrollState.origin === -1 || this._smoothScrollState.target === -1)
            return;
          const e3 = this._smoothScrollPercent();
          this._viewportElement.scrollTop = this._smoothScrollState.origin + Math.round(e3 * (this._smoothScrollState.target - this._smoothScrollState.origin)), e3 < 1 ? this._coreBrowserService.window.requestAnimationFrame(() => this._smoothScroll()) : this._clearSmoothScrollState();
        }
        _smoothScrollPercent() {
          return this._optionsService.rawOptions.smoothScrollDuration && this._smoothScrollState.startTime ? Math.max(Math.min((Date.now() - this._smoothScrollState.startTime) / this._optionsService.rawOptions.smoothScrollDuration, 1), 0) : 1;
        }
        _clearSmoothScrollState() {
          this._smoothScrollState.startTime = 0, this._smoothScrollState.origin = -1, this._smoothScrollState.target = -1;
        }
        _bubbleScroll(e3, t3) {
          const i3 = this._viewportElement.scrollTop + this._lastRecordedViewportHeight;
          return !(t3 < 0 && this._viewportElement.scrollTop !== 0 || t3 > 0 && i3 < this._lastRecordedBufferHeight) || (e3.cancelable && e3.preventDefault(), false);
        }
        handleWheel(e3) {
          const t3 = this._getPixelsScrolled(e3);
          return t3 !== 0 && (this._optionsService.rawOptions.smoothScrollDuration ? (this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, this._smoothScrollState.target === -1 ? this._smoothScrollState.target = this._viewportElement.scrollTop + t3 : this._smoothScrollState.target += t3, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState()) : this._viewportElement.scrollTop += t3, this._bubbleScroll(e3, t3));
        }
        scrollLines(e3) {
          if (e3 !== 0)
            if (this._optionsService.rawOptions.smoothScrollDuration) {
              const t3 = e3 * this._currentRowHeight;
              this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, this._smoothScrollState.target = this._smoothScrollState.origin + t3, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState();
            } else
              this._onRequestScrollLines.fire({ amount: e3, suppressScrollEvent: false });
        }
        _getPixelsScrolled(e3) {
          if (e3.deltaY === 0 || e3.shiftKey)
            return 0;
          let t3 = this._applyScrollModifier(e3.deltaY, e3);
          return e3.deltaMode === WheelEvent.DOM_DELTA_LINE ? t3 *= this._currentRowHeight : e3.deltaMode === WheelEvent.DOM_DELTA_PAGE && (t3 *= this._currentRowHeight * this._bufferService.rows), t3;
        }
        getBufferElements(e3, t3) {
          let i3, s3 = "";
          const r2 = [], n2 = t3 ?? this._bufferService.buffer.lines.length, o2 = this._bufferService.buffer.lines;
          for (let t4 = e3;t4 < n2; t4++) {
            const e4 = o2.get(t4);
            if (!e4)
              continue;
            const n3 = o2.get(t4 + 1)?.isWrapped;
            if (s3 += e4.translateToString(!n3), !n3 || t4 === o2.length - 1) {
              const e5 = document.createElement("div");
              e5.textContent = s3, r2.push(e5), s3.length > 0 && (i3 = e5), s3 = "";
            }
          }
          return { bufferElements: r2, cursorElement: i3 };
        }
        getLinesScrolled(e3) {
          if (e3.deltaY === 0 || e3.shiftKey)
            return 0;
          let t3 = this._applyScrollModifier(e3.deltaY, e3);
          return e3.deltaMode === WheelEvent.DOM_DELTA_PIXEL ? (t3 /= this._currentRowHeight + 0, this._wheelPartialScroll += t3, t3 = Math.floor(Math.abs(this._wheelPartialScroll)) * (this._wheelPartialScroll > 0 ? 1 : -1), this._wheelPartialScroll %= 1) : e3.deltaMode === WheelEvent.DOM_DELTA_PAGE && (t3 *= this._bufferService.rows), t3;
        }
        _applyScrollModifier(e3, t3) {
          const i3 = this._optionsService.rawOptions.fastScrollModifier;
          return i3 === "alt" && t3.altKey || i3 === "ctrl" && t3.ctrlKey || i3 === "shift" && t3.shiftKey ? e3 * this._optionsService.rawOptions.fastScrollSensitivity * this._optionsService.rawOptions.scrollSensitivity : e3 * this._optionsService.rawOptions.scrollSensitivity;
        }
        handleTouchStart(e3) {
          this._lastTouchY = e3.touches[0].pageY;
        }
        handleTouchMove(e3) {
          const t3 = this._lastTouchY - e3.touches[0].pageY;
          return this._lastTouchY = e3.touches[0].pageY, t3 !== 0 && (this._viewportElement.scrollTop += t3, this._bubbleScroll(e3, t3));
        }
      };
      t2.Viewport = l = s2([r(2, c.IBufferService), r(3, c.IOptionsService), r(4, o.ICharSizeService), r(5, o.IRenderService), r(6, o.ICoreBrowserService), r(7, o.IThemeService)], l);
    }, 3107: function(e2, t2, i2) {
      var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : s3 === null ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          o2 = Reflect.decorate(e3, t3, i3, s3);
        else
          for (var a2 = e3.length - 1;a2 >= 0; a2--)
            (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i3, s3) {
          t3(i3, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferDecorationRenderer = undefined;
      const n = i2(4725), o = i2(844), a = i2(2585);
      let h = t2.BufferDecorationRenderer = class extends o.Disposable {
        constructor(e3, t3, i3, s3, r2) {
          super(), this._screenElement = e3, this._bufferService = t3, this._coreBrowserService = i3, this._decorationService = s3, this._renderService = r2, this._decorationElements = new Map, this._altBufferIsActive = false, this._dimensionsChanged = false, this._container = document.createElement("div"), this._container.classList.add("xterm-decoration-container"), this._screenElement.appendChild(this._container), this.register(this._renderService.onRenderedViewportChange(() => this._doRefreshDecorations())), this.register(this._renderService.onDimensionsChange(() => {
            this._dimensionsChanged = true, this._queueRefresh();
          })), this.register(this._coreBrowserService.onDprChange(() => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => {
            this._altBufferIsActive = this._bufferService.buffer === this._bufferService.buffers.alt;
          })), this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh())), this.register(this._decorationService.onDecorationRemoved((e4) => this._removeDecoration(e4))), this.register((0, o.toDisposable)(() => {
            this._container.remove(), this._decorationElements.clear();
          }));
        }
        _queueRefresh() {
          this._animationFrame === undefined && (this._animationFrame = this._renderService.addRefreshCallback(() => {
            this._doRefreshDecorations(), this._animationFrame = undefined;
          }));
        }
        _doRefreshDecorations() {
          for (const e3 of this._decorationService.decorations)
            this._renderDecoration(e3);
          this._dimensionsChanged = false;
        }
        _renderDecoration(e3) {
          this._refreshStyle(e3), this._dimensionsChanged && this._refreshXPosition(e3);
        }
        _createElement(e3) {
          const t3 = this._coreBrowserService.mainDocument.createElement("div");
          t3.classList.add("xterm-decoration"), t3.classList.toggle("xterm-decoration-top-layer", e3?.options?.layer === "top"), t3.style.width = `${Math.round((e3.options.width || 1) * this._renderService.dimensions.css.cell.width)}px`, t3.style.height = (e3.options.height || 1) * this._renderService.dimensions.css.cell.height + "px", t3.style.top = (e3.marker.line - this._bufferService.buffers.active.ydisp) * this._renderService.dimensions.css.cell.height + "px", t3.style.lineHeight = `${this._renderService.dimensions.css.cell.height}px`;
          const i3 = e3.options.x ?? 0;
          return i3 && i3 > this._bufferService.cols && (t3.style.display = "none"), this._refreshXPosition(e3, t3), t3;
        }
        _refreshStyle(e3) {
          const t3 = e3.marker.line - this._bufferService.buffers.active.ydisp;
          if (t3 < 0 || t3 >= this._bufferService.rows)
            e3.element && (e3.element.style.display = "none", e3.onRenderEmitter.fire(e3.element));
          else {
            let i3 = this._decorationElements.get(e3);
            i3 || (i3 = this._createElement(e3), e3.element = i3, this._decorationElements.set(e3, i3), this._container.appendChild(i3), e3.onDispose(() => {
              this._decorationElements.delete(e3), i3.remove();
            })), i3.style.top = t3 * this._renderService.dimensions.css.cell.height + "px", i3.style.display = this._altBufferIsActive ? "none" : "block", e3.onRenderEmitter.fire(i3);
          }
        }
        _refreshXPosition(e3, t3 = e3.element) {
          if (!t3)
            return;
          const i3 = e3.options.x ?? 0;
          (e3.options.anchor || "left") === "right" ? t3.style.right = i3 ? i3 * this._renderService.dimensions.css.cell.width + "px" : "" : t3.style.left = i3 ? i3 * this._renderService.dimensions.css.cell.width + "px" : "";
        }
        _removeDecoration(e3) {
          this._decorationElements.get(e3)?.remove(), this._decorationElements.delete(e3), e3.dispose();
        }
      };
      t2.BufferDecorationRenderer = h = s2([r(1, a.IBufferService), r(2, n.ICoreBrowserService), r(3, a.IDecorationService), r(4, n.IRenderService)], h);
    }, 5871: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.ColorZoneStore = undefined, t2.ColorZoneStore = class {
        constructor() {
          this._zones = [], this._zonePool = [], this._zonePoolIndex = 0, this._linePadding = { full: 0, left: 0, center: 0, right: 0 };
        }
        get zones() {
          return this._zonePool.length = Math.min(this._zonePool.length, this._zones.length), this._zones;
        }
        clear() {
          this._zones.length = 0, this._zonePoolIndex = 0;
        }
        addDecoration(e3) {
          if (e3.options.overviewRulerOptions) {
            for (const t3 of this._zones)
              if (t3.color === e3.options.overviewRulerOptions.color && t3.position === e3.options.overviewRulerOptions.position) {
                if (this._lineIntersectsZone(t3, e3.marker.line))
                  return;
                if (this._lineAdjacentToZone(t3, e3.marker.line, e3.options.overviewRulerOptions.position))
                  return void this._addLineToZone(t3, e3.marker.line);
              }
            if (this._zonePoolIndex < this._zonePool.length)
              return this._zonePool[this._zonePoolIndex].color = e3.options.overviewRulerOptions.color, this._zonePool[this._zonePoolIndex].position = e3.options.overviewRulerOptions.position, this._zonePool[this._zonePoolIndex].startBufferLine = e3.marker.line, this._zonePool[this._zonePoolIndex].endBufferLine = e3.marker.line, void this._zones.push(this._zonePool[this._zonePoolIndex++]);
            this._zones.push({ color: e3.options.overviewRulerOptions.color, position: e3.options.overviewRulerOptions.position, startBufferLine: e3.marker.line, endBufferLine: e3.marker.line }), this._zonePool.push(this._zones[this._zones.length - 1]), this._zonePoolIndex++;
          }
        }
        setPadding(e3) {
          this._linePadding = e3;
        }
        _lineIntersectsZone(e3, t3) {
          return t3 >= e3.startBufferLine && t3 <= e3.endBufferLine;
        }
        _lineAdjacentToZone(e3, t3, i2) {
          return t3 >= e3.startBufferLine - this._linePadding[i2 || "full"] && t3 <= e3.endBufferLine + this._linePadding[i2 || "full"];
        }
        _addLineToZone(e3, t3) {
          e3.startBufferLine = Math.min(e3.startBufferLine, t3), e3.endBufferLine = Math.max(e3.endBufferLine, t3);
        }
      };
    }, 5744: function(e2, t2, i2) {
      var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : s3 === null ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          o2 = Reflect.decorate(e3, t3, i3, s3);
        else
          for (var a2 = e3.length - 1;a2 >= 0; a2--)
            (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i3, s3) {
          t3(i3, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.OverviewRulerRenderer = undefined;
      const n = i2(5871), o = i2(4725), a = i2(844), h = i2(2585), c = { full: 0, left: 0, center: 0, right: 0 }, l = { full: 0, left: 0, center: 0, right: 0 }, d = { full: 0, left: 0, center: 0, right: 0 };
      let _ = t2.OverviewRulerRenderer = class extends a.Disposable {
        get _width() {
          return this._optionsService.options.overviewRulerWidth || 0;
        }
        constructor(e3, t3, i3, s3, r2, o2, h2) {
          super(), this._viewportElement = e3, this._screenElement = t3, this._bufferService = i3, this._decorationService = s3, this._renderService = r2, this._optionsService = o2, this._coreBrowserService = h2, this._colorZoneStore = new n.ColorZoneStore, this._shouldUpdateDimensions = true, this._shouldUpdateAnchor = true, this._lastKnownBufferLength = 0, this._canvas = this._coreBrowserService.mainDocument.createElement("canvas"), this._canvas.classList.add("xterm-decoration-overview-ruler"), this._refreshCanvasDimensions(), this._viewportElement.parentElement?.insertBefore(this._canvas, this._viewportElement);
          const c2 = this._canvas.getContext("2d");
          if (!c2)
            throw new Error("Ctx cannot be null");
          this._ctx = c2, this._registerDecorationListeners(), this._registerBufferChangeListeners(), this._registerDimensionChangeListeners(), this.register((0, a.toDisposable)(() => {
            this._canvas?.remove();
          }));
        }
        _registerDecorationListeners() {
          this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh(undefined, true))), this.register(this._decorationService.onDecorationRemoved(() => this._queueRefresh(undefined, true)));
        }
        _registerBufferChangeListeners() {
          this.register(this._renderService.onRenderedViewportChange(() => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => {
            this._canvas.style.display = this._bufferService.buffer === this._bufferService.buffers.alt ? "none" : "block";
          })), this.register(this._bufferService.onScroll(() => {
            this._lastKnownBufferLength !== this._bufferService.buffers.normal.lines.length && (this._refreshDrawHeightConstants(), this._refreshColorZonePadding());
          }));
        }
        _registerDimensionChangeListeners() {
          this.register(this._renderService.onRender(() => {
            this._containerHeight && this._containerHeight === this._screenElement.clientHeight || (this._queueRefresh(true), this._containerHeight = this._screenElement.clientHeight);
          })), this.register(this._optionsService.onSpecificOptionChange("overviewRulerWidth", () => this._queueRefresh(true))), this.register(this._coreBrowserService.onDprChange(() => this._queueRefresh(true))), this._queueRefresh(true);
        }
        _refreshDrawConstants() {
          const e3 = Math.floor(this._canvas.width / 3), t3 = Math.ceil(this._canvas.width / 3);
          l.full = this._canvas.width, l.left = e3, l.center = t3, l.right = e3, this._refreshDrawHeightConstants(), d.full = 0, d.left = 0, d.center = l.left, d.right = l.left + l.center;
        }
        _refreshDrawHeightConstants() {
          c.full = Math.round(2 * this._coreBrowserService.dpr);
          const e3 = this._canvas.height / this._bufferService.buffer.lines.length, t3 = Math.round(Math.max(Math.min(e3, 12), 6) * this._coreBrowserService.dpr);
          c.left = t3, c.center = t3, c.right = t3;
        }
        _refreshColorZonePadding() {
          this._colorZoneStore.setPadding({ full: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * c.full), left: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * c.left), center: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * c.center), right: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * c.right) }), this._lastKnownBufferLength = this._bufferService.buffers.normal.lines.length;
        }
        _refreshCanvasDimensions() {
          this._canvas.style.width = `${this._width}px`, this._canvas.width = Math.round(this._width * this._coreBrowserService.dpr), this._canvas.style.height = `${this._screenElement.clientHeight}px`, this._canvas.height = Math.round(this._screenElement.clientHeight * this._coreBrowserService.dpr), this._refreshDrawConstants(), this._refreshColorZonePadding();
        }
        _refreshDecorations() {
          this._shouldUpdateDimensions && this._refreshCanvasDimensions(), this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height), this._colorZoneStore.clear();
          for (const e4 of this._decorationService.decorations)
            this._colorZoneStore.addDecoration(e4);
          this._ctx.lineWidth = 1;
          const e3 = this._colorZoneStore.zones;
          for (const t3 of e3)
            t3.position !== "full" && this._renderColorZone(t3);
          for (const t3 of e3)
            t3.position === "full" && this._renderColorZone(t3);
          this._shouldUpdateDimensions = false, this._shouldUpdateAnchor = false;
        }
        _renderColorZone(e3) {
          this._ctx.fillStyle = e3.color, this._ctx.fillRect(d[e3.position || "full"], Math.round((this._canvas.height - 1) * (e3.startBufferLine / this._bufferService.buffers.active.lines.length) - c[e3.position || "full"] / 2), l[e3.position || "full"], Math.round((this._canvas.height - 1) * ((e3.endBufferLine - e3.startBufferLine) / this._bufferService.buffers.active.lines.length) + c[e3.position || "full"]));
        }
        _queueRefresh(e3, t3) {
          this._shouldUpdateDimensions = e3 || this._shouldUpdateDimensions, this._shouldUpdateAnchor = t3 || this._shouldUpdateAnchor, this._animationFrame === undefined && (this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(() => {
            this._refreshDecorations(), this._animationFrame = undefined;
          }));
        }
      };
      t2.OverviewRulerRenderer = _ = s2([r(2, h.IBufferService), r(3, h.IDecorationService), r(4, o.IRenderService), r(5, h.IOptionsService), r(6, o.ICoreBrowserService)], _);
    }, 2950: function(e2, t2, i2) {
      var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : s3 === null ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          o2 = Reflect.decorate(e3, t3, i3, s3);
        else
          for (var a2 = e3.length - 1;a2 >= 0; a2--)
            (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i3, s3) {
          t3(i3, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.CompositionHelper = undefined;
      const n = i2(4725), o = i2(2585), a = i2(2584);
      let h = t2.CompositionHelper = class {
        get isComposing() {
          return this._isComposing;
        }
        constructor(e3, t3, i3, s3, r2, n2) {
          this._textarea = e3, this._compositionView = t3, this._bufferService = i3, this._optionsService = s3, this._coreService = r2, this._renderService = n2, this._isComposing = false, this._isSendingComposition = false, this._compositionPosition = { start: 0, end: 0 }, this._dataAlreadySent = "";
        }
        compositionstart() {
          this._isComposing = true, this._compositionPosition.start = this._textarea.value.length, this._compositionView.textContent = "", this._dataAlreadySent = "", this._compositionView.classList.add("active");
        }
        compositionupdate(e3) {
          this._compositionView.textContent = e3.data, this.updateCompositionElements(), setTimeout(() => {
            this._compositionPosition.end = this._textarea.value.length;
          }, 0);
        }
        compositionend() {
          this._finalizeComposition(true);
        }
        keydown(e3) {
          if (this._isComposing || this._isSendingComposition) {
            if (e3.keyCode === 229)
              return false;
            if (e3.keyCode === 16 || e3.keyCode === 17 || e3.keyCode === 18)
              return false;
            this._finalizeComposition(false);
          }
          return e3.keyCode !== 229 || (this._handleAnyTextareaChanges(), false);
        }
        _finalizeComposition(e3) {
          if (this._compositionView.classList.remove("active"), this._isComposing = false, e3) {
            const e4 = { start: this._compositionPosition.start, end: this._compositionPosition.end };
            this._isSendingComposition = true, setTimeout(() => {
              if (this._isSendingComposition) {
                let t3;
                this._isSendingComposition = false, e4.start += this._dataAlreadySent.length, t3 = this._isComposing ? this._textarea.value.substring(e4.start, e4.end) : this._textarea.value.substring(e4.start), t3.length > 0 && this._coreService.triggerDataEvent(t3, true);
              }
            }, 0);
          } else {
            this._isSendingComposition = false;
            const e4 = this._textarea.value.substring(this._compositionPosition.start, this._compositionPosition.end);
            this._coreService.triggerDataEvent(e4, true);
          }
        }
        _handleAnyTextareaChanges() {
          const e3 = this._textarea.value;
          setTimeout(() => {
            if (!this._isComposing) {
              const t3 = this._textarea.value, i3 = t3.replace(e3, "");
              this._dataAlreadySent = i3, t3.length > e3.length ? this._coreService.triggerDataEvent(i3, true) : t3.length < e3.length ? this._coreService.triggerDataEvent(`${a.C0.DEL}`, true) : t3.length === e3.length && t3 !== e3 && this._coreService.triggerDataEvent(t3, true);
            }
          }, 0);
        }
        updateCompositionElements(e3) {
          if (this._isComposing) {
            if (this._bufferService.buffer.isCursorInViewport) {
              const e4 = Math.min(this._bufferService.buffer.x, this._bufferService.cols - 1), t3 = this._renderService.dimensions.css.cell.height, i3 = this._bufferService.buffer.y * this._renderService.dimensions.css.cell.height, s3 = e4 * this._renderService.dimensions.css.cell.width;
              this._compositionView.style.left = s3 + "px", this._compositionView.style.top = i3 + "px", this._compositionView.style.height = t3 + "px", this._compositionView.style.lineHeight = t3 + "px", this._compositionView.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._compositionView.style.fontSize = this._optionsService.rawOptions.fontSize + "px";
              const r2 = this._compositionView.getBoundingClientRect();
              this._textarea.style.left = s3 + "px", this._textarea.style.top = i3 + "px", this._textarea.style.width = Math.max(r2.width, 1) + "px", this._textarea.style.height = Math.max(r2.height, 1) + "px", this._textarea.style.lineHeight = r2.height + "px";
            }
            e3 || setTimeout(() => this.updateCompositionElements(true), 0);
          }
        }
      };
      t2.CompositionHelper = h = s2([r(2, o.IBufferService), r(3, o.IOptionsService), r(4, o.ICoreService), r(5, n.IRenderService)], h);
    }, 9806: (e2, t2) => {
      function i2(e3, t3, i3) {
        const s2 = i3.getBoundingClientRect(), r = e3.getComputedStyle(i3), n = parseInt(r.getPropertyValue("padding-left")), o = parseInt(r.getPropertyValue("padding-top"));
        return [t3.clientX - s2.left - n, t3.clientY - s2.top - o];
      }
      Object.defineProperty(t2, "__esModule", { value: true }), t2.getCoords = t2.getCoordsRelativeToElement = undefined, t2.getCoordsRelativeToElement = i2, t2.getCoords = function(e3, t3, s2, r, n, o, a, h, c) {
        if (!o)
          return;
        const l = i2(e3, t3, s2);
        return l ? (l[0] = Math.ceil((l[0] + (c ? a / 2 : 0)) / a), l[1] = Math.ceil(l[1] / h), l[0] = Math.min(Math.max(l[0], 1), r + (c ? 1 : 0)), l[1] = Math.min(Math.max(l[1], 1), n), l) : undefined;
      };
    }, 9504: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.moveToCellSequence = undefined;
      const s2 = i2(2584);
      function r(e3, t3, i3, s3) {
        const r2 = e3 - n(e3, i3), a2 = t3 - n(t3, i3), l = Math.abs(r2 - a2) - function(e4, t4, i4) {
          let s4 = 0;
          const r3 = e4 - n(e4, i4), a3 = t4 - n(t4, i4);
          for (let n2 = 0;n2 < Math.abs(r3 - a3); n2++) {
            const a4 = o(e4, t4) === "A" ? -1 : 1, h2 = i4.buffer.lines.get(r3 + a4 * n2);
            h2?.isWrapped && s4++;
          }
          return s4;
        }(e3, t3, i3);
        return c(l, h(o(e3, t3), s3));
      }
      function n(e3, t3) {
        let i3 = 0, s3 = t3.buffer.lines.get(e3), r2 = s3?.isWrapped;
        for (;r2 && e3 >= 0 && e3 < t3.rows; )
          i3++, s3 = t3.buffer.lines.get(--e3), r2 = s3?.isWrapped;
        return i3;
      }
      function o(e3, t3) {
        return e3 > t3 ? "A" : "B";
      }
      function a(e3, t3, i3, s3, r2, n2) {
        let o2 = e3, a2 = t3, h2 = "";
        for (;o2 !== i3 || a2 !== s3; )
          o2 += r2 ? 1 : -1, r2 && o2 > n2.cols - 1 ? (h2 += n2.buffer.translateBufferLineToString(a2, false, e3, o2), o2 = 0, e3 = 0, a2++) : !r2 && o2 < 0 && (h2 += n2.buffer.translateBufferLineToString(a2, false, 0, e3 + 1), o2 = n2.cols - 1, e3 = o2, a2--);
        return h2 + n2.buffer.translateBufferLineToString(a2, false, e3, o2);
      }
      function h(e3, t3) {
        const i3 = t3 ? "O" : "[";
        return s2.C0.ESC + i3 + e3;
      }
      function c(e3, t3) {
        e3 = Math.floor(e3);
        let i3 = "";
        for (let s3 = 0;s3 < e3; s3++)
          i3 += t3;
        return i3;
      }
      t2.moveToCellSequence = function(e3, t3, i3, s3) {
        const o2 = i3.buffer.x, l = i3.buffer.y;
        if (!i3.buffer.hasScrollback)
          return function(e4, t4, i4, s4, o3, l2) {
            return r(t4, s4, o3, l2).length === 0 ? "" : c(a(e4, t4, e4, t4 - n(t4, o3), false, o3).length, h("D", l2));
          }(o2, l, 0, t3, i3, s3) + r(l, t3, i3, s3) + function(e4, t4, i4, s4, o3, l2) {
            let d2;
            d2 = r(t4, s4, o3, l2).length > 0 ? s4 - n(s4, o3) : t4;
            const _2 = s4, u = function(e5, t5, i5, s5, o4, a2) {
              let h2;
              return h2 = r(i5, s5, o4, a2).length > 0 ? s5 - n(s5, o4) : t5, e5 < i5 && h2 <= s5 || e5 >= i5 && h2 < s5 ? "C" : "D";
            }(e4, t4, i4, s4, o3, l2);
            return c(a(e4, d2, i4, _2, u === "C", o3).length, h(u, l2));
          }(o2, l, e3, t3, i3, s3);
        let d;
        if (l === t3)
          return d = o2 > e3 ? "D" : "C", c(Math.abs(o2 - e3), h(d, s3));
        d = l > t3 ? "D" : "C";
        const _ = Math.abs(l - t3);
        return c(function(e4, t4) {
          return t4.cols - e4;
        }(l > t3 ? e3 : o2, i3) + (_ - 1) * i3.cols + 1 + ((l > t3 ? o2 : e3) - 1), h(d, s3));
      };
    }, 1296: function(e2, t2, i2) {
      var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : s3 === null ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          o2 = Reflect.decorate(e3, t3, i3, s3);
        else
          for (var a2 = e3.length - 1;a2 >= 0; a2--)
            (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i3, s3) {
          t3(i3, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.DomRenderer = undefined;
      const n = i2(3787), o = i2(2550), a = i2(2223), h = i2(6171), c = i2(4725), l = i2(8055), d = i2(8460), _ = i2(844), u = i2(2585), f = "xterm-dom-renderer-owner-", v = "xterm-rows", g = "xterm-fg-", p = "xterm-bg-", m = "xterm-focus", S = "xterm-selection";
      let C = 1, b = t2.DomRenderer = class extends _.Disposable {
        constructor(e3, t3, i3, s3, r2, a2, c2, l2, u2, g2, p2, m2) {
          super(), this._document = e3, this._element = t3, this._screenElement = i3, this._viewportElement = s3, this._helperContainer = r2, this._linkifier2 = a2, this._charSizeService = l2, this._optionsService = u2, this._bufferService = g2, this._coreBrowserService = p2, this._themeService = m2, this._terminalClass = C++, this._rowElements = [], this.onRequestRedraw = this.register(new d.EventEmitter).event, this._rowContainer = this._document.createElement("div"), this._rowContainer.classList.add(v), this._rowContainer.style.lineHeight = "normal", this._rowContainer.setAttribute("aria-hidden", "true"), this._refreshRowElements(this._bufferService.cols, this._bufferService.rows), this._selectionContainer = this._document.createElement("div"), this._selectionContainer.classList.add(S), this._selectionContainer.setAttribute("aria-hidden", "true"), this.dimensions = (0, h.createRenderDimensions)(), this._updateDimensions(), this.register(this._optionsService.onOptionChange(() => this._handleOptionsChanged())), this.register(this._themeService.onChangeColors((e4) => this._injectCss(e4))), this._injectCss(this._themeService.colors), this._rowFactory = c2.createInstance(n.DomRendererRowFactory, document), this._element.classList.add(f + this._terminalClass), this._screenElement.appendChild(this._rowContainer), this._screenElement.appendChild(this._selectionContainer), this.register(this._linkifier2.onShowLinkUnderline((e4) => this._handleLinkHover(e4))), this.register(this._linkifier2.onHideLinkUnderline((e4) => this._handleLinkLeave(e4))), this.register((0, _.toDisposable)(() => {
            this._element.classList.remove(f + this._terminalClass), this._rowContainer.remove(), this._selectionContainer.remove(), this._widthCache.dispose(), this._themeStyleElement.remove(), this._dimensionsStyleElement.remove();
          })), this._widthCache = new o.WidthCache(this._document, this._helperContainer), this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold), this._setDefaultSpacing();
        }
        _updateDimensions() {
          const e3 = this._coreBrowserService.dpr;
          this.dimensions.device.char.width = this._charSizeService.width * e3, this.dimensions.device.char.height = Math.ceil(this._charSizeService.height * e3), this.dimensions.device.cell.width = this.dimensions.device.char.width + Math.round(this._optionsService.rawOptions.letterSpacing), this.dimensions.device.cell.height = Math.floor(this.dimensions.device.char.height * this._optionsService.rawOptions.lineHeight), this.dimensions.device.char.left = 0, this.dimensions.device.char.top = 0, this.dimensions.device.canvas.width = this.dimensions.device.cell.width * this._bufferService.cols, this.dimensions.device.canvas.height = this.dimensions.device.cell.height * this._bufferService.rows, this.dimensions.css.canvas.width = Math.round(this.dimensions.device.canvas.width / e3), this.dimensions.css.canvas.height = Math.round(this.dimensions.device.canvas.height / e3), this.dimensions.css.cell.width = this.dimensions.css.canvas.width / this._bufferService.cols, this.dimensions.css.cell.height = this.dimensions.css.canvas.height / this._bufferService.rows;
          for (const e4 of this._rowElements)
            e4.style.width = `${this.dimensions.css.canvas.width}px`, e4.style.height = `${this.dimensions.css.cell.height}px`, e4.style.lineHeight = `${this.dimensions.css.cell.height}px`, e4.style.overflow = "hidden";
          this._dimensionsStyleElement || (this._dimensionsStyleElement = this._document.createElement("style"), this._screenElement.appendChild(this._dimensionsStyleElement));
          const t3 = `${this._terminalSelector} .${v} span { display: inline-block; height: 100%; vertical-align: top;}`;
          this._dimensionsStyleElement.textContent = t3, this._selectionContainer.style.height = this._viewportElement.style.height, this._screenElement.style.width = `${this.dimensions.css.canvas.width}px`, this._screenElement.style.height = `${this.dimensions.css.canvas.height}px`;
        }
        _injectCss(e3) {
          this._themeStyleElement || (this._themeStyleElement = this._document.createElement("style"), this._screenElement.appendChild(this._themeStyleElement));
          let t3 = `${this._terminalSelector} .${v} { color: ${e3.foreground.css}; font-family: ${this._optionsService.rawOptions.fontFamily}; font-size: ${this._optionsService.rawOptions.fontSize}px; font-kerning: none; white-space: pre}`;
          t3 += `${this._terminalSelector} .${v} .xterm-dim { color: ${l.color.multiplyOpacity(e3.foreground, 0.5).css};}`, t3 += `${this._terminalSelector} span:not(.xterm-bold) { font-weight: ${this._optionsService.rawOptions.fontWeight};}${this._terminalSelector} span.xterm-bold { font-weight: ${this._optionsService.rawOptions.fontWeightBold};}${this._terminalSelector} span.xterm-italic { font-style: italic;}`, t3 += "@keyframes blink_box_shadow_" + this._terminalClass + " { 50% {  border-bottom-style: hidden; }}", t3 += "@keyframes blink_block_" + this._terminalClass + " { 0% {" + `  background-color: ${e3.cursor.css};` + `  color: ${e3.cursorAccent.css}; } 50% {  background-color: inherit;` + `  color: ${e3.cursor.css}; }}`, t3 += `${this._terminalSelector} .${v}.${m} .xterm-cursor.xterm-cursor-blink:not(.xterm-cursor-block) { animation: blink_box_shadow_` + this._terminalClass + " 1s step-end infinite;}" + `${this._terminalSelector} .${v}.${m} .xterm-cursor.xterm-cursor-blink.xterm-cursor-block { animation: blink_block_` + this._terminalClass + " 1s step-end infinite;}" + `${this._terminalSelector} .${v} .xterm-cursor.xterm-cursor-block {` + ` background-color: ${e3.cursor.css} !important;` + ` color: ${e3.cursorAccent.css} !important;}` + `${this._terminalSelector} .${v} .xterm-cursor.xterm-cursor-outline {` + ` outline: 1px solid ${e3.cursor.css}; outline-offset: -1px;}` + `${this._terminalSelector} .${v} .xterm-cursor.xterm-cursor-bar {` + ` box-shadow: ${this._optionsService.rawOptions.cursorWidth}px 0 0 ${e3.cursor.css} inset;}` + `${this._terminalSelector} .${v} .xterm-cursor.xterm-cursor-underline {` + ` border-bottom: 1px ${e3.cursor.css}; border-bottom-style: solid; height: calc(100% - 1px);}`, t3 += `${this._terminalSelector} .${S} { position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none;}${this._terminalSelector}.focus .${S} div { position: absolute; background-color: ${e3.selectionBackgroundOpaque.css};}${this._terminalSelector} .${S} div { position: absolute; background-color: ${e3.selectionInactiveBackgroundOpaque.css};}`;
          for (const [i3, s3] of e3.ansi.entries())
            t3 += `${this._terminalSelector} .${g}${i3} { color: ${s3.css}; }${this._terminalSelector} .${g}${i3}.xterm-dim { color: ${l.color.multiplyOpacity(s3, 0.5).css}; }${this._terminalSelector} .${p}${i3} { background-color: ${s3.css}; }`;
          t3 += `${this._terminalSelector} .${g}${a.INVERTED_DEFAULT_COLOR} { color: ${l.color.opaque(e3.background).css}; }${this._terminalSelector} .${g}${a.INVERTED_DEFAULT_COLOR}.xterm-dim { color: ${l.color.multiplyOpacity(l.color.opaque(e3.background), 0.5).css}; }${this._terminalSelector} .${p}${a.INVERTED_DEFAULT_COLOR} { background-color: ${e3.foreground.css}; }`, this._themeStyleElement.textContent = t3;
        }
        _setDefaultSpacing() {
          const e3 = this.dimensions.css.cell.width - this._widthCache.get("W", false, false);
          this._rowContainer.style.letterSpacing = `${e3}px`, this._rowFactory.defaultSpacing = e3;
        }
        handleDevicePixelRatioChange() {
          this._updateDimensions(), this._widthCache.clear(), this._setDefaultSpacing();
        }
        _refreshRowElements(e3, t3) {
          for (let e4 = this._rowElements.length;e4 <= t3; e4++) {
            const e5 = this._document.createElement("div");
            this._rowContainer.appendChild(e5), this._rowElements.push(e5);
          }
          for (;this._rowElements.length > t3; )
            this._rowContainer.removeChild(this._rowElements.pop());
        }
        handleResize(e3, t3) {
          this._refreshRowElements(e3, t3), this._updateDimensions();
        }
        handleCharSizeChanged() {
          this._updateDimensions(), this._widthCache.clear(), this._setDefaultSpacing();
        }
        handleBlur() {
          this._rowContainer.classList.remove(m), this.renderRows(0, this._bufferService.rows - 1);
        }
        handleFocus() {
          this._rowContainer.classList.add(m), this.renderRows(this._bufferService.buffer.y, this._bufferService.buffer.y);
        }
        handleSelectionChanged(e3, t3, i3) {
          if (this._selectionContainer.replaceChildren(), this._rowFactory.handleSelectionChanged(e3, t3, i3), this.renderRows(0, this._bufferService.rows - 1), !e3 || !t3)
            return;
          const s3 = e3[1] - this._bufferService.buffer.ydisp, r2 = t3[1] - this._bufferService.buffer.ydisp, n2 = Math.max(s3, 0), o2 = Math.min(r2, this._bufferService.rows - 1);
          if (n2 >= this._bufferService.rows || o2 < 0)
            return;
          const a2 = this._document.createDocumentFragment();
          if (i3) {
            const i4 = e3[0] > t3[0];
            a2.appendChild(this._createSelectionElement(n2, i4 ? t3[0] : e3[0], i4 ? e3[0] : t3[0], o2 - n2 + 1));
          } else {
            const i4 = s3 === n2 ? e3[0] : 0, h2 = n2 === r2 ? t3[0] : this._bufferService.cols;
            a2.appendChild(this._createSelectionElement(n2, i4, h2));
            const c2 = o2 - n2 - 1;
            if (a2.appendChild(this._createSelectionElement(n2 + 1, 0, this._bufferService.cols, c2)), n2 !== o2) {
              const e4 = r2 === o2 ? t3[0] : this._bufferService.cols;
              a2.appendChild(this._createSelectionElement(o2, 0, e4));
            }
          }
          this._selectionContainer.appendChild(a2);
        }
        _createSelectionElement(e3, t3, i3, s3 = 1) {
          const r2 = this._document.createElement("div");
          return r2.style.height = s3 * this.dimensions.css.cell.height + "px", r2.style.top = e3 * this.dimensions.css.cell.height + "px", r2.style.left = t3 * this.dimensions.css.cell.width + "px", r2.style.width = this.dimensions.css.cell.width * (i3 - t3) + "px", r2;
        }
        handleCursorMove() {
        }
        _handleOptionsChanged() {
          this._updateDimensions(), this._injectCss(this._themeService.colors), this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold), this._setDefaultSpacing();
        }
        clear() {
          for (const e3 of this._rowElements)
            e3.replaceChildren();
        }
        renderRows(e3, t3) {
          const i3 = this._bufferService.buffer, s3 = i3.ybase + i3.y, r2 = Math.min(i3.x, this._bufferService.cols - 1), n2 = this._optionsService.rawOptions.cursorBlink, o2 = this._optionsService.rawOptions.cursorStyle, a2 = this._optionsService.rawOptions.cursorInactiveStyle;
          for (let h2 = e3;h2 <= t3; h2++) {
            const e4 = h2 + i3.ydisp, t4 = this._rowElements[h2], c2 = i3.lines.get(e4);
            if (!t4 || !c2)
              break;
            t4.replaceChildren(...this._rowFactory.createRow(c2, e4, e4 === s3, o2, a2, r2, n2, this.dimensions.css.cell.width, this._widthCache, -1, -1));
          }
        }
        get _terminalSelector() {
          return `.${f}${this._terminalClass}`;
        }
        _handleLinkHover(e3) {
          this._setCellUnderline(e3.x1, e3.x2, e3.y1, e3.y2, e3.cols, true);
        }
        _handleLinkLeave(e3) {
          this._setCellUnderline(e3.x1, e3.x2, e3.y1, e3.y2, e3.cols, false);
        }
        _setCellUnderline(e3, t3, i3, s3, r2, n2) {
          i3 < 0 && (e3 = 0), s3 < 0 && (t3 = 0);
          const o2 = this._bufferService.rows - 1;
          i3 = Math.max(Math.min(i3, o2), 0), s3 = Math.max(Math.min(s3, o2), 0), r2 = Math.min(r2, this._bufferService.cols);
          const a2 = this._bufferService.buffer, h2 = a2.ybase + a2.y, c2 = Math.min(a2.x, r2 - 1), l2 = this._optionsService.rawOptions.cursorBlink, d2 = this._optionsService.rawOptions.cursorStyle, _2 = this._optionsService.rawOptions.cursorInactiveStyle;
          for (let o3 = i3;o3 <= s3; ++o3) {
            const u2 = o3 + a2.ydisp, f2 = this._rowElements[o3], v2 = a2.lines.get(u2);
            if (!f2 || !v2)
              break;
            f2.replaceChildren(...this._rowFactory.createRow(v2, u2, u2 === h2, d2, _2, c2, l2, this.dimensions.css.cell.width, this._widthCache, n2 ? o3 === i3 ? e3 : 0 : -1, n2 ? (o3 === s3 ? t3 : r2) - 1 : -1));
          }
        }
      };
      t2.DomRenderer = b = s2([r(6, u.IInstantiationService), r(7, c.ICharSizeService), r(8, u.IOptionsService), r(9, u.IBufferService), r(10, c.ICoreBrowserService), r(11, c.IThemeService)], b);
    }, 3787: function(e2, t2, i2) {
      var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : s3 === null ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          o2 = Reflect.decorate(e3, t3, i3, s3);
        else
          for (var a2 = e3.length - 1;a2 >= 0; a2--)
            (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i3, s3) {
          t3(i3, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.DomRendererRowFactory = undefined;
      const n = i2(2223), o = i2(643), a = i2(511), h = i2(2585), c = i2(8055), l = i2(4725), d = i2(4269), _ = i2(6171), u = i2(3734);
      let f = t2.DomRendererRowFactory = class {
        constructor(e3, t3, i3, s3, r2, n2, o2) {
          this._document = e3, this._characterJoinerService = t3, this._optionsService = i3, this._coreBrowserService = s3, this._coreService = r2, this._decorationService = n2, this._themeService = o2, this._workCell = new a.CellData, this._columnSelectMode = false, this.defaultSpacing = 0;
        }
        handleSelectionChanged(e3, t3, i3) {
          this._selectionStart = e3, this._selectionEnd = t3, this._columnSelectMode = i3;
        }
        createRow(e3, t3, i3, s3, r2, a2, h2, l2, _2, f2, g) {
          const p = [], m = this._characterJoinerService.getJoinedCharacters(t3), S = this._themeService.colors;
          let C, b = e3.getNoBgTrimmedLength();
          i3 && b < a2 + 1 && (b = a2 + 1);
          let y = 0, w = "", E = 0, k = 0, L = 0, D = false, R = 0, x = false, A = 0;
          const B = [], T = f2 !== -1 && g !== -1;
          for (let M = 0;M < b; M++) {
            e3.loadCell(M, this._workCell);
            let b2 = this._workCell.getWidth();
            if (b2 === 0)
              continue;
            let O = false, P = M, I = this._workCell;
            if (m.length > 0 && M === m[0][0]) {
              O = true;
              const t4 = m.shift();
              I = new d.JoinedCellData(this._workCell, e3.translateToString(true, t4[0], t4[1]), t4[1] - t4[0]), P = t4[1] - 1, b2 = I.getWidth();
            }
            const H = this._isCellInSelection(M, t3), F = i3 && M === a2, W = T && M >= f2 && M <= g;
            let U = false;
            this._decorationService.forEachDecorationAtCell(M, t3, undefined, (e4) => {
              U = true;
            });
            let N = I.getChars() || o.WHITESPACE_CELL_CHAR;
            if (N === " " && (I.isUnderline() || I.isOverline()) && (N = "\xA0"), A = b2 * l2 - _2.get(N, I.isBold(), I.isItalic()), C) {
              if (y && (H && x || !H && !x && I.bg === E) && (H && x && S.selectionForeground || I.fg === k) && I.extended.ext === L && W === D && A === R && !F && !O && !U) {
                I.isInvisible() ? w += o.WHITESPACE_CELL_CHAR : w += N, y++;
                continue;
              }
              y && (C.textContent = w), C = this._document.createElement("span"), y = 0, w = "";
            } else
              C = this._document.createElement("span");
            if (E = I.bg, k = I.fg, L = I.extended.ext, D = W, R = A, x = H, O && a2 >= M && a2 <= P && (a2 = M), !this._coreService.isCursorHidden && F && this._coreService.isCursorInitialized) {
              if (B.push("xterm-cursor"), this._coreBrowserService.isFocused)
                h2 && B.push("xterm-cursor-blink"), B.push(s3 === "bar" ? "xterm-cursor-bar" : s3 === "underline" ? "xterm-cursor-underline" : "xterm-cursor-block");
              else if (r2)
                switch (r2) {
                  case "outline":
                    B.push("xterm-cursor-outline");
                    break;
                  case "block":
                    B.push("xterm-cursor-block");
                    break;
                  case "bar":
                    B.push("xterm-cursor-bar");
                    break;
                  case "underline":
                    B.push("xterm-cursor-underline");
                }
            }
            if (I.isBold() && B.push("xterm-bold"), I.isItalic() && B.push("xterm-italic"), I.isDim() && B.push("xterm-dim"), w = I.isInvisible() ? o.WHITESPACE_CELL_CHAR : I.getChars() || o.WHITESPACE_CELL_CHAR, I.isUnderline() && (B.push(`xterm-underline-${I.extended.underlineStyle}`), w === " " && (w = "\xA0"), !I.isUnderlineColorDefault()))
              if (I.isUnderlineColorRGB())
                C.style.textDecorationColor = `rgb(${u.AttributeData.toColorRGB(I.getUnderlineColor()).join(",")})`;
              else {
                let e4 = I.getUnderlineColor();
                this._optionsService.rawOptions.drawBoldTextInBrightColors && I.isBold() && e4 < 8 && (e4 += 8), C.style.textDecorationColor = S.ansi[e4].css;
              }
            I.isOverline() && (B.push("xterm-overline"), w === " " && (w = "\xA0")), I.isStrikethrough() && B.push("xterm-strikethrough"), W && (C.style.textDecoration = "underline");
            let $ = I.getFgColor(), j = I.getFgColorMode(), z = I.getBgColor(), K = I.getBgColorMode();
            const q = !!I.isInverse();
            if (q) {
              const e4 = $;
              $ = z, z = e4;
              const t4 = j;
              j = K, K = t4;
            }
            let V, G, X, J = false;
            switch (this._decorationService.forEachDecorationAtCell(M, t3, undefined, (e4) => {
              e4.options.layer !== "top" && J || (e4.backgroundColorRGB && (K = 50331648, z = e4.backgroundColorRGB.rgba >> 8 & 16777215, V = e4.backgroundColorRGB), e4.foregroundColorRGB && (j = 50331648, $ = e4.foregroundColorRGB.rgba >> 8 & 16777215, G = e4.foregroundColorRGB), J = e4.options.layer === "top");
            }), !J && H && (V = this._coreBrowserService.isFocused ? S.selectionBackgroundOpaque : S.selectionInactiveBackgroundOpaque, z = V.rgba >> 8 & 16777215, K = 50331648, J = true, S.selectionForeground && (j = 50331648, $ = S.selectionForeground.rgba >> 8 & 16777215, G = S.selectionForeground)), J && B.push("xterm-decoration-top"), K) {
              case 16777216:
              case 33554432:
                X = S.ansi[z], B.push(`xterm-bg-${z}`);
                break;
              case 50331648:
                X = c.rgba.toColor(z >> 16, z >> 8 & 255, 255 & z), this._addStyle(C, `background-color:#${v((z >>> 0).toString(16), "0", 6)}`);
                break;
              default:
                q ? (X = S.foreground, B.push(`xterm-bg-${n.INVERTED_DEFAULT_COLOR}`)) : X = S.background;
            }
            switch (V || I.isDim() && (V = c.color.multiplyOpacity(X, 0.5)), j) {
              case 16777216:
              case 33554432:
                I.isBold() && $ < 8 && this._optionsService.rawOptions.drawBoldTextInBrightColors && ($ += 8), this._applyMinimumContrast(C, X, S.ansi[$], I, V, undefined) || B.push(`xterm-fg-${$}`);
                break;
              case 50331648:
                const e4 = c.rgba.toColor($ >> 16 & 255, $ >> 8 & 255, 255 & $);
                this._applyMinimumContrast(C, X, e4, I, V, G) || this._addStyle(C, `color:#${v($.toString(16), "0", 6)}`);
                break;
              default:
                this._applyMinimumContrast(C, X, S.foreground, I, V, G) || q && B.push(`xterm-fg-${n.INVERTED_DEFAULT_COLOR}`);
            }
            B.length && (C.className = B.join(" "), B.length = 0), F || O || U ? C.textContent = w : y++, A !== this.defaultSpacing && (C.style.letterSpacing = `${A}px`), p.push(C), M = P;
          }
          return C && y && (C.textContent = w), p;
        }
        _applyMinimumContrast(e3, t3, i3, s3, r2, n2) {
          if (this._optionsService.rawOptions.minimumContrastRatio === 1 || (0, _.excludeFromContrastRatioDemands)(s3.getCode()))
            return false;
          const o2 = this._getContrastCache(s3);
          let a2;
          if (r2 || n2 || (a2 = o2.getColor(t3.rgba, i3.rgba)), a2 === undefined) {
            const e4 = this._optionsService.rawOptions.minimumContrastRatio / (s3.isDim() ? 2 : 1);
            a2 = c.color.ensureContrastRatio(r2 || t3, n2 || i3, e4), o2.setColor((r2 || t3).rgba, (n2 || i3).rgba, a2 ?? null);
          }
          return !!a2 && (this._addStyle(e3, `color:${a2.css}`), true);
        }
        _getContrastCache(e3) {
          return e3.isDim() ? this._themeService.colors.halfContrastCache : this._themeService.colors.contrastCache;
        }
        _addStyle(e3, t3) {
          e3.setAttribute("style", `${e3.getAttribute("style") || ""}${t3};`);
        }
        _isCellInSelection(e3, t3) {
          const i3 = this._selectionStart, s3 = this._selectionEnd;
          return !(!i3 || !s3) && (this._columnSelectMode ? i3[0] <= s3[0] ? e3 >= i3[0] && t3 >= i3[1] && e3 < s3[0] && t3 <= s3[1] : e3 < i3[0] && t3 >= i3[1] && e3 >= s3[0] && t3 <= s3[1] : t3 > i3[1] && t3 < s3[1] || i3[1] === s3[1] && t3 === i3[1] && e3 >= i3[0] && e3 < s3[0] || i3[1] < s3[1] && t3 === s3[1] && e3 < s3[0] || i3[1] < s3[1] && t3 === i3[1] && e3 >= i3[0]);
        }
      };
      function v(e3, t3, i3) {
        for (;e3.length < i3; )
          e3 = t3 + e3;
        return e3;
      }
      t2.DomRendererRowFactory = f = s2([r(1, l.ICharacterJoinerService), r(2, h.IOptionsService), r(3, l.ICoreBrowserService), r(4, h.ICoreService), r(5, h.IDecorationService), r(6, l.IThemeService)], f);
    }, 2550: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.WidthCache = undefined, t2.WidthCache = class {
        constructor(e3, t3) {
          this._flat = new Float32Array(256), this._font = "", this._fontSize = 0, this._weight = "normal", this._weightBold = "bold", this._measureElements = [], this._container = e3.createElement("div"), this._container.classList.add("xterm-width-cache-measure-container"), this._container.setAttribute("aria-hidden", "true"), this._container.style.whiteSpace = "pre", this._container.style.fontKerning = "none";
          const i2 = e3.createElement("span");
          i2.classList.add("xterm-char-measure-element");
          const s2 = e3.createElement("span");
          s2.classList.add("xterm-char-measure-element"), s2.style.fontWeight = "bold";
          const r = e3.createElement("span");
          r.classList.add("xterm-char-measure-element"), r.style.fontStyle = "italic";
          const n = e3.createElement("span");
          n.classList.add("xterm-char-measure-element"), n.style.fontWeight = "bold", n.style.fontStyle = "italic", this._measureElements = [i2, s2, r, n], this._container.appendChild(i2), this._container.appendChild(s2), this._container.appendChild(r), this._container.appendChild(n), t3.appendChild(this._container), this.clear();
        }
        dispose() {
          this._container.remove(), this._measureElements.length = 0, this._holey = undefined;
        }
        clear() {
          this._flat.fill(-9999), this._holey = new Map;
        }
        setFont(e3, t3, i2, s2) {
          e3 === this._font && t3 === this._fontSize && i2 === this._weight && s2 === this._weightBold || (this._font = e3, this._fontSize = t3, this._weight = i2, this._weightBold = s2, this._container.style.fontFamily = this._font, this._container.style.fontSize = `${this._fontSize}px`, this._measureElements[0].style.fontWeight = `${i2}`, this._measureElements[1].style.fontWeight = `${s2}`, this._measureElements[2].style.fontWeight = `${i2}`, this._measureElements[3].style.fontWeight = `${s2}`, this.clear());
        }
        get(e3, t3, i2) {
          let s2 = 0;
          if (!t3 && !i2 && e3.length === 1 && (s2 = e3.charCodeAt(0)) < 256)
            return this._flat[s2] !== -9999 ? this._flat[s2] : this._flat[s2] = this._measure(e3, 0);
          let r = e3;
          t3 && (r += "B"), i2 && (r += "I");
          let n = this._holey.get(r);
          if (n === undefined) {
            let s3 = 0;
            t3 && (s3 |= 1), i2 && (s3 |= 2), n = this._measure(e3, s3), this._holey.set(r, n);
          }
          return n;
        }
        _measure(e3, t3) {
          const i2 = this._measureElements[t3];
          return i2.textContent = e3.repeat(32), i2.offsetWidth / 32;
        }
      };
    }, 2223: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.TEXT_BASELINE = t2.DIM_OPACITY = t2.INVERTED_DEFAULT_COLOR = undefined;
      const s2 = i2(6114);
      t2.INVERTED_DEFAULT_COLOR = 257, t2.DIM_OPACITY = 0.5, t2.TEXT_BASELINE = s2.isFirefox || s2.isLegacyEdge ? "bottom" : "ideographic";
    }, 6171: (e2, t2) => {
      function i2(e3) {
        return 57508 <= e3 && e3 <= 57558;
      }
      Object.defineProperty(t2, "__esModule", { value: true }), t2.createRenderDimensions = t2.excludeFromContrastRatioDemands = t2.isRestrictedPowerlineGlyph = t2.isPowerlineGlyph = t2.throwIfFalsy = undefined, t2.throwIfFalsy = function(e3) {
        if (!e3)
          throw new Error("value must not be falsy");
        return e3;
      }, t2.isPowerlineGlyph = i2, t2.isRestrictedPowerlineGlyph = function(e3) {
        return 57520 <= e3 && e3 <= 57527;
      }, t2.excludeFromContrastRatioDemands = function(e3) {
        return i2(e3) || function(e4) {
          return 9472 <= e4 && e4 <= 9631;
        }(e3);
      }, t2.createRenderDimensions = function() {
        return { css: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 } }, device: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 }, char: { width: 0, height: 0, left: 0, top: 0 } } };
      };
    }, 456: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.SelectionModel = undefined, t2.SelectionModel = class {
        constructor(e3) {
          this._bufferService = e3, this.isSelectAllActive = false, this.selectionStartLength = 0;
        }
        clearSelection() {
          this.selectionStart = undefined, this.selectionEnd = undefined, this.isSelectAllActive = false, this.selectionStartLength = 0;
        }
        get finalSelectionStart() {
          return this.isSelectAllActive ? [0, 0] : this.selectionEnd && this.selectionStart && this.areSelectionValuesReversed() ? this.selectionEnd : this.selectionStart;
        }
        get finalSelectionEnd() {
          if (this.isSelectAllActive)
            return [this._bufferService.cols, this._bufferService.buffer.ybase + this._bufferService.rows - 1];
          if (this.selectionStart) {
            if (!this.selectionEnd || this.areSelectionValuesReversed()) {
              const e3 = this.selectionStart[0] + this.selectionStartLength;
              return e3 > this._bufferService.cols ? e3 % this._bufferService.cols == 0 ? [this._bufferService.cols, this.selectionStart[1] + Math.floor(e3 / this._bufferService.cols) - 1] : [e3 % this._bufferService.cols, this.selectionStart[1] + Math.floor(e3 / this._bufferService.cols)] : [e3, this.selectionStart[1]];
            }
            if (this.selectionStartLength && this.selectionEnd[1] === this.selectionStart[1]) {
              const e3 = this.selectionStart[0] + this.selectionStartLength;
              return e3 > this._bufferService.cols ? [e3 % this._bufferService.cols, this.selectionStart[1] + Math.floor(e3 / this._bufferService.cols)] : [Math.max(e3, this.selectionEnd[0]), this.selectionEnd[1]];
            }
            return this.selectionEnd;
          }
        }
        areSelectionValuesReversed() {
          const e3 = this.selectionStart, t3 = this.selectionEnd;
          return !(!e3 || !t3) && (e3[1] > t3[1] || e3[1] === t3[1] && e3[0] > t3[0]);
        }
        handleTrim(e3) {
          return this.selectionStart && (this.selectionStart[1] -= e3), this.selectionEnd && (this.selectionEnd[1] -= e3), this.selectionEnd && this.selectionEnd[1] < 0 ? (this.clearSelection(), true) : (this.selectionStart && this.selectionStart[1] < 0 && (this.selectionStart[1] = 0), false);
        }
      };
    }, 428: function(e2, t2, i2) {
      var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : s3 === null ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          o2 = Reflect.decorate(e3, t3, i3, s3);
        else
          for (var a2 = e3.length - 1;a2 >= 0; a2--)
            (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i3, s3) {
          t3(i3, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.CharSizeService = undefined;
      const n = i2(2585), o = i2(8460), a = i2(844);
      let h = t2.CharSizeService = class extends a.Disposable {
        get hasValidSize() {
          return this.width > 0 && this.height > 0;
        }
        constructor(e3, t3, i3) {
          super(), this._optionsService = i3, this.width = 0, this.height = 0, this._onCharSizeChange = this.register(new o.EventEmitter), this.onCharSizeChange = this._onCharSizeChange.event, this._measureStrategy = new c(e3, t3, this._optionsService), this.register(this._optionsService.onMultipleOptionChange(["fontFamily", "fontSize"], () => this.measure()));
        }
        measure() {
          const e3 = this._measureStrategy.measure();
          e3.width === this.width && e3.height === this.height || (this.width = e3.width, this.height = e3.height, this._onCharSizeChange.fire());
        }
      };
      t2.CharSizeService = h = s2([r(2, n.IOptionsService)], h);

      class c {
        constructor(e3, t3, i3) {
          this._document = e3, this._parentElement = t3, this._optionsService = i3, this._result = { width: 0, height: 0 }, this._measureElement = this._document.createElement("span"), this._measureElement.classList.add("xterm-char-measure-element"), this._measureElement.textContent = "W".repeat(32), this._measureElement.setAttribute("aria-hidden", "true"), this._measureElement.style.whiteSpace = "pre", this._measureElement.style.fontKerning = "none", this._parentElement.appendChild(this._measureElement);
        }
        measure() {
          this._measureElement.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._measureElement.style.fontSize = `${this._optionsService.rawOptions.fontSize}px`;
          const e3 = { height: Number(this._measureElement.offsetHeight), width: Number(this._measureElement.offsetWidth) };
          return e3.width !== 0 && e3.height !== 0 && (this._result.width = e3.width / 32, this._result.height = Math.ceil(e3.height)), this._result;
        }
      }
    }, 4269: function(e2, t2, i2) {
      var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : s3 === null ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          o2 = Reflect.decorate(e3, t3, i3, s3);
        else
          for (var a2 = e3.length - 1;a2 >= 0; a2--)
            (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i3, s3) {
          t3(i3, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.CharacterJoinerService = t2.JoinedCellData = undefined;
      const n = i2(3734), o = i2(643), a = i2(511), h = i2(2585);

      class c extends n.AttributeData {
        constructor(e3, t3, i3) {
          super(), this.content = 0, this.combinedData = "", this.fg = e3.fg, this.bg = e3.bg, this.combinedData = t3, this._width = i3;
        }
        isCombined() {
          return 2097152;
        }
        getWidth() {
          return this._width;
        }
        getChars() {
          return this.combinedData;
        }
        getCode() {
          return 2097151;
        }
        setFromCharData(e3) {
          throw new Error("not implemented");
        }
        getAsCharData() {
          return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
        }
      }
      t2.JoinedCellData = c;
      let l = t2.CharacterJoinerService = class e3 {
        constructor(e4) {
          this._bufferService = e4, this._characterJoiners = [], this._nextCharacterJoinerId = 0, this._workCell = new a.CellData;
        }
        register(e4) {
          const t3 = { id: this._nextCharacterJoinerId++, handler: e4 };
          return this._characterJoiners.push(t3), t3.id;
        }
        deregister(e4) {
          for (let t3 = 0;t3 < this._characterJoiners.length; t3++)
            if (this._characterJoiners[t3].id === e4)
              return this._characterJoiners.splice(t3, 1), true;
          return false;
        }
        getJoinedCharacters(e4) {
          if (this._characterJoiners.length === 0)
            return [];
          const t3 = this._bufferService.buffer.lines.get(e4);
          if (!t3 || t3.length === 0)
            return [];
          const i3 = [], s3 = t3.translateToString(true);
          let r2 = 0, n2 = 0, a2 = 0, h2 = t3.getFg(0), c2 = t3.getBg(0);
          for (let e5 = 0;e5 < t3.getTrimmedLength(); e5++)
            if (t3.loadCell(e5, this._workCell), this._workCell.getWidth() !== 0) {
              if (this._workCell.fg !== h2 || this._workCell.bg !== c2) {
                if (e5 - r2 > 1) {
                  const e6 = this._getJoinedRanges(s3, a2, n2, t3, r2);
                  for (let t4 = 0;t4 < e6.length; t4++)
                    i3.push(e6[t4]);
                }
                r2 = e5, a2 = n2, h2 = this._workCell.fg, c2 = this._workCell.bg;
              }
              n2 += this._workCell.getChars().length || o.WHITESPACE_CELL_CHAR.length;
            }
          if (this._bufferService.cols - r2 > 1) {
            const e5 = this._getJoinedRanges(s3, a2, n2, t3, r2);
            for (let t4 = 0;t4 < e5.length; t4++)
              i3.push(e5[t4]);
          }
          return i3;
        }
        _getJoinedRanges(t3, i3, s3, r2, n2) {
          const o2 = t3.substring(i3, s3);
          let a2 = [];
          try {
            a2 = this._characterJoiners[0].handler(o2);
          } catch (e4) {
            console.error(e4);
          }
          for (let t4 = 1;t4 < this._characterJoiners.length; t4++)
            try {
              const i4 = this._characterJoiners[t4].handler(o2);
              for (let t5 = 0;t5 < i4.length; t5++)
                e3._mergeRanges(a2, i4[t5]);
            } catch (e4) {
              console.error(e4);
            }
          return this._stringRangesToCellRanges(a2, r2, n2), a2;
        }
        _stringRangesToCellRanges(e4, t3, i3) {
          let s3 = 0, r2 = false, n2 = 0, a2 = e4[s3];
          if (a2) {
            for (let h2 = i3;h2 < this._bufferService.cols; h2++) {
              const i4 = t3.getWidth(h2), c2 = t3.getString(h2).length || o.WHITESPACE_CELL_CHAR.length;
              if (i4 !== 0) {
                if (!r2 && a2[0] <= n2 && (a2[0] = h2, r2 = true), a2[1] <= n2) {
                  if (a2[1] = h2, a2 = e4[++s3], !a2)
                    break;
                  a2[0] <= n2 ? (a2[0] = h2, r2 = true) : r2 = false;
                }
                n2 += c2;
              }
            }
            a2 && (a2[1] = this._bufferService.cols);
          }
        }
        static _mergeRanges(e4, t3) {
          let i3 = false;
          for (let s3 = 0;s3 < e4.length; s3++) {
            const r2 = e4[s3];
            if (i3) {
              if (t3[1] <= r2[0])
                return e4[s3 - 1][1] = t3[1], e4;
              if (t3[1] <= r2[1])
                return e4[s3 - 1][1] = Math.max(t3[1], r2[1]), e4.splice(s3, 1), e4;
              e4.splice(s3, 1), s3--;
            } else {
              if (t3[1] <= r2[0])
                return e4.splice(s3, 0, t3), e4;
              if (t3[1] <= r2[1])
                return r2[0] = Math.min(t3[0], r2[0]), e4;
              t3[0] < r2[1] && (r2[0] = Math.min(t3[0], r2[0]), i3 = true);
            }
          }
          return i3 ? e4[e4.length - 1][1] = t3[1] : e4.push(t3), e4;
        }
      };
      t2.CharacterJoinerService = l = s2([r(0, h.IBufferService)], l);
    }, 5114: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.CoreBrowserService = undefined;
      const s2 = i2(844), r = i2(8460), n = i2(3656);

      class o extends s2.Disposable {
        constructor(e3, t3, i3) {
          super(), this._textarea = e3, this._window = t3, this.mainDocument = i3, this._isFocused = false, this._cachedIsFocused = undefined, this._screenDprMonitor = new a(this._window), this._onDprChange = this.register(new r.EventEmitter), this.onDprChange = this._onDprChange.event, this._onWindowChange = this.register(new r.EventEmitter), this.onWindowChange = this._onWindowChange.event, this.register(this.onWindowChange((e4) => this._screenDprMonitor.setWindow(e4))), this.register((0, r.forwardEvent)(this._screenDprMonitor.onDprChange, this._onDprChange)), this._textarea.addEventListener("focus", () => this._isFocused = true), this._textarea.addEventListener("blur", () => this._isFocused = false);
        }
        get window() {
          return this._window;
        }
        set window(e3) {
          this._window !== e3 && (this._window = e3, this._onWindowChange.fire(this._window));
        }
        get dpr() {
          return this.window.devicePixelRatio;
        }
        get isFocused() {
          return this._cachedIsFocused === undefined && (this._cachedIsFocused = this._isFocused && this._textarea.ownerDocument.hasFocus(), queueMicrotask(() => this._cachedIsFocused = undefined)), this._cachedIsFocused;
        }
      }
      t2.CoreBrowserService = o;

      class a extends s2.Disposable {
        constructor(e3) {
          super(), this._parentWindow = e3, this._windowResizeListener = this.register(new s2.MutableDisposable), this._onDprChange = this.register(new r.EventEmitter), this.onDprChange = this._onDprChange.event, this._outerListener = () => this._setDprAndFireIfDiffers(), this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this._updateDpr(), this._setWindowResizeListener(), this.register((0, s2.toDisposable)(() => this.clearListener()));
        }
        setWindow(e3) {
          this._parentWindow = e3, this._setWindowResizeListener(), this._setDprAndFireIfDiffers();
        }
        _setWindowResizeListener() {
          this._windowResizeListener.value = (0, n.addDisposableDomListener)(this._parentWindow, "resize", () => this._setDprAndFireIfDiffers());
        }
        _setDprAndFireIfDiffers() {
          this._parentWindow.devicePixelRatio !== this._currentDevicePixelRatio && this._onDprChange.fire(this._parentWindow.devicePixelRatio), this._updateDpr();
        }
        _updateDpr() {
          this._outerListener && (this._resolutionMediaMatchList?.removeListener(this._outerListener), this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this._resolutionMediaMatchList = this._parentWindow.matchMedia(`screen and (resolution: ${this._parentWindow.devicePixelRatio}dppx)`), this._resolutionMediaMatchList.addListener(this._outerListener));
        }
        clearListener() {
          this._resolutionMediaMatchList && this._outerListener && (this._resolutionMediaMatchList.removeListener(this._outerListener), this._resolutionMediaMatchList = undefined, this._outerListener = undefined);
        }
      }
    }, 8934: function(e2, t2, i2) {
      var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : s3 === null ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          o2 = Reflect.decorate(e3, t3, i3, s3);
        else
          for (var a2 = e3.length - 1;a2 >= 0; a2--)
            (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i3, s3) {
          t3(i3, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.MouseService = undefined;
      const n = i2(4725), o = i2(9806);
      let a = t2.MouseService = class {
        constructor(e3, t3) {
          this._renderService = e3, this._charSizeService = t3;
        }
        getCoords(e3, t3, i3, s3, r2) {
          return (0, o.getCoords)(window, e3, t3, i3, s3, this._charSizeService.hasValidSize, this._renderService.dimensions.css.cell.width, this._renderService.dimensions.css.cell.height, r2);
        }
        getMouseReportCoords(e3, t3) {
          const i3 = (0, o.getCoordsRelativeToElement)(window, e3, t3);
          if (this._charSizeService.hasValidSize)
            return i3[0] = Math.min(Math.max(i3[0], 0), this._renderService.dimensions.css.canvas.width - 1), i3[1] = Math.min(Math.max(i3[1], 0), this._renderService.dimensions.css.canvas.height - 1), { col: Math.floor(i3[0] / this._renderService.dimensions.css.cell.width), row: Math.floor(i3[1] / this._renderService.dimensions.css.cell.height), x: Math.floor(i3[0]), y: Math.floor(i3[1]) };
        }
      };
      t2.MouseService = a = s2([r(0, n.IRenderService), r(1, n.ICharSizeService)], a);
    }, 3230: function(e2, t2, i2) {
      var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : s3 === null ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          o2 = Reflect.decorate(e3, t3, i3, s3);
        else
          for (var a2 = e3.length - 1;a2 >= 0; a2--)
            (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i3, s3) {
          t3(i3, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.RenderService = undefined;
      const n = i2(6193), o = i2(4725), a = i2(8460), h = i2(844), c = i2(7226), l = i2(2585);
      let d = t2.RenderService = class extends h.Disposable {
        get dimensions() {
          return this._renderer.value.dimensions;
        }
        constructor(e3, t3, i3, s3, r2, o2, l2, d2, _) {
          if (super(), this._rowCount = e3, this._charSizeService = s3, this._renderer = this.register(new h.MutableDisposable), this._pausedResizeTask = new c.DebouncedIdleTask, this._isPaused = false, this._needsFullRefresh = false, this._isNextRenderRedrawOnly = true, this._needsSelectionRefresh = false, this._canvasWidth = 0, this._canvasHeight = 0, this._selectionState = { start: undefined, end: undefined, columnSelectMode: false }, this._onDimensionsChange = this.register(new a.EventEmitter), this.onDimensionsChange = this._onDimensionsChange.event, this._onRenderedViewportChange = this.register(new a.EventEmitter), this.onRenderedViewportChange = this._onRenderedViewportChange.event, this._onRender = this.register(new a.EventEmitter), this.onRender = this._onRender.event, this._onRefreshRequest = this.register(new a.EventEmitter), this.onRefreshRequest = this._onRefreshRequest.event, this._renderDebouncer = new n.RenderDebouncer(l2.window, (e4, t4) => this._renderRows(e4, t4)), this.register(this._renderDebouncer), this.register(l2.onDprChange(() => this.handleDevicePixelRatioChange())), this.register(o2.onResize(() => this._fullRefresh())), this.register(o2.buffers.onBufferActivate(() => this._renderer.value?.clear())), this.register(i3.onOptionChange(() => this._handleOptionsChanged())), this.register(this._charSizeService.onCharSizeChange(() => this.handleCharSizeChanged())), this.register(r2.onDecorationRegistered(() => this._fullRefresh())), this.register(r2.onDecorationRemoved(() => this._fullRefresh())), this.register(i3.onMultipleOptionChange(["customGlyphs", "drawBoldTextInBrightColors", "letterSpacing", "lineHeight", "fontFamily", "fontSize", "fontWeight", "fontWeightBold", "minimumContrastRatio"], () => {
            this.clear(), this.handleResize(o2.cols, o2.rows), this._fullRefresh();
          })), this.register(i3.onMultipleOptionChange(["cursorBlink", "cursorStyle"], () => this.refreshRows(o2.buffer.y, o2.buffer.y, true))), this.register(_.onChangeColors(() => this._fullRefresh())), ("IntersectionObserver" in l2.window)) {
            const e4 = new l2.window.IntersectionObserver((e5) => this._handleIntersectionChange(e5[e5.length - 1]), { threshold: 0 });
            e4.observe(t3), this.register({ dispose: () => e4.disconnect() });
          }
        }
        _handleIntersectionChange(e3) {
          this._isPaused = e3.isIntersecting === undefined ? e3.intersectionRatio === 0 : !e3.isIntersecting, this._isPaused || this._charSizeService.hasValidSize || this._charSizeService.measure(), !this._isPaused && this._needsFullRefresh && (this._pausedResizeTask.flush(), this.refreshRows(0, this._rowCount - 1), this._needsFullRefresh = false);
        }
        refreshRows(e3, t3, i3 = false) {
          this._isPaused ? this._needsFullRefresh = true : (i3 || (this._isNextRenderRedrawOnly = false), this._renderDebouncer.refresh(e3, t3, this._rowCount));
        }
        _renderRows(e3, t3) {
          this._renderer.value && (e3 = Math.min(e3, this._rowCount - 1), t3 = Math.min(t3, this._rowCount - 1), this._renderer.value.renderRows(e3, t3), this._needsSelectionRefresh && (this._renderer.value.handleSelectionChanged(this._selectionState.start, this._selectionState.end, this._selectionState.columnSelectMode), this._needsSelectionRefresh = false), this._isNextRenderRedrawOnly || this._onRenderedViewportChange.fire({ start: e3, end: t3 }), this._onRender.fire({ start: e3, end: t3 }), this._isNextRenderRedrawOnly = true);
        }
        resize(e3, t3) {
          this._rowCount = t3, this._fireOnCanvasResize();
        }
        _handleOptionsChanged() {
          this._renderer.value && (this.refreshRows(0, this._rowCount - 1), this._fireOnCanvasResize());
        }
        _fireOnCanvasResize() {
          this._renderer.value && (this._renderer.value.dimensions.css.canvas.width === this._canvasWidth && this._renderer.value.dimensions.css.canvas.height === this._canvasHeight || this._onDimensionsChange.fire(this._renderer.value.dimensions));
        }
        hasRenderer() {
          return !!this._renderer.value;
        }
        setRenderer(e3) {
          this._renderer.value = e3, this._renderer.value && (this._renderer.value.onRequestRedraw((e4) => this.refreshRows(e4.start, e4.end, true)), this._needsSelectionRefresh = true, this._fullRefresh());
        }
        addRefreshCallback(e3) {
          return this._renderDebouncer.addRefreshCallback(e3);
        }
        _fullRefresh() {
          this._isPaused ? this._needsFullRefresh = true : this.refreshRows(0, this._rowCount - 1);
        }
        clearTextureAtlas() {
          this._renderer.value && (this._renderer.value.clearTextureAtlas?.(), this._fullRefresh());
        }
        handleDevicePixelRatioChange() {
          this._charSizeService.measure(), this._renderer.value && (this._renderer.value.handleDevicePixelRatioChange(), this.refreshRows(0, this._rowCount - 1));
        }
        handleResize(e3, t3) {
          this._renderer.value && (this._isPaused ? this._pausedResizeTask.set(() => this._renderer.value.handleResize(e3, t3)) : this._renderer.value.handleResize(e3, t3), this._fullRefresh());
        }
        handleCharSizeChanged() {
          this._renderer.value?.handleCharSizeChanged();
        }
        handleBlur() {
          this._renderer.value?.handleBlur();
        }
        handleFocus() {
          this._renderer.value?.handleFocus();
        }
        handleSelectionChanged(e3, t3, i3) {
          this._selectionState.start = e3, this._selectionState.end = t3, this._selectionState.columnSelectMode = i3, this._renderer.value?.handleSelectionChanged(e3, t3, i3);
        }
        handleCursorMove() {
          this._renderer.value?.handleCursorMove();
        }
        clear() {
          this._renderer.value?.clear();
        }
      };
      t2.RenderService = d = s2([r(2, l.IOptionsService), r(3, o.ICharSizeService), r(4, l.IDecorationService), r(5, l.IBufferService), r(6, o.ICoreBrowserService), r(7, l.IInstantiationService), r(8, o.IThemeService)], d);
    }, 9312: function(e2, t2, i2) {
      var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : s3 === null ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          o2 = Reflect.decorate(e3, t3, i3, s3);
        else
          for (var a2 = e3.length - 1;a2 >= 0; a2--)
            (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i3, s3) {
          t3(i3, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.SelectionService = undefined;
      const n = i2(9806), o = i2(9504), a = i2(456), h = i2(4725), c = i2(8460), l = i2(844), d = i2(6114), _ = i2(4841), u = i2(511), f = i2(2585), v = String.fromCharCode(160), g = new RegExp(v, "g");
      let p = t2.SelectionService = class extends l.Disposable {
        constructor(e3, t3, i3, s3, r2, n2, o2, h2, d2) {
          super(), this._element = e3, this._screenElement = t3, this._linkifier = i3, this._bufferService = s3, this._coreService = r2, this._mouseService = n2, this._optionsService = o2, this._renderService = h2, this._coreBrowserService = d2, this._dragScrollAmount = 0, this._enabled = true, this._workCell = new u.CellData, this._mouseDownTimeStamp = 0, this._oldHasSelection = false, this._oldSelectionStart = undefined, this._oldSelectionEnd = undefined, this._onLinuxMouseSelection = this.register(new c.EventEmitter), this.onLinuxMouseSelection = this._onLinuxMouseSelection.event, this._onRedrawRequest = this.register(new c.EventEmitter), this.onRequestRedraw = this._onRedrawRequest.event, this._onSelectionChange = this.register(new c.EventEmitter), this.onSelectionChange = this._onSelectionChange.event, this._onRequestScrollLines = this.register(new c.EventEmitter), this.onRequestScrollLines = this._onRequestScrollLines.event, this._mouseMoveListener = (e4) => this._handleMouseMove(e4), this._mouseUpListener = (e4) => this._handleMouseUp(e4), this._coreService.onUserInput(() => {
            this.hasSelection && this.clearSelection();
          }), this._trimListener = this._bufferService.buffer.lines.onTrim((e4) => this._handleTrim(e4)), this.register(this._bufferService.buffers.onBufferActivate((e4) => this._handleBufferActivate(e4))), this.enable(), this._model = new a.SelectionModel(this._bufferService), this._activeSelectionMode = 0, this.register((0, l.toDisposable)(() => {
            this._removeMouseDownListeners();
          }));
        }
        reset() {
          this.clearSelection();
        }
        disable() {
          this.clearSelection(), this._enabled = false;
        }
        enable() {
          this._enabled = true;
        }
        get selectionStart() {
          return this._model.finalSelectionStart;
        }
        get selectionEnd() {
          return this._model.finalSelectionEnd;
        }
        get hasSelection() {
          const e3 = this._model.finalSelectionStart, t3 = this._model.finalSelectionEnd;
          return !(!e3 || !t3 || e3[0] === t3[0] && e3[1] === t3[1]);
        }
        get selectionText() {
          const e3 = this._model.finalSelectionStart, t3 = this._model.finalSelectionEnd;
          if (!e3 || !t3)
            return "";
          const i3 = this._bufferService.buffer, s3 = [];
          if (this._activeSelectionMode === 3) {
            if (e3[0] === t3[0])
              return "";
            const r2 = e3[0] < t3[0] ? e3[0] : t3[0], n2 = e3[0] < t3[0] ? t3[0] : e3[0];
            for (let o2 = e3[1];o2 <= t3[1]; o2++) {
              const e4 = i3.translateBufferLineToString(o2, true, r2, n2);
              s3.push(e4);
            }
          } else {
            const r2 = e3[1] === t3[1] ? t3[0] : undefined;
            s3.push(i3.translateBufferLineToString(e3[1], true, e3[0], r2));
            for (let r3 = e3[1] + 1;r3 <= t3[1] - 1; r3++) {
              const e4 = i3.lines.get(r3), t4 = i3.translateBufferLineToString(r3, true);
              e4?.isWrapped ? s3[s3.length - 1] += t4 : s3.push(t4);
            }
            if (e3[1] !== t3[1]) {
              const e4 = i3.lines.get(t3[1]), r3 = i3.translateBufferLineToString(t3[1], true, 0, t3[0]);
              e4 && e4.isWrapped ? s3[s3.length - 1] += r3 : s3.push(r3);
            }
          }
          return s3.map((e4) => e4.replace(g, " ")).join(d.isWindows ? "\r\n" : "\n");
        }
        clearSelection() {
          this._model.clearSelection(), this._removeMouseDownListeners(), this.refresh(), this._onSelectionChange.fire();
        }
        refresh(e3) {
          this._refreshAnimationFrame || (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._refresh())), d.isLinux && e3 && this.selectionText.length && this._onLinuxMouseSelection.fire(this.selectionText);
        }
        _refresh() {
          this._refreshAnimationFrame = undefined, this._onRedrawRequest.fire({ start: this._model.finalSelectionStart, end: this._model.finalSelectionEnd, columnSelectMode: this._activeSelectionMode === 3 });
        }
        _isClickInSelection(e3) {
          const t3 = this._getMouseBufferCoords(e3), i3 = this._model.finalSelectionStart, s3 = this._model.finalSelectionEnd;
          return !!(i3 && s3 && t3) && this._areCoordsInSelection(t3, i3, s3);
        }
        isCellInSelection(e3, t3) {
          const i3 = this._model.finalSelectionStart, s3 = this._model.finalSelectionEnd;
          return !(!i3 || !s3) && this._areCoordsInSelection([e3, t3], i3, s3);
        }
        _areCoordsInSelection(e3, t3, i3) {
          return e3[1] > t3[1] && e3[1] < i3[1] || t3[1] === i3[1] && e3[1] === t3[1] && e3[0] >= t3[0] && e3[0] < i3[0] || t3[1] < i3[1] && e3[1] === i3[1] && e3[0] < i3[0] || t3[1] < i3[1] && e3[1] === t3[1] && e3[0] >= t3[0];
        }
        _selectWordAtCursor(e3, t3) {
          const i3 = this._linkifier.currentLink?.link?.range;
          if (i3)
            return this._model.selectionStart = [i3.start.x - 1, i3.start.y - 1], this._model.selectionStartLength = (0, _.getRangeLength)(i3, this._bufferService.cols), this._model.selectionEnd = undefined, true;
          const s3 = this._getMouseBufferCoords(e3);
          return !!s3 && (this._selectWordAt(s3, t3), this._model.selectionEnd = undefined, true);
        }
        selectAll() {
          this._model.isSelectAllActive = true, this.refresh(), this._onSelectionChange.fire();
        }
        selectLines(e3, t3) {
          this._model.clearSelection(), e3 = Math.max(e3, 0), t3 = Math.min(t3, this._bufferService.buffer.lines.length - 1), this._model.selectionStart = [0, e3], this._model.selectionEnd = [this._bufferService.cols, t3], this.refresh(), this._onSelectionChange.fire();
        }
        _handleTrim(e3) {
          this._model.handleTrim(e3) && this.refresh();
        }
        _getMouseBufferCoords(e3) {
          const t3 = this._mouseService.getCoords(e3, this._screenElement, this._bufferService.cols, this._bufferService.rows, true);
          if (t3)
            return t3[0]--, t3[1]--, t3[1] += this._bufferService.buffer.ydisp, t3;
        }
        _getMouseEventScrollAmount(e3) {
          let t3 = (0, n.getCoordsRelativeToElement)(this._coreBrowserService.window, e3, this._screenElement)[1];
          const i3 = this._renderService.dimensions.css.canvas.height;
          return t3 >= 0 && t3 <= i3 ? 0 : (t3 > i3 && (t3 -= i3), t3 = Math.min(Math.max(t3, -50), 50), t3 /= 50, t3 / Math.abs(t3) + Math.round(14 * t3));
        }
        shouldForceSelection(e3) {
          return d.isMac ? e3.altKey && this._optionsService.rawOptions.macOptionClickForcesSelection : e3.shiftKey;
        }
        handleMouseDown(e3) {
          if (this._mouseDownTimeStamp = e3.timeStamp, (e3.button !== 2 || !this.hasSelection) && e3.button === 0) {
            if (!this._enabled) {
              if (!this.shouldForceSelection(e3))
                return;
              e3.stopPropagation();
            }
            e3.preventDefault(), this._dragScrollAmount = 0, this._enabled && e3.shiftKey ? this._handleIncrementalClick(e3) : e3.detail === 1 ? this._handleSingleClick(e3) : e3.detail === 2 ? this._handleDoubleClick(e3) : e3.detail === 3 && this._handleTripleClick(e3), this._addMouseDownListeners(), this.refresh(true);
          }
        }
        _addMouseDownListeners() {
          this._screenElement.ownerDocument && (this._screenElement.ownerDocument.addEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.addEventListener("mouseup", this._mouseUpListener)), this._dragScrollIntervalTimer = this._coreBrowserService.window.setInterval(() => this._dragScroll(), 50);
        }
        _removeMouseDownListeners() {
          this._screenElement.ownerDocument && (this._screenElement.ownerDocument.removeEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.removeEventListener("mouseup", this._mouseUpListener)), this._coreBrowserService.window.clearInterval(this._dragScrollIntervalTimer), this._dragScrollIntervalTimer = undefined;
        }
        _handleIncrementalClick(e3) {
          this._model.selectionStart && (this._model.selectionEnd = this._getMouseBufferCoords(e3));
        }
        _handleSingleClick(e3) {
          if (this._model.selectionStartLength = 0, this._model.isSelectAllActive = false, this._activeSelectionMode = this.shouldColumnSelect(e3) ? 3 : 0, this._model.selectionStart = this._getMouseBufferCoords(e3), !this._model.selectionStart)
            return;
          this._model.selectionEnd = undefined;
          const t3 = this._bufferService.buffer.lines.get(this._model.selectionStart[1]);
          t3 && t3.length !== this._model.selectionStart[0] && t3.hasWidth(this._model.selectionStart[0]) === 0 && this._model.selectionStart[0]++;
        }
        _handleDoubleClick(e3) {
          this._selectWordAtCursor(e3, true) && (this._activeSelectionMode = 1);
        }
        _handleTripleClick(e3) {
          const t3 = this._getMouseBufferCoords(e3);
          t3 && (this._activeSelectionMode = 2, this._selectLineAt(t3[1]));
        }
        shouldColumnSelect(e3) {
          return e3.altKey && !(d.isMac && this._optionsService.rawOptions.macOptionClickForcesSelection);
        }
        _handleMouseMove(e3) {
          if (e3.stopImmediatePropagation(), !this._model.selectionStart)
            return;
          const t3 = this._model.selectionEnd ? [this._model.selectionEnd[0], this._model.selectionEnd[1]] : null;
          if (this._model.selectionEnd = this._getMouseBufferCoords(e3), !this._model.selectionEnd)
            return void this.refresh(true);
          this._activeSelectionMode === 2 ? this._model.selectionEnd[1] < this._model.selectionStart[1] ? this._model.selectionEnd[0] = 0 : this._model.selectionEnd[0] = this._bufferService.cols : this._activeSelectionMode === 1 && this._selectToWordAt(this._model.selectionEnd), this._dragScrollAmount = this._getMouseEventScrollAmount(e3), this._activeSelectionMode !== 3 && (this._dragScrollAmount > 0 ? this._model.selectionEnd[0] = this._bufferService.cols : this._dragScrollAmount < 0 && (this._model.selectionEnd[0] = 0));
          const i3 = this._bufferService.buffer;
          if (this._model.selectionEnd[1] < i3.lines.length) {
            const e4 = i3.lines.get(this._model.selectionEnd[1]);
            e4 && e4.hasWidth(this._model.selectionEnd[0]) === 0 && this._model.selectionEnd[0] < this._bufferService.cols && this._model.selectionEnd[0]++;
          }
          t3 && t3[0] === this._model.selectionEnd[0] && t3[1] === this._model.selectionEnd[1] || this.refresh(true);
        }
        _dragScroll() {
          if (this._model.selectionEnd && this._model.selectionStart && this._dragScrollAmount) {
            this._onRequestScrollLines.fire({ amount: this._dragScrollAmount, suppressScrollEvent: false });
            const e3 = this._bufferService.buffer;
            this._dragScrollAmount > 0 ? (this._activeSelectionMode !== 3 && (this._model.selectionEnd[0] = this._bufferService.cols), this._model.selectionEnd[1] = Math.min(e3.ydisp + this._bufferService.rows, e3.lines.length - 1)) : (this._activeSelectionMode !== 3 && (this._model.selectionEnd[0] = 0), this._model.selectionEnd[1] = e3.ydisp), this.refresh();
          }
        }
        _handleMouseUp(e3) {
          const t3 = e3.timeStamp - this._mouseDownTimeStamp;
          if (this._removeMouseDownListeners(), this.selectionText.length <= 1 && t3 < 500 && e3.altKey && this._optionsService.rawOptions.altClickMovesCursor) {
            if (this._bufferService.buffer.ybase === this._bufferService.buffer.ydisp) {
              const t4 = this._mouseService.getCoords(e3, this._element, this._bufferService.cols, this._bufferService.rows, false);
              if (t4 && t4[0] !== undefined && t4[1] !== undefined) {
                const e4 = (0, o.moveToCellSequence)(t4[0] - 1, t4[1] - 1, this._bufferService, this._coreService.decPrivateModes.applicationCursorKeys);
                this._coreService.triggerDataEvent(e4, true);
              }
            }
          } else
            this._fireEventIfSelectionChanged();
        }
        _fireEventIfSelectionChanged() {
          const e3 = this._model.finalSelectionStart, t3 = this._model.finalSelectionEnd, i3 = !(!e3 || !t3 || e3[0] === t3[0] && e3[1] === t3[1]);
          i3 ? e3 && t3 && (this._oldSelectionStart && this._oldSelectionEnd && e3[0] === this._oldSelectionStart[0] && e3[1] === this._oldSelectionStart[1] && t3[0] === this._oldSelectionEnd[0] && t3[1] === this._oldSelectionEnd[1] || this._fireOnSelectionChange(e3, t3, i3)) : this._oldHasSelection && this._fireOnSelectionChange(e3, t3, i3);
        }
        _fireOnSelectionChange(e3, t3, i3) {
          this._oldSelectionStart = e3, this._oldSelectionEnd = t3, this._oldHasSelection = i3, this._onSelectionChange.fire();
        }
        _handleBufferActivate(e3) {
          this.clearSelection(), this._trimListener.dispose(), this._trimListener = e3.activeBuffer.lines.onTrim((e4) => this._handleTrim(e4));
        }
        _convertViewportColToCharacterIndex(e3, t3) {
          let i3 = t3;
          for (let s3 = 0;t3 >= s3; s3++) {
            const r2 = e3.loadCell(s3, this._workCell).getChars().length;
            this._workCell.getWidth() === 0 ? i3-- : r2 > 1 && t3 !== s3 && (i3 += r2 - 1);
          }
          return i3;
        }
        setSelection(e3, t3, i3) {
          this._model.clearSelection(), this._removeMouseDownListeners(), this._model.selectionStart = [e3, t3], this._model.selectionStartLength = i3, this.refresh(), this._fireEventIfSelectionChanged();
        }
        rightClickSelect(e3) {
          this._isClickInSelection(e3) || (this._selectWordAtCursor(e3, false) && this.refresh(true), this._fireEventIfSelectionChanged());
        }
        _getWordAt(e3, t3, i3 = true, s3 = true) {
          if (e3[0] >= this._bufferService.cols)
            return;
          const r2 = this._bufferService.buffer, n2 = r2.lines.get(e3[1]);
          if (!n2)
            return;
          const o2 = r2.translateBufferLineToString(e3[1], false);
          let a2 = this._convertViewportColToCharacterIndex(n2, e3[0]), h2 = a2;
          const c2 = e3[0] - a2;
          let l2 = 0, d2 = 0, _2 = 0, u2 = 0;
          if (o2.charAt(a2) === " ") {
            for (;a2 > 0 && o2.charAt(a2 - 1) === " "; )
              a2--;
            for (;h2 < o2.length && o2.charAt(h2 + 1) === " "; )
              h2++;
          } else {
            let t4 = e3[0], i4 = e3[0];
            n2.getWidth(t4) === 0 && (l2++, t4--), n2.getWidth(i4) === 2 && (d2++, i4++);
            const s4 = n2.getString(i4).length;
            for (s4 > 1 && (u2 += s4 - 1, h2 += s4 - 1);t4 > 0 && a2 > 0 && !this._isCharWordSeparator(n2.loadCell(t4 - 1, this._workCell)); ) {
              n2.loadCell(t4 - 1, this._workCell);
              const e4 = this._workCell.getChars().length;
              this._workCell.getWidth() === 0 ? (l2++, t4--) : e4 > 1 && (_2 += e4 - 1, a2 -= e4 - 1), a2--, t4--;
            }
            for (;i4 < n2.length && h2 + 1 < o2.length && !this._isCharWordSeparator(n2.loadCell(i4 + 1, this._workCell)); ) {
              n2.loadCell(i4 + 1, this._workCell);
              const e4 = this._workCell.getChars().length;
              this._workCell.getWidth() === 2 ? (d2++, i4++) : e4 > 1 && (u2 += e4 - 1, h2 += e4 - 1), h2++, i4++;
            }
          }
          h2++;
          let f2 = a2 + c2 - l2 + _2, v2 = Math.min(this._bufferService.cols, h2 - a2 + l2 + d2 - _2 - u2);
          if (t3 || o2.slice(a2, h2).trim() !== "") {
            if (i3 && f2 === 0 && n2.getCodePoint(0) !== 32) {
              const t4 = r2.lines.get(e3[1] - 1);
              if (t4 && n2.isWrapped && t4.getCodePoint(this._bufferService.cols - 1) !== 32) {
                const t5 = this._getWordAt([this._bufferService.cols - 1, e3[1] - 1], false, true, false);
                if (t5) {
                  const e4 = this._bufferService.cols - t5.start;
                  f2 -= e4, v2 += e4;
                }
              }
            }
            if (s3 && f2 + v2 === this._bufferService.cols && n2.getCodePoint(this._bufferService.cols - 1) !== 32) {
              const t4 = r2.lines.get(e3[1] + 1);
              if (t4?.isWrapped && t4.getCodePoint(0) !== 32) {
                const t5 = this._getWordAt([0, e3[1] + 1], false, false, true);
                t5 && (v2 += t5.length);
              }
            }
            return { start: f2, length: v2 };
          }
        }
        _selectWordAt(e3, t3) {
          const i3 = this._getWordAt(e3, t3);
          if (i3) {
            for (;i3.start < 0; )
              i3.start += this._bufferService.cols, e3[1]--;
            this._model.selectionStart = [i3.start, e3[1]], this._model.selectionStartLength = i3.length;
          }
        }
        _selectToWordAt(e3) {
          const t3 = this._getWordAt(e3, true);
          if (t3) {
            let i3 = e3[1];
            for (;t3.start < 0; )
              t3.start += this._bufferService.cols, i3--;
            if (!this._model.areSelectionValuesReversed())
              for (;t3.start + t3.length > this._bufferService.cols; )
                t3.length -= this._bufferService.cols, i3++;
            this._model.selectionEnd = [this._model.areSelectionValuesReversed() ? t3.start : t3.start + t3.length, i3];
          }
        }
        _isCharWordSeparator(e3) {
          return e3.getWidth() !== 0 && this._optionsService.rawOptions.wordSeparator.indexOf(e3.getChars()) >= 0;
        }
        _selectLineAt(e3) {
          const t3 = this._bufferService.buffer.getWrappedRangeForLine(e3), i3 = { start: { x: 0, y: t3.first }, end: { x: this._bufferService.cols - 1, y: t3.last } };
          this._model.selectionStart = [0, t3.first], this._model.selectionEnd = undefined, this._model.selectionStartLength = (0, _.getRangeLength)(i3, this._bufferService.cols);
        }
      };
      t2.SelectionService = p = s2([r(3, f.IBufferService), r(4, f.ICoreService), r(5, h.IMouseService), r(6, f.IOptionsService), r(7, h.IRenderService), r(8, h.ICoreBrowserService)], p);
    }, 4725: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.IThemeService = t2.ICharacterJoinerService = t2.ISelectionService = t2.IRenderService = t2.IMouseService = t2.ICoreBrowserService = t2.ICharSizeService = undefined;
      const s2 = i2(8343);
      t2.ICharSizeService = (0, s2.createDecorator)("CharSizeService"), t2.ICoreBrowserService = (0, s2.createDecorator)("CoreBrowserService"), t2.IMouseService = (0, s2.createDecorator)("MouseService"), t2.IRenderService = (0, s2.createDecorator)("RenderService"), t2.ISelectionService = (0, s2.createDecorator)("SelectionService"), t2.ICharacterJoinerService = (0, s2.createDecorator)("CharacterJoinerService"), t2.IThemeService = (0, s2.createDecorator)("ThemeService");
    }, 6731: function(e2, t2, i2) {
      var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : s3 === null ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          o2 = Reflect.decorate(e3, t3, i3, s3);
        else
          for (var a2 = e3.length - 1;a2 >= 0; a2--)
            (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i3, s3) {
          t3(i3, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.ThemeService = t2.DEFAULT_ANSI_COLORS = undefined;
      const n = i2(7239), o = i2(8055), a = i2(8460), h = i2(844), c = i2(2585), l = o.css.toColor("#ffffff"), d = o.css.toColor("#000000"), _ = o.css.toColor("#ffffff"), u = o.css.toColor("#000000"), f = { css: "rgba(255, 255, 255, 0.3)", rgba: 4294967117 };
      t2.DEFAULT_ANSI_COLORS = Object.freeze((() => {
        const e3 = [o.css.toColor("#2e3436"), o.css.toColor("#cc0000"), o.css.toColor("#4e9a06"), o.css.toColor("#c4a000"), o.css.toColor("#3465a4"), o.css.toColor("#75507b"), o.css.toColor("#06989a"), o.css.toColor("#d3d7cf"), o.css.toColor("#555753"), o.css.toColor("#ef2929"), o.css.toColor("#8ae234"), o.css.toColor("#fce94f"), o.css.toColor("#729fcf"), o.css.toColor("#ad7fa8"), o.css.toColor("#34e2e2"), o.css.toColor("#eeeeec")], t3 = [0, 95, 135, 175, 215, 255];
        for (let i3 = 0;i3 < 216; i3++) {
          const s3 = t3[i3 / 36 % 6 | 0], r2 = t3[i3 / 6 % 6 | 0], n2 = t3[i3 % 6];
          e3.push({ css: o.channels.toCss(s3, r2, n2), rgba: o.channels.toRgba(s3, r2, n2) });
        }
        for (let t4 = 0;t4 < 24; t4++) {
          const i3 = 8 + 10 * t4;
          e3.push({ css: o.channels.toCss(i3, i3, i3), rgba: o.channels.toRgba(i3, i3, i3) });
        }
        return e3;
      })());
      let v = t2.ThemeService = class extends h.Disposable {
        get colors() {
          return this._colors;
        }
        constructor(e3) {
          super(), this._optionsService = e3, this._contrastCache = new n.ColorContrastCache, this._halfContrastCache = new n.ColorContrastCache, this._onChangeColors = this.register(new a.EventEmitter), this.onChangeColors = this._onChangeColors.event, this._colors = { foreground: l, background: d, cursor: _, cursorAccent: u, selectionForeground: undefined, selectionBackgroundTransparent: f, selectionBackgroundOpaque: o.color.blend(d, f), selectionInactiveBackgroundTransparent: f, selectionInactiveBackgroundOpaque: o.color.blend(d, f), ansi: t2.DEFAULT_ANSI_COLORS.slice(), contrastCache: this._contrastCache, halfContrastCache: this._halfContrastCache }, this._updateRestoreColors(), this._setTheme(this._optionsService.rawOptions.theme), this.register(this._optionsService.onSpecificOptionChange("minimumContrastRatio", () => this._contrastCache.clear())), this.register(this._optionsService.onSpecificOptionChange("theme", () => this._setTheme(this._optionsService.rawOptions.theme)));
        }
        _setTheme(e3 = {}) {
          const i3 = this._colors;
          if (i3.foreground = g(e3.foreground, l), i3.background = g(e3.background, d), i3.cursor = g(e3.cursor, _), i3.cursorAccent = g(e3.cursorAccent, u), i3.selectionBackgroundTransparent = g(e3.selectionBackground, f), i3.selectionBackgroundOpaque = o.color.blend(i3.background, i3.selectionBackgroundTransparent), i3.selectionInactiveBackgroundTransparent = g(e3.selectionInactiveBackground, i3.selectionBackgroundTransparent), i3.selectionInactiveBackgroundOpaque = o.color.blend(i3.background, i3.selectionInactiveBackgroundTransparent), i3.selectionForeground = e3.selectionForeground ? g(e3.selectionForeground, o.NULL_COLOR) : undefined, i3.selectionForeground === o.NULL_COLOR && (i3.selectionForeground = undefined), o.color.isOpaque(i3.selectionBackgroundTransparent)) {
            const e4 = 0.3;
            i3.selectionBackgroundTransparent = o.color.opacity(i3.selectionBackgroundTransparent, e4);
          }
          if (o.color.isOpaque(i3.selectionInactiveBackgroundTransparent)) {
            const e4 = 0.3;
            i3.selectionInactiveBackgroundTransparent = o.color.opacity(i3.selectionInactiveBackgroundTransparent, e4);
          }
          if (i3.ansi = t2.DEFAULT_ANSI_COLORS.slice(), i3.ansi[0] = g(e3.black, t2.DEFAULT_ANSI_COLORS[0]), i3.ansi[1] = g(e3.red, t2.DEFAULT_ANSI_COLORS[1]), i3.ansi[2] = g(e3.green, t2.DEFAULT_ANSI_COLORS[2]), i3.ansi[3] = g(e3.yellow, t2.DEFAULT_ANSI_COLORS[3]), i3.ansi[4] = g(e3.blue, t2.DEFAULT_ANSI_COLORS[4]), i3.ansi[5] = g(e3.magenta, t2.DEFAULT_ANSI_COLORS[5]), i3.ansi[6] = g(e3.cyan, t2.DEFAULT_ANSI_COLORS[6]), i3.ansi[7] = g(e3.white, t2.DEFAULT_ANSI_COLORS[7]), i3.ansi[8] = g(e3.brightBlack, t2.DEFAULT_ANSI_COLORS[8]), i3.ansi[9] = g(e3.brightRed, t2.DEFAULT_ANSI_COLORS[9]), i3.ansi[10] = g(e3.brightGreen, t2.DEFAULT_ANSI_COLORS[10]), i3.ansi[11] = g(e3.brightYellow, t2.DEFAULT_ANSI_COLORS[11]), i3.ansi[12] = g(e3.brightBlue, t2.DEFAULT_ANSI_COLORS[12]), i3.ansi[13] = g(e3.brightMagenta, t2.DEFAULT_ANSI_COLORS[13]), i3.ansi[14] = g(e3.brightCyan, t2.DEFAULT_ANSI_COLORS[14]), i3.ansi[15] = g(e3.brightWhite, t2.DEFAULT_ANSI_COLORS[15]), e3.extendedAnsi) {
            const s3 = Math.min(i3.ansi.length - 16, e3.extendedAnsi.length);
            for (let r2 = 0;r2 < s3; r2++)
              i3.ansi[r2 + 16] = g(e3.extendedAnsi[r2], t2.DEFAULT_ANSI_COLORS[r2 + 16]);
          }
          this._contrastCache.clear(), this._halfContrastCache.clear(), this._updateRestoreColors(), this._onChangeColors.fire(this.colors);
        }
        restoreColor(e3) {
          this._restoreColor(e3), this._onChangeColors.fire(this.colors);
        }
        _restoreColor(e3) {
          if (e3 !== undefined)
            switch (e3) {
              case 256:
                this._colors.foreground = this._restoreColors.foreground;
                break;
              case 257:
                this._colors.background = this._restoreColors.background;
                break;
              case 258:
                this._colors.cursor = this._restoreColors.cursor;
                break;
              default:
                this._colors.ansi[e3] = this._restoreColors.ansi[e3];
            }
          else
            for (let e4 = 0;e4 < this._restoreColors.ansi.length; ++e4)
              this._colors.ansi[e4] = this._restoreColors.ansi[e4];
        }
        modifyColors(e3) {
          e3(this._colors), this._onChangeColors.fire(this.colors);
        }
        _updateRestoreColors() {
          this._restoreColors = { foreground: this._colors.foreground, background: this._colors.background, cursor: this._colors.cursor, ansi: this._colors.ansi.slice() };
        }
      };
      function g(e3, t3) {
        if (e3 !== undefined)
          try {
            return o.css.toColor(e3);
          } catch {
          }
        return t3;
      }
      t2.ThemeService = v = s2([r(0, c.IOptionsService)], v);
    }, 6349: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.CircularList = undefined;
      const s2 = i2(8460), r = i2(844);

      class n extends r.Disposable {
        constructor(e3) {
          super(), this._maxLength = e3, this.onDeleteEmitter = this.register(new s2.EventEmitter), this.onDelete = this.onDeleteEmitter.event, this.onInsertEmitter = this.register(new s2.EventEmitter), this.onInsert = this.onInsertEmitter.event, this.onTrimEmitter = this.register(new s2.EventEmitter), this.onTrim = this.onTrimEmitter.event, this._array = new Array(this._maxLength), this._startIndex = 0, this._length = 0;
        }
        get maxLength() {
          return this._maxLength;
        }
        set maxLength(e3) {
          if (this._maxLength === e3)
            return;
          const t3 = new Array(e3);
          for (let i3 = 0;i3 < Math.min(e3, this.length); i3++)
            t3[i3] = this._array[this._getCyclicIndex(i3)];
          this._array = t3, this._maxLength = e3, this._startIndex = 0;
        }
        get length() {
          return this._length;
        }
        set length(e3) {
          if (e3 > this._length)
            for (let t3 = this._length;t3 < e3; t3++)
              this._array[t3] = undefined;
          this._length = e3;
        }
        get(e3) {
          return this._array[this._getCyclicIndex(e3)];
        }
        set(e3, t3) {
          this._array[this._getCyclicIndex(e3)] = t3;
        }
        push(e3) {
          this._array[this._getCyclicIndex(this._length)] = e3, this._length === this._maxLength ? (this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1)) : this._length++;
        }
        recycle() {
          if (this._length !== this._maxLength)
            throw new Error("Can only recycle when the buffer is full");
          return this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1), this._array[this._getCyclicIndex(this._length - 1)];
        }
        get isFull() {
          return this._length === this._maxLength;
        }
        pop() {
          return this._array[this._getCyclicIndex(this._length-- - 1)];
        }
        splice(e3, t3, ...i3) {
          if (t3) {
            for (let i4 = e3;i4 < this._length - t3; i4++)
              this._array[this._getCyclicIndex(i4)] = this._array[this._getCyclicIndex(i4 + t3)];
            this._length -= t3, this.onDeleteEmitter.fire({ index: e3, amount: t3 });
          }
          for (let t4 = this._length - 1;t4 >= e3; t4--)
            this._array[this._getCyclicIndex(t4 + i3.length)] = this._array[this._getCyclicIndex(t4)];
          for (let t4 = 0;t4 < i3.length; t4++)
            this._array[this._getCyclicIndex(e3 + t4)] = i3[t4];
          if (i3.length && this.onInsertEmitter.fire({ index: e3, amount: i3.length }), this._length + i3.length > this._maxLength) {
            const e4 = this._length + i3.length - this._maxLength;
            this._startIndex += e4, this._length = this._maxLength, this.onTrimEmitter.fire(e4);
          } else
            this._length += i3.length;
        }
        trimStart(e3) {
          e3 > this._length && (e3 = this._length), this._startIndex += e3, this._length -= e3, this.onTrimEmitter.fire(e3);
        }
        shiftElements(e3, t3, i3) {
          if (!(t3 <= 0)) {
            if (e3 < 0 || e3 >= this._length)
              throw new Error("start argument out of range");
            if (e3 + i3 < 0)
              throw new Error("Cannot shift elements in list beyond index 0");
            if (i3 > 0) {
              for (let s4 = t3 - 1;s4 >= 0; s4--)
                this.set(e3 + s4 + i3, this.get(e3 + s4));
              const s3 = e3 + t3 + i3 - this._length;
              if (s3 > 0)
                for (this._length += s3;this._length > this._maxLength; )
                  this._length--, this._startIndex++, this.onTrimEmitter.fire(1);
            } else
              for (let s3 = 0;s3 < t3; s3++)
                this.set(e3 + s3 + i3, this.get(e3 + s3));
          }
        }
        _getCyclicIndex(e3) {
          return (this._startIndex + e3) % this._maxLength;
        }
      }
      t2.CircularList = n;
    }, 1439: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.clone = undefined, t2.clone = function e(t3, i2 = 5) {
        if (typeof t3 != "object")
          return t3;
        const s2 = Array.isArray(t3) ? [] : {};
        for (const r in t3)
          s2[r] = i2 <= 1 ? t3[r] : t3[r] && e(t3[r], i2 - 1);
        return s2;
      };
    }, 8055: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.contrastRatio = t2.toPaddedHex = t2.rgba = t2.rgb = t2.css = t2.color = t2.channels = t2.NULL_COLOR = undefined;
      const s2 = i2(6114);
      let r = 0, n = 0, o = 0, a = 0;
      var h, c, l, d, _;
      function u(e3) {
        const t3 = e3.toString(16);
        return t3.length < 2 ? "0" + t3 : t3;
      }
      function f(e3, t3) {
        return e3 < t3 ? (t3 + 0.05) / (e3 + 0.05) : (e3 + 0.05) / (t3 + 0.05);
      }
      t2.NULL_COLOR = { css: "#00000000", rgba: 0 }, function(e3) {
        e3.toCss = function(e4, t3, i3, s3) {
          return s3 !== undefined ? `#${u(e4)}${u(t3)}${u(i3)}${u(s3)}` : `#${u(e4)}${u(t3)}${u(i3)}`;
        }, e3.toRgba = function(e4, t3, i3, s3 = 255) {
          return (e4 << 24 | t3 << 16 | i3 << 8 | s3) >>> 0;
        };
      }(h || (t2.channels = h = {})), function(e3) {
        function t3(e4, t4) {
          return a = Math.round(255 * t4), [r, n, o] = _.toChannels(e4.rgba), { css: h.toCss(r, n, o, a), rgba: h.toRgba(r, n, o, a) };
        }
        e3.blend = function(e4, t4) {
          if (a = (255 & t4.rgba) / 255, a === 1)
            return { css: t4.css, rgba: t4.rgba };
          const i3 = t4.rgba >> 24 & 255, s3 = t4.rgba >> 16 & 255, c2 = t4.rgba >> 8 & 255, l2 = e4.rgba >> 24 & 255, d2 = e4.rgba >> 16 & 255, _2 = e4.rgba >> 8 & 255;
          return r = l2 + Math.round((i3 - l2) * a), n = d2 + Math.round((s3 - d2) * a), o = _2 + Math.round((c2 - _2) * a), { css: h.toCss(r, n, o), rgba: h.toRgba(r, n, o) };
        }, e3.isOpaque = function(e4) {
          return (255 & e4.rgba) == 255;
        }, e3.ensureContrastRatio = function(e4, t4, i3) {
          const s3 = _.ensureContrastRatio(e4.rgba, t4.rgba, i3);
          if (s3)
            return _.toColor(s3 >> 24 & 255, s3 >> 16 & 255, s3 >> 8 & 255);
        }, e3.opaque = function(e4) {
          const t4 = (255 | e4.rgba) >>> 0;
          return [r, n, o] = _.toChannels(t4), { css: h.toCss(r, n, o), rgba: t4 };
        }, e3.opacity = t3, e3.multiplyOpacity = function(e4, i3) {
          return a = 255 & e4.rgba, t3(e4, a * i3 / 255);
        }, e3.toColorRGB = function(e4) {
          return [e4.rgba >> 24 & 255, e4.rgba >> 16 & 255, e4.rgba >> 8 & 255];
        };
      }(c || (t2.color = c = {})), function(e3) {
        let t3, i3;
        if (!s2.isNode) {
          const e4 = document.createElement("canvas");
          e4.width = 1, e4.height = 1;
          const s3 = e4.getContext("2d", { willReadFrequently: true });
          s3 && (t3 = s3, t3.globalCompositeOperation = "copy", i3 = t3.createLinearGradient(0, 0, 1, 1));
        }
        e3.toColor = function(e4) {
          if (e4.match(/#[\da-f]{3,8}/i))
            switch (e4.length) {
              case 4:
                return r = parseInt(e4.slice(1, 2).repeat(2), 16), n = parseInt(e4.slice(2, 3).repeat(2), 16), o = parseInt(e4.slice(3, 4).repeat(2), 16), _.toColor(r, n, o);
              case 5:
                return r = parseInt(e4.slice(1, 2).repeat(2), 16), n = parseInt(e4.slice(2, 3).repeat(2), 16), o = parseInt(e4.slice(3, 4).repeat(2), 16), a = parseInt(e4.slice(4, 5).repeat(2), 16), _.toColor(r, n, o, a);
              case 7:
                return { css: e4, rgba: (parseInt(e4.slice(1), 16) << 8 | 255) >>> 0 };
              case 9:
                return { css: e4, rgba: parseInt(e4.slice(1), 16) >>> 0 };
            }
          const s3 = e4.match(/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(,\s*(0|1|\d?\.(\d+))\s*)?\)/);
          if (s3)
            return r = parseInt(s3[1]), n = parseInt(s3[2]), o = parseInt(s3[3]), a = Math.round(255 * (s3[5] === undefined ? 1 : parseFloat(s3[5]))), _.toColor(r, n, o, a);
          if (!t3 || !i3)
            throw new Error("css.toColor: Unsupported css format");
          if (t3.fillStyle = i3, t3.fillStyle = e4, typeof t3.fillStyle != "string")
            throw new Error("css.toColor: Unsupported css format");
          if (t3.fillRect(0, 0, 1, 1), [r, n, o, a] = t3.getImageData(0, 0, 1, 1).data, a !== 255)
            throw new Error("css.toColor: Unsupported css format");
          return { rgba: h.toRgba(r, n, o, a), css: e4 };
        };
      }(l || (t2.css = l = {})), function(e3) {
        function t3(e4, t4, i3) {
          const s3 = e4 / 255, r2 = t4 / 255, n2 = i3 / 255;
          return 0.2126 * (s3 <= 0.03928 ? s3 / 12.92 : Math.pow((s3 + 0.055) / 1.055, 2.4)) + 0.7152 * (r2 <= 0.03928 ? r2 / 12.92 : Math.pow((r2 + 0.055) / 1.055, 2.4)) + 0.0722 * (n2 <= 0.03928 ? n2 / 12.92 : Math.pow((n2 + 0.055) / 1.055, 2.4));
        }
        e3.relativeLuminance = function(e4) {
          return t3(e4 >> 16 & 255, e4 >> 8 & 255, 255 & e4);
        }, e3.relativeLuminance2 = t3;
      }(d || (t2.rgb = d = {})), function(e3) {
        function t3(e4, t4, i4) {
          const s3 = e4 >> 24 & 255, r2 = e4 >> 16 & 255, n2 = e4 >> 8 & 255;
          let o2 = t4 >> 24 & 255, a2 = t4 >> 16 & 255, h2 = t4 >> 8 & 255, c2 = f(d.relativeLuminance2(o2, a2, h2), d.relativeLuminance2(s3, r2, n2));
          for (;c2 < i4 && (o2 > 0 || a2 > 0 || h2 > 0); )
            o2 -= Math.max(0, Math.ceil(0.1 * o2)), a2 -= Math.max(0, Math.ceil(0.1 * a2)), h2 -= Math.max(0, Math.ceil(0.1 * h2)), c2 = f(d.relativeLuminance2(o2, a2, h2), d.relativeLuminance2(s3, r2, n2));
          return (o2 << 24 | a2 << 16 | h2 << 8 | 255) >>> 0;
        }
        function i3(e4, t4, i4) {
          const s3 = e4 >> 24 & 255, r2 = e4 >> 16 & 255, n2 = e4 >> 8 & 255;
          let o2 = t4 >> 24 & 255, a2 = t4 >> 16 & 255, h2 = t4 >> 8 & 255, c2 = f(d.relativeLuminance2(o2, a2, h2), d.relativeLuminance2(s3, r2, n2));
          for (;c2 < i4 && (o2 < 255 || a2 < 255 || h2 < 255); )
            o2 = Math.min(255, o2 + Math.ceil(0.1 * (255 - o2))), a2 = Math.min(255, a2 + Math.ceil(0.1 * (255 - a2))), h2 = Math.min(255, h2 + Math.ceil(0.1 * (255 - h2))), c2 = f(d.relativeLuminance2(o2, a2, h2), d.relativeLuminance2(s3, r2, n2));
          return (o2 << 24 | a2 << 16 | h2 << 8 | 255) >>> 0;
        }
        e3.ensureContrastRatio = function(e4, s3, r2) {
          const n2 = d.relativeLuminance(e4 >> 8), o2 = d.relativeLuminance(s3 >> 8);
          if (f(n2, o2) < r2) {
            if (o2 < n2) {
              const o3 = t3(e4, s3, r2), a3 = f(n2, d.relativeLuminance(o3 >> 8));
              if (a3 < r2) {
                const t4 = i3(e4, s3, r2);
                return a3 > f(n2, d.relativeLuminance(t4 >> 8)) ? o3 : t4;
              }
              return o3;
            }
            const a2 = i3(e4, s3, r2), h2 = f(n2, d.relativeLuminance(a2 >> 8));
            if (h2 < r2) {
              const i4 = t3(e4, s3, r2);
              return h2 > f(n2, d.relativeLuminance(i4 >> 8)) ? a2 : i4;
            }
            return a2;
          }
        }, e3.reduceLuminance = t3, e3.increaseLuminance = i3, e3.toChannels = function(e4) {
          return [e4 >> 24 & 255, e4 >> 16 & 255, e4 >> 8 & 255, 255 & e4];
        }, e3.toColor = function(e4, t4, i4, s3) {
          return { css: h.toCss(e4, t4, i4, s3), rgba: h.toRgba(e4, t4, i4, s3) };
        };
      }(_ || (t2.rgba = _ = {})), t2.toPaddedHex = u, t2.contrastRatio = f;
    }, 8969: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.CoreTerminal = undefined;
      const s2 = i2(844), r = i2(2585), n = i2(4348), o = i2(7866), a = i2(744), h = i2(7302), c = i2(6975), l = i2(8460), d = i2(1753), _ = i2(1480), u = i2(7994), f = i2(9282), v = i2(5435), g = i2(5981), p = i2(2660);
      let m = false;

      class S extends s2.Disposable {
        get onScroll() {
          return this._onScrollApi || (this._onScrollApi = this.register(new l.EventEmitter), this._onScroll.event((e3) => {
            this._onScrollApi?.fire(e3.position);
          })), this._onScrollApi.event;
        }
        get cols() {
          return this._bufferService.cols;
        }
        get rows() {
          return this._bufferService.rows;
        }
        get buffers() {
          return this._bufferService.buffers;
        }
        get options() {
          return this.optionsService.options;
        }
        set options(e3) {
          for (const t3 in e3)
            this.optionsService.options[t3] = e3[t3];
        }
        constructor(e3) {
          super(), this._windowsWrappingHeuristics = this.register(new s2.MutableDisposable), this._onBinary = this.register(new l.EventEmitter), this.onBinary = this._onBinary.event, this._onData = this.register(new l.EventEmitter), this.onData = this._onData.event, this._onLineFeed = this.register(new l.EventEmitter), this.onLineFeed = this._onLineFeed.event, this._onResize = this.register(new l.EventEmitter), this.onResize = this._onResize.event, this._onWriteParsed = this.register(new l.EventEmitter), this.onWriteParsed = this._onWriteParsed.event, this._onScroll = this.register(new l.EventEmitter), this._instantiationService = new n.InstantiationService, this.optionsService = this.register(new h.OptionsService(e3)), this._instantiationService.setService(r.IOptionsService, this.optionsService), this._bufferService = this.register(this._instantiationService.createInstance(a.BufferService)), this._instantiationService.setService(r.IBufferService, this._bufferService), this._logService = this.register(this._instantiationService.createInstance(o.LogService)), this._instantiationService.setService(r.ILogService, this._logService), this.coreService = this.register(this._instantiationService.createInstance(c.CoreService)), this._instantiationService.setService(r.ICoreService, this.coreService), this.coreMouseService = this.register(this._instantiationService.createInstance(d.CoreMouseService)), this._instantiationService.setService(r.ICoreMouseService, this.coreMouseService), this.unicodeService = this.register(this._instantiationService.createInstance(_.UnicodeService)), this._instantiationService.setService(r.IUnicodeService, this.unicodeService), this._charsetService = this._instantiationService.createInstance(u.CharsetService), this._instantiationService.setService(r.ICharsetService, this._charsetService), this._oscLinkService = this._instantiationService.createInstance(p.OscLinkService), this._instantiationService.setService(r.IOscLinkService, this._oscLinkService), this._inputHandler = this.register(new v.InputHandler(this._bufferService, this._charsetService, this.coreService, this._logService, this.optionsService, this._oscLinkService, this.coreMouseService, this.unicodeService)), this.register((0, l.forwardEvent)(this._inputHandler.onLineFeed, this._onLineFeed)), this.register(this._inputHandler), this.register((0, l.forwardEvent)(this._bufferService.onResize, this._onResize)), this.register((0, l.forwardEvent)(this.coreService.onData, this._onData)), this.register((0, l.forwardEvent)(this.coreService.onBinary, this._onBinary)), this.register(this.coreService.onRequestScrollToBottom(() => this.scrollToBottom())), this.register(this.coreService.onUserInput(() => this._writeBuffer.handleUserInput())), this.register(this.optionsService.onMultipleOptionChange(["windowsMode", "windowsPty"], () => this._handleWindowsPtyOptionChange())), this.register(this._bufferService.onScroll((e4) => {
            this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
          })), this.register(this._inputHandler.onScroll((e4) => {
            this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
          })), this._writeBuffer = this.register(new g.WriteBuffer((e4, t3) => this._inputHandler.parse(e4, t3))), this.register((0, l.forwardEvent)(this._writeBuffer.onWriteParsed, this._onWriteParsed));
        }
        write(e3, t3) {
          this._writeBuffer.write(e3, t3);
        }
        writeSync(e3, t3) {
          this._logService.logLevel <= r.LogLevelEnum.WARN && !m && (this._logService.warn("writeSync is unreliable and will be removed soon."), m = true), this._writeBuffer.writeSync(e3, t3);
        }
        resize(e3, t3) {
          isNaN(e3) || isNaN(t3) || (e3 = Math.max(e3, a.MINIMUM_COLS), t3 = Math.max(t3, a.MINIMUM_ROWS), this._bufferService.resize(e3, t3));
        }
        scroll(e3, t3 = false) {
          this._bufferService.scroll(e3, t3);
        }
        scrollLines(e3, t3, i3) {
          this._bufferService.scrollLines(e3, t3, i3);
        }
        scrollPages(e3) {
          this.scrollLines(e3 * (this.rows - 1));
        }
        scrollToTop() {
          this.scrollLines(-this._bufferService.buffer.ydisp);
        }
        scrollToBottom() {
          this.scrollLines(this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp);
        }
        scrollToLine(e3) {
          const t3 = e3 - this._bufferService.buffer.ydisp;
          t3 !== 0 && this.scrollLines(t3);
        }
        registerEscHandler(e3, t3) {
          return this._inputHandler.registerEscHandler(e3, t3);
        }
        registerDcsHandler(e3, t3) {
          return this._inputHandler.registerDcsHandler(e3, t3);
        }
        registerCsiHandler(e3, t3) {
          return this._inputHandler.registerCsiHandler(e3, t3);
        }
        registerOscHandler(e3, t3) {
          return this._inputHandler.registerOscHandler(e3, t3);
        }
        _setup() {
          this._handleWindowsPtyOptionChange();
        }
        reset() {
          this._inputHandler.reset(), this._bufferService.reset(), this._charsetService.reset(), this.coreService.reset(), this.coreMouseService.reset();
        }
        _handleWindowsPtyOptionChange() {
          let e3 = false;
          const t3 = this.optionsService.rawOptions.windowsPty;
          t3 && t3.buildNumber !== undefined && t3.buildNumber !== undefined ? e3 = !!(t3.backend === "conpty" && t3.buildNumber < 21376) : this.optionsService.rawOptions.windowsMode && (e3 = true), e3 ? this._enableWindowsWrappingHeuristics() : this._windowsWrappingHeuristics.clear();
        }
        _enableWindowsWrappingHeuristics() {
          if (!this._windowsWrappingHeuristics.value) {
            const e3 = [];
            e3.push(this.onLineFeed(f.updateWindowsModeWrappedState.bind(null, this._bufferService))), e3.push(this.registerCsiHandler({ final: "H" }, () => ((0, f.updateWindowsModeWrappedState)(this._bufferService), false))), this._windowsWrappingHeuristics.value = (0, s2.toDisposable)(() => {
              for (const t3 of e3)
                t3.dispose();
            });
          }
        }
      }
      t2.CoreTerminal = S;
    }, 8460: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.runAndSubscribe = t2.forwardEvent = t2.EventEmitter = undefined, t2.EventEmitter = class {
        constructor() {
          this._listeners = [], this._disposed = false;
        }
        get event() {
          return this._event || (this._event = (e3) => (this._listeners.push(e3), { dispose: () => {
            if (!this._disposed) {
              for (let t3 = 0;t3 < this._listeners.length; t3++)
                if (this._listeners[t3] === e3)
                  return void this._listeners.splice(t3, 1);
            }
          } })), this._event;
        }
        fire(e3, t3) {
          const i2 = [];
          for (let e4 = 0;e4 < this._listeners.length; e4++)
            i2.push(this._listeners[e4]);
          for (let s2 = 0;s2 < i2.length; s2++)
            i2[s2].call(undefined, e3, t3);
        }
        dispose() {
          this.clearListeners(), this._disposed = true;
        }
        clearListeners() {
          this._listeners && (this._listeners.length = 0);
        }
      }, t2.forwardEvent = function(e3, t3) {
        return e3((e4) => t3.fire(e4));
      }, t2.runAndSubscribe = function(e3, t3) {
        return t3(undefined), e3((e4) => t3(e4));
      };
    }, 5435: function(e2, t2, i2) {
      var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : s3 === null ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          o2 = Reflect.decorate(e3, t3, i3, s3);
        else
          for (var a2 = e3.length - 1;a2 >= 0; a2--)
            (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i3, s3) {
          t3(i3, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.InputHandler = t2.WindowsOptionsReportType = undefined;
      const n = i2(2584), o = i2(7116), a = i2(2015), h = i2(844), c = i2(482), l = i2(8437), d = i2(8460), _ = i2(643), u = i2(511), f = i2(3734), v = i2(2585), g = i2(1480), p = i2(6242), m = i2(6351), S = i2(5941), C = { "(": 0, ")": 1, "*": 2, "+": 3, "-": 1, ".": 2 }, b = 131072;
      function y(e3, t3) {
        if (e3 > 24)
          return t3.setWinLines || false;
        switch (e3) {
          case 1:
            return !!t3.restoreWin;
          case 2:
            return !!t3.minimizeWin;
          case 3:
            return !!t3.setWinPosition;
          case 4:
            return !!t3.setWinSizePixels;
          case 5:
            return !!t3.raiseWin;
          case 6:
            return !!t3.lowerWin;
          case 7:
            return !!t3.refreshWin;
          case 8:
            return !!t3.setWinSizeChars;
          case 9:
            return !!t3.maximizeWin;
          case 10:
            return !!t3.fullscreenWin;
          case 11:
            return !!t3.getWinState;
          case 13:
            return !!t3.getWinPosition;
          case 14:
            return !!t3.getWinSizePixels;
          case 15:
            return !!t3.getScreenSizePixels;
          case 16:
            return !!t3.getCellSizePixels;
          case 18:
            return !!t3.getWinSizeChars;
          case 19:
            return !!t3.getScreenSizeChars;
          case 20:
            return !!t3.getIconTitle;
          case 21:
            return !!t3.getWinTitle;
          case 22:
            return !!t3.pushTitle;
          case 23:
            return !!t3.popTitle;
          case 24:
            return !!t3.setWinLines;
        }
        return false;
      }
      var w;
      (function(e3) {
        e3[e3.GET_WIN_SIZE_PIXELS = 0] = "GET_WIN_SIZE_PIXELS", e3[e3.GET_CELL_SIZE_PIXELS = 1] = "GET_CELL_SIZE_PIXELS";
      })(w || (t2.WindowsOptionsReportType = w = {}));
      let E = 0;

      class k extends h.Disposable {
        getAttrData() {
          return this._curAttrData;
        }
        constructor(e3, t3, i3, s3, r2, h2, _2, f2, v2 = new a.EscapeSequenceParser) {
          super(), this._bufferService = e3, this._charsetService = t3, this._coreService = i3, this._logService = s3, this._optionsService = r2, this._oscLinkService = h2, this._coreMouseService = _2, this._unicodeService = f2, this._parser = v2, this._parseBuffer = new Uint32Array(4096), this._stringDecoder = new c.StringToUtf32, this._utf8Decoder = new c.Utf8ToUtf32, this._workCell = new u.CellData, this._windowTitle = "", this._iconName = "", this._windowTitleStack = [], this._iconNameStack = [], this._curAttrData = l.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = l.DEFAULT_ATTR_DATA.clone(), this._onRequestBell = this.register(new d.EventEmitter), this.onRequestBell = this._onRequestBell.event, this._onRequestRefreshRows = this.register(new d.EventEmitter), this.onRequestRefreshRows = this._onRequestRefreshRows.event, this._onRequestReset = this.register(new d.EventEmitter), this.onRequestReset = this._onRequestReset.event, this._onRequestSendFocus = this.register(new d.EventEmitter), this.onRequestSendFocus = this._onRequestSendFocus.event, this._onRequestSyncScrollBar = this.register(new d.EventEmitter), this.onRequestSyncScrollBar = this._onRequestSyncScrollBar.event, this._onRequestWindowsOptionsReport = this.register(new d.EventEmitter), this.onRequestWindowsOptionsReport = this._onRequestWindowsOptionsReport.event, this._onA11yChar = this.register(new d.EventEmitter), this.onA11yChar = this._onA11yChar.event, this._onA11yTab = this.register(new d.EventEmitter), this.onA11yTab = this._onA11yTab.event, this._onCursorMove = this.register(new d.EventEmitter), this.onCursorMove = this._onCursorMove.event, this._onLineFeed = this.register(new d.EventEmitter), this.onLineFeed = this._onLineFeed.event, this._onScroll = this.register(new d.EventEmitter), this.onScroll = this._onScroll.event, this._onTitleChange = this.register(new d.EventEmitter), this.onTitleChange = this._onTitleChange.event, this._onColor = this.register(new d.EventEmitter), this.onColor = this._onColor.event, this._parseStack = { paused: false, cursorStartX: 0, cursorStartY: 0, decodedLength: 0, position: 0 }, this._specialColors = [256, 257, 258], this.register(this._parser), this._dirtyRowTracker = new L(this._bufferService), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate((e4) => this._activeBuffer = e4.activeBuffer)), this._parser.setCsiHandlerFallback((e4, t4) => {
            this._logService.debug("Unknown CSI code: ", { identifier: this._parser.identToString(e4), params: t4.toArray() });
          }), this._parser.setEscHandlerFallback((e4) => {
            this._logService.debug("Unknown ESC code: ", { identifier: this._parser.identToString(e4) });
          }), this._parser.setExecuteHandlerFallback((e4) => {
            this._logService.debug("Unknown EXECUTE code: ", { code: e4 });
          }), this._parser.setOscHandlerFallback((e4, t4, i4) => {
            this._logService.debug("Unknown OSC code: ", { identifier: e4, action: t4, data: i4 });
          }), this._parser.setDcsHandlerFallback((e4, t4, i4) => {
            t4 === "HOOK" && (i4 = i4.toArray()), this._logService.debug("Unknown DCS code: ", { identifier: this._parser.identToString(e4), action: t4, payload: i4 });
          }), this._parser.setPrintHandler((e4, t4, i4) => this.print(e4, t4, i4)), this._parser.registerCsiHandler({ final: "@" }, (e4) => this.insertChars(e4)), this._parser.registerCsiHandler({ intermediates: " ", final: "@" }, (e4) => this.scrollLeft(e4)), this._parser.registerCsiHandler({ final: "A" }, (e4) => this.cursorUp(e4)), this._parser.registerCsiHandler({ intermediates: " ", final: "A" }, (e4) => this.scrollRight(e4)), this._parser.registerCsiHandler({ final: "B" }, (e4) => this.cursorDown(e4)), this._parser.registerCsiHandler({ final: "C" }, (e4) => this.cursorForward(e4)), this._parser.registerCsiHandler({ final: "D" }, (e4) => this.cursorBackward(e4)), this._parser.registerCsiHandler({ final: "E" }, (e4) => this.cursorNextLine(e4)), this._parser.registerCsiHandler({ final: "F" }, (e4) => this.cursorPrecedingLine(e4)), this._parser.registerCsiHandler({ final: "G" }, (e4) => this.cursorCharAbsolute(e4)), this._parser.registerCsiHandler({ final: "H" }, (e4) => this.cursorPosition(e4)), this._parser.registerCsiHandler({ final: "I" }, (e4) => this.cursorForwardTab(e4)), this._parser.registerCsiHandler({ final: "J" }, (e4) => this.eraseInDisplay(e4, false)), this._parser.registerCsiHandler({ prefix: "?", final: "J" }, (e4) => this.eraseInDisplay(e4, true)), this._parser.registerCsiHandler({ final: "K" }, (e4) => this.eraseInLine(e4, false)), this._parser.registerCsiHandler({ prefix: "?", final: "K" }, (e4) => this.eraseInLine(e4, true)), this._parser.registerCsiHandler({ final: "L" }, (e4) => this.insertLines(e4)), this._parser.registerCsiHandler({ final: "M" }, (e4) => this.deleteLines(e4)), this._parser.registerCsiHandler({ final: "P" }, (e4) => this.deleteChars(e4)), this._parser.registerCsiHandler({ final: "S" }, (e4) => this.scrollUp(e4)), this._parser.registerCsiHandler({ final: "T" }, (e4) => this.scrollDown(e4)), this._parser.registerCsiHandler({ final: "X" }, (e4) => this.eraseChars(e4)), this._parser.registerCsiHandler({ final: "Z" }, (e4) => this.cursorBackwardTab(e4)), this._parser.registerCsiHandler({ final: "`" }, (e4) => this.charPosAbsolute(e4)), this._parser.registerCsiHandler({ final: "a" }, (e4) => this.hPositionRelative(e4)), this._parser.registerCsiHandler({ final: "b" }, (e4) => this.repeatPrecedingCharacter(e4)), this._parser.registerCsiHandler({ final: "c" }, (e4) => this.sendDeviceAttributesPrimary(e4)), this._parser.registerCsiHandler({ prefix: ">", final: "c" }, (e4) => this.sendDeviceAttributesSecondary(e4)), this._parser.registerCsiHandler({ final: "d" }, (e4) => this.linePosAbsolute(e4)), this._parser.registerCsiHandler({ final: "e" }, (e4) => this.vPositionRelative(e4)), this._parser.registerCsiHandler({ final: "f" }, (e4) => this.hVPosition(e4)), this._parser.registerCsiHandler({ final: "g" }, (e4) => this.tabClear(e4)), this._parser.registerCsiHandler({ final: "h" }, (e4) => this.setMode(e4)), this._parser.registerCsiHandler({ prefix: "?", final: "h" }, (e4) => this.setModePrivate(e4)), this._parser.registerCsiHandler({ final: "l" }, (e4) => this.resetMode(e4)), this._parser.registerCsiHandler({ prefix: "?", final: "l" }, (e4) => this.resetModePrivate(e4)), this._parser.registerCsiHandler({ final: "m" }, (e4) => this.charAttributes(e4)), this._parser.registerCsiHandler({ final: "n" }, (e4) => this.deviceStatus(e4)), this._parser.registerCsiHandler({ prefix: "?", final: "n" }, (e4) => this.deviceStatusPrivate(e4)), this._parser.registerCsiHandler({ intermediates: "!", final: "p" }, (e4) => this.softReset(e4)), this._parser.registerCsiHandler({ intermediates: " ", final: "q" }, (e4) => this.setCursorStyle(e4)), this._parser.registerCsiHandler({ final: "r" }, (e4) => this.setScrollRegion(e4)), this._parser.registerCsiHandler({ final: "s" }, (e4) => this.saveCursor(e4)), this._parser.registerCsiHandler({ final: "t" }, (e4) => this.windowOptions(e4)), this._parser.registerCsiHandler({ final: "u" }, (e4) => this.restoreCursor(e4)), this._parser.registerCsiHandler({ intermediates: "'", final: "}" }, (e4) => this.insertColumns(e4)), this._parser.registerCsiHandler({ intermediates: "'", final: "~" }, (e4) => this.deleteColumns(e4)), this._parser.registerCsiHandler({ intermediates: '"', final: "q" }, (e4) => this.selectProtected(e4)), this._parser.registerCsiHandler({ intermediates: "$", final: "p" }, (e4) => this.requestMode(e4, true)), this._parser.registerCsiHandler({ prefix: "?", intermediates: "$", final: "p" }, (e4) => this.requestMode(e4, false)), this._parser.setExecuteHandler(n.C0.BEL, () => this.bell()), this._parser.setExecuteHandler(n.C0.LF, () => this.lineFeed()), this._parser.setExecuteHandler(n.C0.VT, () => this.lineFeed()), this._parser.setExecuteHandler(n.C0.FF, () => this.lineFeed()), this._parser.setExecuteHandler(n.C0.CR, () => this.carriageReturn()), this._parser.setExecuteHandler(n.C0.BS, () => this.backspace()), this._parser.setExecuteHandler(n.C0.HT, () => this.tab()), this._parser.setExecuteHandler(n.C0.SO, () => this.shiftOut()), this._parser.setExecuteHandler(n.C0.SI, () => this.shiftIn()), this._parser.setExecuteHandler(n.C1.IND, () => this.index()), this._parser.setExecuteHandler(n.C1.NEL, () => this.nextLine()), this._parser.setExecuteHandler(n.C1.HTS, () => this.tabSet()), this._parser.registerOscHandler(0, new p.OscHandler((e4) => (this.setTitle(e4), this.setIconName(e4), true))), this._parser.registerOscHandler(1, new p.OscHandler((e4) => this.setIconName(e4))), this._parser.registerOscHandler(2, new p.OscHandler((e4) => this.setTitle(e4))), this._parser.registerOscHandler(4, new p.OscHandler((e4) => this.setOrReportIndexedColor(e4))), this._parser.registerOscHandler(8, new p.OscHandler((e4) => this.setHyperlink(e4))), this._parser.registerOscHandler(10, new p.OscHandler((e4) => this.setOrReportFgColor(e4))), this._parser.registerOscHandler(11, new p.OscHandler((e4) => this.setOrReportBgColor(e4))), this._parser.registerOscHandler(12, new p.OscHandler((e4) => this.setOrReportCursorColor(e4))), this._parser.registerOscHandler(104, new p.OscHandler((e4) => this.restoreIndexedColor(e4))), this._parser.registerOscHandler(110, new p.OscHandler((e4) => this.restoreFgColor(e4))), this._parser.registerOscHandler(111, new p.OscHandler((e4) => this.restoreBgColor(e4))), this._parser.registerOscHandler(112, new p.OscHandler((e4) => this.restoreCursorColor(e4))), this._parser.registerEscHandler({ final: "7" }, () => this.saveCursor()), this._parser.registerEscHandler({ final: "8" }, () => this.restoreCursor()), this._parser.registerEscHandler({ final: "D" }, () => this.index()), this._parser.registerEscHandler({ final: "E" }, () => this.nextLine()), this._parser.registerEscHandler({ final: "H" }, () => this.tabSet()), this._parser.registerEscHandler({ final: "M" }, () => this.reverseIndex()), this._parser.registerEscHandler({ final: "=" }, () => this.keypadApplicationMode()), this._parser.registerEscHandler({ final: ">" }, () => this.keypadNumericMode()), this._parser.registerEscHandler({ final: "c" }, () => this.fullReset()), this._parser.registerEscHandler({ final: "n" }, () => this.setgLevel(2)), this._parser.registerEscHandler({ final: "o" }, () => this.setgLevel(3)), this._parser.registerEscHandler({ final: "|" }, () => this.setgLevel(3)), this._parser.registerEscHandler({ final: "}" }, () => this.setgLevel(2)), this._parser.registerEscHandler({ final: "~" }, () => this.setgLevel(1)), this._parser.registerEscHandler({ intermediates: "%", final: "@" }, () => this.selectDefaultCharset()), this._parser.registerEscHandler({ intermediates: "%", final: "G" }, () => this.selectDefaultCharset());
          for (const e4 in o.CHARSETS)
            this._parser.registerEscHandler({ intermediates: "(", final: e4 }, () => this.selectCharset("(" + e4)), this._parser.registerEscHandler({ intermediates: ")", final: e4 }, () => this.selectCharset(")" + e4)), this._parser.registerEscHandler({ intermediates: "*", final: e4 }, () => this.selectCharset("*" + e4)), this._parser.registerEscHandler({ intermediates: "+", final: e4 }, () => this.selectCharset("+" + e4)), this._parser.registerEscHandler({ intermediates: "-", final: e4 }, () => this.selectCharset("-" + e4)), this._parser.registerEscHandler({ intermediates: ".", final: e4 }, () => this.selectCharset("." + e4)), this._parser.registerEscHandler({ intermediates: "/", final: e4 }, () => this.selectCharset("/" + e4));
          this._parser.registerEscHandler({ intermediates: "#", final: "8" }, () => this.screenAlignmentPattern()), this._parser.setErrorHandler((e4) => (this._logService.error("Parsing error: ", e4), e4)), this._parser.registerDcsHandler({ intermediates: "$", final: "q" }, new m.DcsHandler((e4, t4) => this.requestStatusString(e4, t4)));
        }
        _preserveStack(e3, t3, i3, s3) {
          this._parseStack.paused = true, this._parseStack.cursorStartX = e3, this._parseStack.cursorStartY = t3, this._parseStack.decodedLength = i3, this._parseStack.position = s3;
        }
        _logSlowResolvingAsync(e3) {
          this._logService.logLevel <= v.LogLevelEnum.WARN && Promise.race([e3, new Promise((e4, t3) => setTimeout(() => t3("#SLOW_TIMEOUT"), 5000))]).catch((e4) => {
            if (e4 !== "#SLOW_TIMEOUT")
              throw e4;
            console.warn("async parser handler taking longer than 5000 ms");
          });
        }
        _getCurrentLinkId() {
          return this._curAttrData.extended.urlId;
        }
        parse(e3, t3) {
          let i3, s3 = this._activeBuffer.x, r2 = this._activeBuffer.y, n2 = 0;
          const o2 = this._parseStack.paused;
          if (o2) {
            if (i3 = this._parser.parse(this._parseBuffer, this._parseStack.decodedLength, t3))
              return this._logSlowResolvingAsync(i3), i3;
            s3 = this._parseStack.cursorStartX, r2 = this._parseStack.cursorStartY, this._parseStack.paused = false, e3.length > b && (n2 = this._parseStack.position + b);
          }
          if (this._logService.logLevel <= v.LogLevelEnum.DEBUG && this._logService.debug("parsing data" + (typeof e3 == "string" ? ` "${e3}"` : ` "${Array.prototype.map.call(e3, (e4) => String.fromCharCode(e4)).join("")}"`), typeof e3 == "string" ? e3.split("").map((e4) => e4.charCodeAt(0)) : e3), this._parseBuffer.length < e3.length && this._parseBuffer.length < b && (this._parseBuffer = new Uint32Array(Math.min(e3.length, b))), o2 || this._dirtyRowTracker.clearRange(), e3.length > b)
            for (let t4 = n2;t4 < e3.length; t4 += b) {
              const n3 = t4 + b < e3.length ? t4 + b : e3.length, o3 = typeof e3 == "string" ? this._stringDecoder.decode(e3.substring(t4, n3), this._parseBuffer) : this._utf8Decoder.decode(e3.subarray(t4, n3), this._parseBuffer);
              if (i3 = this._parser.parse(this._parseBuffer, o3))
                return this._preserveStack(s3, r2, o3, t4), this._logSlowResolvingAsync(i3), i3;
            }
          else if (!o2) {
            const t4 = typeof e3 == "string" ? this._stringDecoder.decode(e3, this._parseBuffer) : this._utf8Decoder.decode(e3, this._parseBuffer);
            if (i3 = this._parser.parse(this._parseBuffer, t4))
              return this._preserveStack(s3, r2, t4, 0), this._logSlowResolvingAsync(i3), i3;
          }
          this._activeBuffer.x === s3 && this._activeBuffer.y === r2 || this._onCursorMove.fire();
          const a2 = this._dirtyRowTracker.end + (this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp), h2 = this._dirtyRowTracker.start + (this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp);
          h2 < this._bufferService.rows && this._onRequestRefreshRows.fire(Math.min(h2, this._bufferService.rows - 1), Math.min(a2, this._bufferService.rows - 1));
        }
        print(e3, t3, i3) {
          let s3, r2;
          const n2 = this._charsetService.charset, o2 = this._optionsService.rawOptions.screenReaderMode, a2 = this._bufferService.cols, h2 = this._coreService.decPrivateModes.wraparound, d2 = this._coreService.modes.insertMode, u2 = this._curAttrData;
          let f2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
          this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._activeBuffer.x && i3 - t3 > 0 && f2.getWidth(this._activeBuffer.x - 1) === 2 && f2.setCellFromCodePoint(this._activeBuffer.x - 1, 0, 1, u2.fg, u2.bg, u2.extended);
          let v2 = this._parser.precedingJoinState;
          for (let p2 = t3;p2 < i3; ++p2) {
            if (s3 = e3[p2], s3 < 127 && n2) {
              const e4 = n2[String.fromCharCode(s3)];
              e4 && (s3 = e4.charCodeAt(0));
            }
            const t4 = this._unicodeService.charProperties(s3, v2);
            r2 = g.UnicodeService.extractWidth(t4);
            const i4 = g.UnicodeService.extractShouldJoin(t4), m2 = i4 ? g.UnicodeService.extractWidth(v2) : 0;
            if (v2 = t4, o2 && this._onA11yChar.fire((0, c.stringFromCodePoint)(s3)), this._getCurrentLinkId() && this._oscLinkService.addLineToLink(this._getCurrentLinkId(), this._activeBuffer.ybase + this._activeBuffer.y), this._activeBuffer.x + r2 - m2 > a2) {
              if (h2) {
                const e4 = f2;
                let t5 = this._activeBuffer.x - m2;
                for (this._activeBuffer.x = m2, this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData(), true)) : (this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = true), f2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y), m2 > 0 && f2 instanceof l.BufferLine && f2.copyCellsFrom(e4, t5, 0, m2, false);t5 < a2; )
                  e4.setCellFromCodePoint(t5++, 0, 1, u2.fg, u2.bg, u2.extended);
              } else if (this._activeBuffer.x = a2 - 1, r2 === 2)
                continue;
            }
            if (i4 && this._activeBuffer.x) {
              const e4 = f2.getWidth(this._activeBuffer.x - 1) ? 1 : 2;
              f2.addCodepointToCell(this._activeBuffer.x - e4, s3, r2);
              for (let e5 = r2 - m2;--e5 >= 0; )
                f2.setCellFromCodePoint(this._activeBuffer.x++, 0, 0, u2.fg, u2.bg, u2.extended);
            } else if (d2 && (f2.insertCells(this._activeBuffer.x, r2 - m2, this._activeBuffer.getNullCell(u2), u2), f2.getWidth(a2 - 1) === 2 && f2.setCellFromCodePoint(a2 - 1, _.NULL_CELL_CODE, _.NULL_CELL_WIDTH, u2.fg, u2.bg, u2.extended)), f2.setCellFromCodePoint(this._activeBuffer.x++, s3, r2, u2.fg, u2.bg, u2.extended), r2 > 0)
              for (;--r2; )
                f2.setCellFromCodePoint(this._activeBuffer.x++, 0, 0, u2.fg, u2.bg, u2.extended);
          }
          this._parser.precedingJoinState = v2, this._activeBuffer.x < a2 && i3 - t3 > 0 && f2.getWidth(this._activeBuffer.x) === 0 && !f2.hasContent(this._activeBuffer.x) && f2.setCellFromCodePoint(this._activeBuffer.x, 0, 1, u2.fg, u2.bg, u2.extended), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
        }
        registerCsiHandler(e3, t3) {
          return e3.final !== "t" || e3.prefix || e3.intermediates ? this._parser.registerCsiHandler(e3, t3) : this._parser.registerCsiHandler(e3, (e4) => !y(e4.params[0], this._optionsService.rawOptions.windowOptions) || t3(e4));
        }
        registerDcsHandler(e3, t3) {
          return this._parser.registerDcsHandler(e3, new m.DcsHandler(t3));
        }
        registerEscHandler(e3, t3) {
          return this._parser.registerEscHandler(e3, t3);
        }
        registerOscHandler(e3, t3) {
          return this._parser.registerOscHandler(e3, new p.OscHandler(t3));
        }
        bell() {
          return this._onRequestBell.fire(), true;
        }
        lineFeed() {
          return this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._optionsService.rawOptions.convertEol && (this._activeBuffer.x = 0), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows ? this._activeBuffer.y = this._bufferService.rows - 1 : this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = false, this._activeBuffer.x >= this._bufferService.cols && this._activeBuffer.x--, this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._onLineFeed.fire(), true;
        }
        carriageReturn() {
          return this._activeBuffer.x = 0, true;
        }
        backspace() {
          if (!this._coreService.decPrivateModes.reverseWraparound)
            return this._restrictCursor(), this._activeBuffer.x > 0 && this._activeBuffer.x--, true;
          if (this._restrictCursor(this._bufferService.cols), this._activeBuffer.x > 0)
            this._activeBuffer.x--;
          else if (this._activeBuffer.x === 0 && this._activeBuffer.y > this._activeBuffer.scrollTop && this._activeBuffer.y <= this._activeBuffer.scrollBottom && this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y)?.isWrapped) {
            this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = false, this._activeBuffer.y--, this._activeBuffer.x = this._bufferService.cols - 1;
            const e3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            e3.hasWidth(this._activeBuffer.x) && !e3.hasContent(this._activeBuffer.x) && this._activeBuffer.x--;
          }
          return this._restrictCursor(), true;
        }
        tab() {
          if (this._activeBuffer.x >= this._bufferService.cols)
            return true;
          const e3 = this._activeBuffer.x;
          return this._activeBuffer.x = this._activeBuffer.nextStop(), this._optionsService.rawOptions.screenReaderMode && this._onA11yTab.fire(this._activeBuffer.x - e3), true;
        }
        shiftOut() {
          return this._charsetService.setgLevel(1), true;
        }
        shiftIn() {
          return this._charsetService.setgLevel(0), true;
        }
        _restrictCursor(e3 = this._bufferService.cols - 1) {
          this._activeBuffer.x = Math.min(e3, Math.max(0, this._activeBuffer.x)), this._activeBuffer.y = this._coreService.decPrivateModes.origin ? Math.min(this._activeBuffer.scrollBottom, Math.max(this._activeBuffer.scrollTop, this._activeBuffer.y)) : Math.min(this._bufferService.rows - 1, Math.max(0, this._activeBuffer.y)), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
        }
        _setCursor(e3, t3) {
          this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._coreService.decPrivateModes.origin ? (this._activeBuffer.x = e3, this._activeBuffer.y = this._activeBuffer.scrollTop + t3) : (this._activeBuffer.x = e3, this._activeBuffer.y = t3), this._restrictCursor(), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
        }
        _moveCursor(e3, t3) {
          this._restrictCursor(), this._setCursor(this._activeBuffer.x + e3, this._activeBuffer.y + t3);
        }
        cursorUp(e3) {
          const t3 = this._activeBuffer.y - this._activeBuffer.scrollTop;
          return t3 >= 0 ? this._moveCursor(0, -Math.min(t3, e3.params[0] || 1)) : this._moveCursor(0, -(e3.params[0] || 1)), true;
        }
        cursorDown(e3) {
          const t3 = this._activeBuffer.scrollBottom - this._activeBuffer.y;
          return t3 >= 0 ? this._moveCursor(0, Math.min(t3, e3.params[0] || 1)) : this._moveCursor(0, e3.params[0] || 1), true;
        }
        cursorForward(e3) {
          return this._moveCursor(e3.params[0] || 1, 0), true;
        }
        cursorBackward(e3) {
          return this._moveCursor(-(e3.params[0] || 1), 0), true;
        }
        cursorNextLine(e3) {
          return this.cursorDown(e3), this._activeBuffer.x = 0, true;
        }
        cursorPrecedingLine(e3) {
          return this.cursorUp(e3), this._activeBuffer.x = 0, true;
        }
        cursorCharAbsolute(e3) {
          return this._setCursor((e3.params[0] || 1) - 1, this._activeBuffer.y), true;
        }
        cursorPosition(e3) {
          return this._setCursor(e3.length >= 2 ? (e3.params[1] || 1) - 1 : 0, (e3.params[0] || 1) - 1), true;
        }
        charPosAbsolute(e3) {
          return this._setCursor((e3.params[0] || 1) - 1, this._activeBuffer.y), true;
        }
        hPositionRelative(e3) {
          return this._moveCursor(e3.params[0] || 1, 0), true;
        }
        linePosAbsolute(e3) {
          return this._setCursor(this._activeBuffer.x, (e3.params[0] || 1) - 1), true;
        }
        vPositionRelative(e3) {
          return this._moveCursor(0, e3.params[0] || 1), true;
        }
        hVPosition(e3) {
          return this.cursorPosition(e3), true;
        }
        tabClear(e3) {
          const t3 = e3.params[0];
          return t3 === 0 ? delete this._activeBuffer.tabs[this._activeBuffer.x] : t3 === 3 && (this._activeBuffer.tabs = {}), true;
        }
        cursorForwardTab(e3) {
          if (this._activeBuffer.x >= this._bufferService.cols)
            return true;
          let t3 = e3.params[0] || 1;
          for (;t3--; )
            this._activeBuffer.x = this._activeBuffer.nextStop();
          return true;
        }
        cursorBackwardTab(e3) {
          if (this._activeBuffer.x >= this._bufferService.cols)
            return true;
          let t3 = e3.params[0] || 1;
          for (;t3--; )
            this._activeBuffer.x = this._activeBuffer.prevStop();
          return true;
        }
        selectProtected(e3) {
          const t3 = e3.params[0];
          return t3 === 1 && (this._curAttrData.bg |= 536870912), t3 !== 2 && t3 !== 0 || (this._curAttrData.bg &= -536870913), true;
        }
        _eraseInBufferLine(e3, t3, i3, s3 = false, r2 = false) {
          const n2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e3);
          n2.replaceCells(t3, i3, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData(), r2), s3 && (n2.isWrapped = false);
        }
        _resetBufferLine(e3, t3 = false) {
          const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e3);
          i3 && (i3.fill(this._activeBuffer.getNullCell(this._eraseAttrData()), t3), this._bufferService.buffer.clearMarkers(this._activeBuffer.ybase + e3), i3.isWrapped = false);
        }
        eraseInDisplay(e3, t3 = false) {
          let i3;
          switch (this._restrictCursor(this._bufferService.cols), e3.params[0]) {
            case 0:
              for (i3 = this._activeBuffer.y, this._dirtyRowTracker.markDirty(i3), this._eraseInBufferLine(i3++, this._activeBuffer.x, this._bufferService.cols, this._activeBuffer.x === 0, t3);i3 < this._bufferService.rows; i3++)
                this._resetBufferLine(i3, t3);
              this._dirtyRowTracker.markDirty(i3);
              break;
            case 1:
              for (i3 = this._activeBuffer.y, this._dirtyRowTracker.markDirty(i3), this._eraseInBufferLine(i3, 0, this._activeBuffer.x + 1, true, t3), this._activeBuffer.x + 1 >= this._bufferService.cols && (this._activeBuffer.lines.get(i3 + 1).isWrapped = false);i3--; )
                this._resetBufferLine(i3, t3);
              this._dirtyRowTracker.markDirty(0);
              break;
            case 2:
              for (i3 = this._bufferService.rows, this._dirtyRowTracker.markDirty(i3 - 1);i3--; )
                this._resetBufferLine(i3, t3);
              this._dirtyRowTracker.markDirty(0);
              break;
            case 3:
              const e4 = this._activeBuffer.lines.length - this._bufferService.rows;
              e4 > 0 && (this._activeBuffer.lines.trimStart(e4), this._activeBuffer.ybase = Math.max(this._activeBuffer.ybase - e4, 0), this._activeBuffer.ydisp = Math.max(this._activeBuffer.ydisp - e4, 0), this._onScroll.fire(0));
          }
          return true;
        }
        eraseInLine(e3, t3 = false) {
          switch (this._restrictCursor(this._bufferService.cols), e3.params[0]) {
            case 0:
              this._eraseInBufferLine(this._activeBuffer.y, this._activeBuffer.x, this._bufferService.cols, this._activeBuffer.x === 0, t3);
              break;
            case 1:
              this._eraseInBufferLine(this._activeBuffer.y, 0, this._activeBuffer.x + 1, false, t3);
              break;
            case 2:
              this._eraseInBufferLine(this._activeBuffer.y, 0, this._bufferService.cols, true, t3);
          }
          return this._dirtyRowTracker.markDirty(this._activeBuffer.y), true;
        }
        insertLines(e3) {
          this._restrictCursor();
          let t3 = e3.params[0] || 1;
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
            return true;
          const i3 = this._activeBuffer.ybase + this._activeBuffer.y, s3 = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, r2 = this._bufferService.rows - 1 + this._activeBuffer.ybase - s3 + 1;
          for (;t3--; )
            this._activeBuffer.lines.splice(r2 - 1, 1), this._activeBuffer.lines.splice(i3, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, true;
        }
        deleteLines(e3) {
          this._restrictCursor();
          let t3 = e3.params[0] || 1;
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
            return true;
          const i3 = this._activeBuffer.ybase + this._activeBuffer.y;
          let s3;
          for (s3 = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, s3 = this._bufferService.rows - 1 + this._activeBuffer.ybase - s3;t3--; )
            this._activeBuffer.lines.splice(i3, 1), this._activeBuffer.lines.splice(s3, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, true;
        }
        insertChars(e3) {
          this._restrictCursor();
          const t3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
          return t3 && (t3.insertCells(this._activeBuffer.x, e3.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), true;
        }
        deleteChars(e3) {
          this._restrictCursor();
          const t3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
          return t3 && (t3.deleteCells(this._activeBuffer.x, e3.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), true;
        }
        scrollUp(e3) {
          let t3 = e3.params[0] || 1;
          for (;t3--; )
            this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
        }
        scrollDown(e3) {
          let t3 = e3.params[0] || 1;
          for (;t3--; )
            this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 0, this._activeBuffer.getBlankLine(l.DEFAULT_ATTR_DATA));
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
        }
        scrollLeft(e3) {
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
            return true;
          const t3 = e3.params[0] || 1;
          for (let e4 = this._activeBuffer.scrollTop;e4 <= this._activeBuffer.scrollBottom; ++e4) {
            const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
            i3.deleteCells(0, t3, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), i3.isWrapped = false;
          }
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
        }
        scrollRight(e3) {
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
            return true;
          const t3 = e3.params[0] || 1;
          for (let e4 = this._activeBuffer.scrollTop;e4 <= this._activeBuffer.scrollBottom; ++e4) {
            const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
            i3.insertCells(0, t3, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), i3.isWrapped = false;
          }
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
        }
        insertColumns(e3) {
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
            return true;
          const t3 = e3.params[0] || 1;
          for (let e4 = this._activeBuffer.scrollTop;e4 <= this._activeBuffer.scrollBottom; ++e4) {
            const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
            i3.insertCells(this._activeBuffer.x, t3, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), i3.isWrapped = false;
          }
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
        }
        deleteColumns(e3) {
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
            return true;
          const t3 = e3.params[0] || 1;
          for (let e4 = this._activeBuffer.scrollTop;e4 <= this._activeBuffer.scrollBottom; ++e4) {
            const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
            i3.deleteCells(this._activeBuffer.x, t3, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), i3.isWrapped = false;
          }
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
        }
        eraseChars(e3) {
          this._restrictCursor();
          const t3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
          return t3 && (t3.replaceCells(this._activeBuffer.x, this._activeBuffer.x + (e3.params[0] || 1), this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), true;
        }
        repeatPrecedingCharacter(e3) {
          const t3 = this._parser.precedingJoinState;
          if (!t3)
            return true;
          const i3 = e3.params[0] || 1, s3 = g.UnicodeService.extractWidth(t3), r2 = this._activeBuffer.x - s3, n2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).getString(r2), o2 = new Uint32Array(n2.length * i3);
          let a2 = 0;
          for (let e4 = 0;e4 < n2.length; ) {
            const t4 = n2.codePointAt(e4) || 0;
            o2[a2++] = t4, e4 += t4 > 65535 ? 2 : 1;
          }
          let h2 = a2;
          for (let e4 = 1;e4 < i3; ++e4)
            o2.copyWithin(h2, 0, a2), h2 += a2;
          return this.print(o2, 0, h2), true;
        }
        sendDeviceAttributesPrimary(e3) {
          return e3.params[0] > 0 || (this._is("xterm") || this._is("rxvt-unicode") || this._is("screen") ? this._coreService.triggerDataEvent(n.C0.ESC + "[?1;2c") : this._is("linux") && this._coreService.triggerDataEvent(n.C0.ESC + "[?6c")), true;
        }
        sendDeviceAttributesSecondary(e3) {
          return e3.params[0] > 0 || (this._is("xterm") ? this._coreService.triggerDataEvent(n.C0.ESC + "[>0;276;0c") : this._is("rxvt-unicode") ? this._coreService.triggerDataEvent(n.C0.ESC + "[>85;95;0c") : this._is("linux") ? this._coreService.triggerDataEvent(e3.params[0] + "c") : this._is("screen") && this._coreService.triggerDataEvent(n.C0.ESC + "[>83;40003;0c")), true;
        }
        _is(e3) {
          return (this._optionsService.rawOptions.termName + "").indexOf(e3) === 0;
        }
        setMode(e3) {
          for (let t3 = 0;t3 < e3.length; t3++)
            switch (e3.params[t3]) {
              case 4:
                this._coreService.modes.insertMode = true;
                break;
              case 20:
                this._optionsService.options.convertEol = true;
            }
          return true;
        }
        setModePrivate(e3) {
          for (let t3 = 0;t3 < e3.length; t3++)
            switch (e3.params[t3]) {
              case 1:
                this._coreService.decPrivateModes.applicationCursorKeys = true;
                break;
              case 2:
                this._charsetService.setgCharset(0, o.DEFAULT_CHARSET), this._charsetService.setgCharset(1, o.DEFAULT_CHARSET), this._charsetService.setgCharset(2, o.DEFAULT_CHARSET), this._charsetService.setgCharset(3, o.DEFAULT_CHARSET);
                break;
              case 3:
                this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(132, this._bufferService.rows), this._onRequestReset.fire());
                break;
              case 6:
                this._coreService.decPrivateModes.origin = true, this._setCursor(0, 0);
                break;
              case 7:
                this._coreService.decPrivateModes.wraparound = true;
                break;
              case 12:
                this._optionsService.options.cursorBlink = true;
                break;
              case 45:
                this._coreService.decPrivateModes.reverseWraparound = true;
                break;
              case 66:
                this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = true, this._onRequestSyncScrollBar.fire();
                break;
              case 9:
                this._coreMouseService.activeProtocol = "X10";
                break;
              case 1000:
                this._coreMouseService.activeProtocol = "VT200";
                break;
              case 1002:
                this._coreMouseService.activeProtocol = "DRAG";
                break;
              case 1003:
                this._coreMouseService.activeProtocol = "ANY";
                break;
              case 1004:
                this._coreService.decPrivateModes.sendFocus = true, this._onRequestSendFocus.fire();
                break;
              case 1005:
                this._logService.debug("DECSET 1005 not supported (see #2507)");
                break;
              case 1006:
                this._coreMouseService.activeEncoding = "SGR";
                break;
              case 1015:
                this._logService.debug("DECSET 1015 not supported (see #2507)");
                break;
              case 1016:
                this._coreMouseService.activeEncoding = "SGR_PIXELS";
                break;
              case 25:
                this._coreService.isCursorHidden = false;
                break;
              case 1048:
                this.saveCursor();
                break;
              case 1049:
                this.saveCursor();
              case 47:
              case 1047:
                this._bufferService.buffers.activateAltBuffer(this._eraseAttrData()), this._coreService.isCursorInitialized = true, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
                break;
              case 2004:
                this._coreService.decPrivateModes.bracketedPasteMode = true;
            }
          return true;
        }
        resetMode(e3) {
          for (let t3 = 0;t3 < e3.length; t3++)
            switch (e3.params[t3]) {
              case 4:
                this._coreService.modes.insertMode = false;
                break;
              case 20:
                this._optionsService.options.convertEol = false;
            }
          return true;
        }
        resetModePrivate(e3) {
          for (let t3 = 0;t3 < e3.length; t3++)
            switch (e3.params[t3]) {
              case 1:
                this._coreService.decPrivateModes.applicationCursorKeys = false;
                break;
              case 3:
                this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(80, this._bufferService.rows), this._onRequestReset.fire());
                break;
              case 6:
                this._coreService.decPrivateModes.origin = false, this._setCursor(0, 0);
                break;
              case 7:
                this._coreService.decPrivateModes.wraparound = false;
                break;
              case 12:
                this._optionsService.options.cursorBlink = false;
                break;
              case 45:
                this._coreService.decPrivateModes.reverseWraparound = false;
                break;
              case 66:
                this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = false, this._onRequestSyncScrollBar.fire();
                break;
              case 9:
              case 1000:
              case 1002:
              case 1003:
                this._coreMouseService.activeProtocol = "NONE";
                break;
              case 1004:
                this._coreService.decPrivateModes.sendFocus = false;
                break;
              case 1005:
                this._logService.debug("DECRST 1005 not supported (see #2507)");
                break;
              case 1006:
              case 1016:
                this._coreMouseService.activeEncoding = "DEFAULT";
                break;
              case 1015:
                this._logService.debug("DECRST 1015 not supported (see #2507)");
                break;
              case 25:
                this._coreService.isCursorHidden = true;
                break;
              case 1048:
                this.restoreCursor();
                break;
              case 1049:
              case 47:
              case 1047:
                this._bufferService.buffers.activateNormalBuffer(), e3.params[t3] === 1049 && this.restoreCursor(), this._coreService.isCursorInitialized = true, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
                break;
              case 2004:
                this._coreService.decPrivateModes.bracketedPasteMode = false;
            }
          return true;
        }
        requestMode(e3, t3) {
          const i3 = this._coreService.decPrivateModes, { activeProtocol: s3, activeEncoding: r2 } = this._coreMouseService, o2 = this._coreService, { buffers: a2, cols: h2 } = this._bufferService, { active: c2, alt: l2 } = a2, d2 = this._optionsService.rawOptions, _2 = (e4) => e4 ? 1 : 2, u2 = e3.params[0];
          return f2 = u2, v2 = t3 ? u2 === 2 ? 4 : u2 === 4 ? _2(o2.modes.insertMode) : u2 === 12 ? 3 : u2 === 20 ? _2(d2.convertEol) : 0 : u2 === 1 ? _2(i3.applicationCursorKeys) : u2 === 3 ? d2.windowOptions.setWinLines ? h2 === 80 ? 2 : h2 === 132 ? 1 : 0 : 0 : u2 === 6 ? _2(i3.origin) : u2 === 7 ? _2(i3.wraparound) : u2 === 8 ? 3 : u2 === 9 ? _2(s3 === "X10") : u2 === 12 ? _2(d2.cursorBlink) : u2 === 25 ? _2(!o2.isCursorHidden) : u2 === 45 ? _2(i3.reverseWraparound) : u2 === 66 ? _2(i3.applicationKeypad) : u2 === 67 ? 4 : u2 === 1000 ? _2(s3 === "VT200") : u2 === 1002 ? _2(s3 === "DRAG") : u2 === 1003 ? _2(s3 === "ANY") : u2 === 1004 ? _2(i3.sendFocus) : u2 === 1005 ? 4 : u2 === 1006 ? _2(r2 === "SGR") : u2 === 1015 ? 4 : u2 === 1016 ? _2(r2 === "SGR_PIXELS") : u2 === 1048 ? 1 : u2 === 47 || u2 === 1047 || u2 === 1049 ? _2(c2 === l2) : u2 === 2004 ? _2(i3.bracketedPasteMode) : 0, o2.triggerDataEvent(`${n.C0.ESC}[${t3 ? "" : "?"}${f2};${v2}\$y`), true;
          var f2, v2;
        }
        _updateAttrColor(e3, t3, i3, s3, r2) {
          return t3 === 2 ? (e3 |= 50331648, e3 &= -16777216, e3 |= f.AttributeData.fromColorRGB([i3, s3, r2])) : t3 === 5 && (e3 &= -50331904, e3 |= 33554432 | 255 & i3), e3;
        }
        _extractColor(e3, t3, i3) {
          const s3 = [0, 0, -1, 0, 0, 0];
          let r2 = 0, n2 = 0;
          do {
            if (s3[n2 + r2] = e3.params[t3 + n2], e3.hasSubParams(t3 + n2)) {
              const i4 = e3.getSubParams(t3 + n2);
              let o2 = 0;
              do {
                s3[1] === 5 && (r2 = 1), s3[n2 + o2 + 1 + r2] = i4[o2];
              } while (++o2 < i4.length && o2 + n2 + 1 + r2 < s3.length);
              break;
            }
            if (s3[1] === 5 && n2 + r2 >= 2 || s3[1] === 2 && n2 + r2 >= 5)
              break;
            s3[1] && (r2 = 1);
          } while (++n2 + t3 < e3.length && n2 + r2 < s3.length);
          for (let e4 = 2;e4 < s3.length; ++e4)
            s3[e4] === -1 && (s3[e4] = 0);
          switch (s3[0]) {
            case 38:
              i3.fg = this._updateAttrColor(i3.fg, s3[1], s3[3], s3[4], s3[5]);
              break;
            case 48:
              i3.bg = this._updateAttrColor(i3.bg, s3[1], s3[3], s3[4], s3[5]);
              break;
            case 58:
              i3.extended = i3.extended.clone(), i3.extended.underlineColor = this._updateAttrColor(i3.extended.underlineColor, s3[1], s3[3], s3[4], s3[5]);
          }
          return n2;
        }
        _processUnderline(e3, t3) {
          t3.extended = t3.extended.clone(), (!~e3 || e3 > 5) && (e3 = 1), t3.extended.underlineStyle = e3, t3.fg |= 268435456, e3 === 0 && (t3.fg &= -268435457), t3.updateExtended();
        }
        _processSGR0(e3) {
          e3.fg = l.DEFAULT_ATTR_DATA.fg, e3.bg = l.DEFAULT_ATTR_DATA.bg, e3.extended = e3.extended.clone(), e3.extended.underlineStyle = 0, e3.extended.underlineColor &= -67108864, e3.updateExtended();
        }
        charAttributes(e3) {
          if (e3.length === 1 && e3.params[0] === 0)
            return this._processSGR0(this._curAttrData), true;
          const t3 = e3.length;
          let i3;
          const s3 = this._curAttrData;
          for (let r2 = 0;r2 < t3; r2++)
            i3 = e3.params[r2], i3 >= 30 && i3 <= 37 ? (s3.fg &= -50331904, s3.fg |= 16777216 | i3 - 30) : i3 >= 40 && i3 <= 47 ? (s3.bg &= -50331904, s3.bg |= 16777216 | i3 - 40) : i3 >= 90 && i3 <= 97 ? (s3.fg &= -50331904, s3.fg |= 16777224 | i3 - 90) : i3 >= 100 && i3 <= 107 ? (s3.bg &= -50331904, s3.bg |= 16777224 | i3 - 100) : i3 === 0 ? this._processSGR0(s3) : i3 === 1 ? s3.fg |= 134217728 : i3 === 3 ? s3.bg |= 67108864 : i3 === 4 ? (s3.fg |= 268435456, this._processUnderline(e3.hasSubParams(r2) ? e3.getSubParams(r2)[0] : 1, s3)) : i3 === 5 ? s3.fg |= 536870912 : i3 === 7 ? s3.fg |= 67108864 : i3 === 8 ? s3.fg |= 1073741824 : i3 === 9 ? s3.fg |= 2147483648 : i3 === 2 ? s3.bg |= 134217728 : i3 === 21 ? this._processUnderline(2, s3) : i3 === 22 ? (s3.fg &= -134217729, s3.bg &= -134217729) : i3 === 23 ? s3.bg &= -67108865 : i3 === 24 ? (s3.fg &= -268435457, this._processUnderline(0, s3)) : i3 === 25 ? s3.fg &= -536870913 : i3 === 27 ? s3.fg &= -67108865 : i3 === 28 ? s3.fg &= -1073741825 : i3 === 29 ? s3.fg &= 2147483647 : i3 === 39 ? (s3.fg &= -67108864, s3.fg |= 16777215 & l.DEFAULT_ATTR_DATA.fg) : i3 === 49 ? (s3.bg &= -67108864, s3.bg |= 16777215 & l.DEFAULT_ATTR_DATA.bg) : i3 === 38 || i3 === 48 || i3 === 58 ? r2 += this._extractColor(e3, r2, s3) : i3 === 53 ? s3.bg |= 1073741824 : i3 === 55 ? s3.bg &= -1073741825 : i3 === 59 ? (s3.extended = s3.extended.clone(), s3.extended.underlineColor = -1, s3.updateExtended()) : i3 === 100 ? (s3.fg &= -67108864, s3.fg |= 16777215 & l.DEFAULT_ATTR_DATA.fg, s3.bg &= -67108864, s3.bg |= 16777215 & l.DEFAULT_ATTR_DATA.bg) : this._logService.debug("Unknown SGR attribute: %d.", i3);
          return true;
        }
        deviceStatus(e3) {
          switch (e3.params[0]) {
            case 5:
              this._coreService.triggerDataEvent(`${n.C0.ESC}[0n`);
              break;
            case 6:
              const e4 = this._activeBuffer.y + 1, t3 = this._activeBuffer.x + 1;
              this._coreService.triggerDataEvent(`${n.C0.ESC}[${e4};${t3}R`);
          }
          return true;
        }
        deviceStatusPrivate(e3) {
          if (e3.params[0] === 6) {
            const e4 = this._activeBuffer.y + 1, t3 = this._activeBuffer.x + 1;
            this._coreService.triggerDataEvent(`${n.C0.ESC}[?${e4};${t3}R`);
          }
          return true;
        }
        softReset(e3) {
          return this._coreService.isCursorHidden = false, this._onRequestSyncScrollBar.fire(), this._activeBuffer.scrollTop = 0, this._activeBuffer.scrollBottom = this._bufferService.rows - 1, this._curAttrData = l.DEFAULT_ATTR_DATA.clone(), this._coreService.reset(), this._charsetService.reset(), this._activeBuffer.savedX = 0, this._activeBuffer.savedY = this._activeBuffer.ybase, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, this._coreService.decPrivateModes.origin = false, true;
        }
        setCursorStyle(e3) {
          const t3 = e3.params[0] || 1;
          switch (t3) {
            case 1:
            case 2:
              this._optionsService.options.cursorStyle = "block";
              break;
            case 3:
            case 4:
              this._optionsService.options.cursorStyle = "underline";
              break;
            case 5:
            case 6:
              this._optionsService.options.cursorStyle = "bar";
          }
          const i3 = t3 % 2 == 1;
          return this._optionsService.options.cursorBlink = i3, true;
        }
        setScrollRegion(e3) {
          const t3 = e3.params[0] || 1;
          let i3;
          return (e3.length < 2 || (i3 = e3.params[1]) > this._bufferService.rows || i3 === 0) && (i3 = this._bufferService.rows), i3 > t3 && (this._activeBuffer.scrollTop = t3 - 1, this._activeBuffer.scrollBottom = i3 - 1, this._setCursor(0, 0)), true;
        }
        windowOptions(e3) {
          if (!y(e3.params[0], this._optionsService.rawOptions.windowOptions))
            return true;
          const t3 = e3.length > 1 ? e3.params[1] : 0;
          switch (e3.params[0]) {
            case 14:
              t3 !== 2 && this._onRequestWindowsOptionsReport.fire(w.GET_WIN_SIZE_PIXELS);
              break;
            case 16:
              this._onRequestWindowsOptionsReport.fire(w.GET_CELL_SIZE_PIXELS);
              break;
            case 18:
              this._bufferService && this._coreService.triggerDataEvent(`${n.C0.ESC}[8;${this._bufferService.rows};${this._bufferService.cols}t`);
              break;
            case 22:
              t3 !== 0 && t3 !== 2 || (this._windowTitleStack.push(this._windowTitle), this._windowTitleStack.length > 10 && this._windowTitleStack.shift()), t3 !== 0 && t3 !== 1 || (this._iconNameStack.push(this._iconName), this._iconNameStack.length > 10 && this._iconNameStack.shift());
              break;
            case 23:
              t3 !== 0 && t3 !== 2 || this._windowTitleStack.length && this.setTitle(this._windowTitleStack.pop()), t3 !== 0 && t3 !== 1 || this._iconNameStack.length && this.setIconName(this._iconNameStack.pop());
          }
          return true;
        }
        saveCursor(e3) {
          return this._activeBuffer.savedX = this._activeBuffer.x, this._activeBuffer.savedY = this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, true;
        }
        restoreCursor(e3) {
          return this._activeBuffer.x = this._activeBuffer.savedX || 0, this._activeBuffer.y = Math.max(this._activeBuffer.savedY - this._activeBuffer.ybase, 0), this._curAttrData.fg = this._activeBuffer.savedCurAttrData.fg, this._curAttrData.bg = this._activeBuffer.savedCurAttrData.bg, this._charsetService.charset = this._savedCharset, this._activeBuffer.savedCharset && (this._charsetService.charset = this._activeBuffer.savedCharset), this._restrictCursor(), true;
        }
        setTitle(e3) {
          return this._windowTitle = e3, this._onTitleChange.fire(e3), true;
        }
        setIconName(e3) {
          return this._iconName = e3, true;
        }
        setOrReportIndexedColor(e3) {
          const t3 = [], i3 = e3.split(";");
          for (;i3.length > 1; ) {
            const e4 = i3.shift(), s3 = i3.shift();
            if (/^\d+$/.exec(e4)) {
              const i4 = parseInt(e4);
              if (D(i4))
                if (s3 === "?")
                  t3.push({ type: 0, index: i4 });
                else {
                  const e5 = (0, S.parseColor)(s3);
                  e5 && t3.push({ type: 1, index: i4, color: e5 });
                }
            }
          }
          return t3.length && this._onColor.fire(t3), true;
        }
        setHyperlink(e3) {
          const t3 = e3.split(";");
          return !(t3.length < 2) && (t3[1] ? this._createHyperlink(t3[0], t3[1]) : !t3[0] && this._finishHyperlink());
        }
        _createHyperlink(e3, t3) {
          this._getCurrentLinkId() && this._finishHyperlink();
          const i3 = e3.split(":");
          let s3;
          const r2 = i3.findIndex((e4) => e4.startsWith("id="));
          return r2 !== -1 && (s3 = i3[r2].slice(3) || undefined), this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = this._oscLinkService.registerLink({ id: s3, uri: t3 }), this._curAttrData.updateExtended(), true;
        }
        _finishHyperlink() {
          return this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = 0, this._curAttrData.updateExtended(), true;
        }
        _setOrReportSpecialColor(e3, t3) {
          const i3 = e3.split(";");
          for (let e4 = 0;e4 < i3.length && !(t3 >= this._specialColors.length); ++e4, ++t3)
            if (i3[e4] === "?")
              this._onColor.fire([{ type: 0, index: this._specialColors[t3] }]);
            else {
              const s3 = (0, S.parseColor)(i3[e4]);
              s3 && this._onColor.fire([{ type: 1, index: this._specialColors[t3], color: s3 }]);
            }
          return true;
        }
        setOrReportFgColor(e3) {
          return this._setOrReportSpecialColor(e3, 0);
        }
        setOrReportBgColor(e3) {
          return this._setOrReportSpecialColor(e3, 1);
        }
        setOrReportCursorColor(e3) {
          return this._setOrReportSpecialColor(e3, 2);
        }
        restoreIndexedColor(e3) {
          if (!e3)
            return this._onColor.fire([{ type: 2 }]), true;
          const t3 = [], i3 = e3.split(";");
          for (let e4 = 0;e4 < i3.length; ++e4)
            if (/^\d+$/.exec(i3[e4])) {
              const s3 = parseInt(i3[e4]);
              D(s3) && t3.push({ type: 2, index: s3 });
            }
          return t3.length && this._onColor.fire(t3), true;
        }
        restoreFgColor(e3) {
          return this._onColor.fire([{ type: 2, index: 256 }]), true;
        }
        restoreBgColor(e3) {
          return this._onColor.fire([{ type: 2, index: 257 }]), true;
        }
        restoreCursorColor(e3) {
          return this._onColor.fire([{ type: 2, index: 258 }]), true;
        }
        nextLine() {
          return this._activeBuffer.x = 0, this.index(), true;
        }
        keypadApplicationMode() {
          return this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = true, this._onRequestSyncScrollBar.fire(), true;
        }
        keypadNumericMode() {
          return this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = false, this._onRequestSyncScrollBar.fire(), true;
        }
        selectDefaultCharset() {
          return this._charsetService.setgLevel(0), this._charsetService.setgCharset(0, o.DEFAULT_CHARSET), true;
        }
        selectCharset(e3) {
          return e3.length !== 2 ? (this.selectDefaultCharset(), true) : (e3[0] === "/" || this._charsetService.setgCharset(C[e3[0]], o.CHARSETS[e3[1]] || o.DEFAULT_CHARSET), true);
        }
        index() {
          return this._restrictCursor(), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._restrictCursor(), true;
        }
        tabSet() {
          return this._activeBuffer.tabs[this._activeBuffer.x] = true, true;
        }
        reverseIndex() {
          if (this._restrictCursor(), this._activeBuffer.y === this._activeBuffer.scrollTop) {
            const e3 = this._activeBuffer.scrollBottom - this._activeBuffer.scrollTop;
            this._activeBuffer.lines.shiftElements(this._activeBuffer.ybase + this._activeBuffer.y, e3, 1), this._activeBuffer.lines.set(this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.getBlankLine(this._eraseAttrData())), this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom);
          } else
            this._activeBuffer.y--, this._restrictCursor();
          return true;
        }
        fullReset() {
          return this._parser.reset(), this._onRequestReset.fire(), true;
        }
        reset() {
          this._curAttrData = l.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = l.DEFAULT_ATTR_DATA.clone();
        }
        _eraseAttrData() {
          return this._eraseAttrDataInternal.bg &= -67108864, this._eraseAttrDataInternal.bg |= 67108863 & this._curAttrData.bg, this._eraseAttrDataInternal;
        }
        setgLevel(e3) {
          return this._charsetService.setgLevel(e3), true;
        }
        screenAlignmentPattern() {
          const e3 = new u.CellData;
          e3.content = 1 << 22 | "E".charCodeAt(0), e3.fg = this._curAttrData.fg, e3.bg = this._curAttrData.bg, this._setCursor(0, 0);
          for (let t3 = 0;t3 < this._bufferService.rows; ++t3) {
            const i3 = this._activeBuffer.ybase + this._activeBuffer.y + t3, s3 = this._activeBuffer.lines.get(i3);
            s3 && (s3.fill(e3), s3.isWrapped = false);
          }
          return this._dirtyRowTracker.markAllDirty(), this._setCursor(0, 0), true;
        }
        requestStatusString(e3, t3) {
          const i3 = this._bufferService.buffer, s3 = this._optionsService.rawOptions;
          return ((e4) => (this._coreService.triggerDataEvent(`${n.C0.ESC}${e4}${n.C0.ESC}\\`), true))(e3 === '"q' ? `P1\$r${this._curAttrData.isProtected() ? 1 : 0}"q` : e3 === '"p' ? 'P1$r61;1"p' : e3 === "r" ? `P1\$r${i3.scrollTop + 1};${i3.scrollBottom + 1}r` : e3 === "m" ? "P1$r0m" : e3 === " q" ? `P1\$r${{ block: 2, underline: 4, bar: 6 }[s3.cursorStyle] - (s3.cursorBlink ? 1 : 0)} q` : "P0$r");
        }
        markRangeDirty(e3, t3) {
          this._dirtyRowTracker.markRangeDirty(e3, t3);
        }
      }
      t2.InputHandler = k;
      let L = class {
        constructor(e3) {
          this._bufferService = e3, this.clearRange();
        }
        clearRange() {
          this.start = this._bufferService.buffer.y, this.end = this._bufferService.buffer.y;
        }
        markDirty(e3) {
          e3 < this.start ? this.start = e3 : e3 > this.end && (this.end = e3);
        }
        markRangeDirty(e3, t3) {
          e3 > t3 && (E = e3, e3 = t3, t3 = E), e3 < this.start && (this.start = e3), t3 > this.end && (this.end = t3);
        }
        markAllDirty() {
          this.markRangeDirty(0, this._bufferService.rows - 1);
        }
      };
      function D(e3) {
        return 0 <= e3 && e3 < 256;
      }
      L = s2([r(0, v.IBufferService)], L);
    }, 844: (e2, t2) => {
      function i2(e3) {
        for (const t3 of e3)
          t3.dispose();
        e3.length = 0;
      }
      Object.defineProperty(t2, "__esModule", { value: true }), t2.getDisposeArrayDisposable = t2.disposeArray = t2.toDisposable = t2.MutableDisposable = t2.Disposable = undefined, t2.Disposable = class {
        constructor() {
          this._disposables = [], this._isDisposed = false;
        }
        dispose() {
          this._isDisposed = true;
          for (const e3 of this._disposables)
            e3.dispose();
          this._disposables.length = 0;
        }
        register(e3) {
          return this._disposables.push(e3), e3;
        }
        unregister(e3) {
          const t3 = this._disposables.indexOf(e3);
          t3 !== -1 && this._disposables.splice(t3, 1);
        }
      }, t2.MutableDisposable = class {
        constructor() {
          this._isDisposed = false;
        }
        get value() {
          return this._isDisposed ? undefined : this._value;
        }
        set value(e3) {
          this._isDisposed || e3 === this._value || (this._value?.dispose(), this._value = e3);
        }
        clear() {
          this.value = undefined;
        }
        dispose() {
          this._isDisposed = true, this._value?.dispose(), this._value = undefined;
        }
      }, t2.toDisposable = function(e3) {
        return { dispose: e3 };
      }, t2.disposeArray = i2, t2.getDisposeArrayDisposable = function(e3) {
        return { dispose: () => i2(e3) };
      };
    }, 1505: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.FourKeyMap = t2.TwoKeyMap = undefined;

      class i2 {
        constructor() {
          this._data = {};
        }
        set(e3, t3, i3) {
          this._data[e3] || (this._data[e3] = {}), this._data[e3][t3] = i3;
        }
        get(e3, t3) {
          return this._data[e3] ? this._data[e3][t3] : undefined;
        }
        clear() {
          this._data = {};
        }
      }
      t2.TwoKeyMap = i2, t2.FourKeyMap = class {
        constructor() {
          this._data = new i2;
        }
        set(e3, t3, s2, r, n) {
          this._data.get(e3, t3) || this._data.set(e3, t3, new i2), this._data.get(e3, t3).set(s2, r, n);
        }
        get(e3, t3, i3, s2) {
          return this._data.get(e3, t3)?.get(i3, s2);
        }
        clear() {
          this._data.clear();
        }
      };
    }, 6114: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.isChromeOS = t2.isLinux = t2.isWindows = t2.isIphone = t2.isIpad = t2.isMac = t2.getSafariVersion = t2.isSafari = t2.isLegacyEdge = t2.isFirefox = t2.isNode = undefined, t2.isNode = typeof process != "undefined";
      const i2 = t2.isNode ? "node" : navigator.userAgent, s2 = t2.isNode ? "node" : navigator.platform;
      t2.isFirefox = i2.includes("Firefox"), t2.isLegacyEdge = i2.includes("Edge"), t2.isSafari = /^((?!chrome|android).)*safari/i.test(i2), t2.getSafariVersion = function() {
        if (!t2.isSafari)
          return 0;
        const e3 = i2.match(/Version\/(\d+)/);
        return e3 === null || e3.length < 2 ? 0 : parseInt(e3[1]);
      }, t2.isMac = ["Macintosh", "MacIntel", "MacPPC", "Mac68K"].includes(s2), t2.isIpad = s2 === "iPad", t2.isIphone = s2 === "iPhone", t2.isWindows = ["Windows", "Win16", "Win32", "WinCE"].includes(s2), t2.isLinux = s2.indexOf("Linux") >= 0, t2.isChromeOS = /\bCrOS\b/.test(i2);
    }, 6106: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.SortedList = undefined;
      let i2 = 0;
      t2.SortedList = class {
        constructor(e3) {
          this._getKey = e3, this._array = [];
        }
        clear() {
          this._array.length = 0;
        }
        insert(e3) {
          this._array.length !== 0 ? (i2 = this._search(this._getKey(e3)), this._array.splice(i2, 0, e3)) : this._array.push(e3);
        }
        delete(e3) {
          if (this._array.length === 0)
            return false;
          const t3 = this._getKey(e3);
          if (t3 === undefined)
            return false;
          if (i2 = this._search(t3), i2 === -1)
            return false;
          if (this._getKey(this._array[i2]) !== t3)
            return false;
          do {
            if (this._array[i2] === e3)
              return this._array.splice(i2, 1), true;
          } while (++i2 < this._array.length && this._getKey(this._array[i2]) === t3);
          return false;
        }
        *getKeyIterator(e3) {
          if (this._array.length !== 0 && (i2 = this._search(e3), !(i2 < 0 || i2 >= this._array.length) && this._getKey(this._array[i2]) === e3))
            do {
              yield this._array[i2];
            } while (++i2 < this._array.length && this._getKey(this._array[i2]) === e3);
        }
        forEachByKey(e3, t3) {
          if (this._array.length !== 0 && (i2 = this._search(e3), !(i2 < 0 || i2 >= this._array.length) && this._getKey(this._array[i2]) === e3))
            do {
              t3(this._array[i2]);
            } while (++i2 < this._array.length && this._getKey(this._array[i2]) === e3);
        }
        values() {
          return [...this._array].values();
        }
        _search(e3) {
          let t3 = 0, i3 = this._array.length - 1;
          for (;i3 >= t3; ) {
            let s2 = t3 + i3 >> 1;
            const r = this._getKey(this._array[s2]);
            if (r > e3)
              i3 = s2 - 1;
            else {
              if (!(r < e3)) {
                for (;s2 > 0 && this._getKey(this._array[s2 - 1]) === e3; )
                  s2--;
                return s2;
              }
              t3 = s2 + 1;
            }
          }
          return t3;
        }
      };
    }, 7226: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.DebouncedIdleTask = t2.IdleTaskQueue = t2.PriorityTaskQueue = undefined;
      const s2 = i2(6114);

      class r {
        constructor() {
          this._tasks = [], this._i = 0;
        }
        enqueue(e3) {
          this._tasks.push(e3), this._start();
        }
        flush() {
          for (;this._i < this._tasks.length; )
            this._tasks[this._i]() || this._i++;
          this.clear();
        }
        clear() {
          this._idleCallback && (this._cancelCallback(this._idleCallback), this._idleCallback = undefined), this._i = 0, this._tasks.length = 0;
        }
        _start() {
          this._idleCallback || (this._idleCallback = this._requestCallback(this._process.bind(this)));
        }
        _process(e3) {
          this._idleCallback = undefined;
          let t3 = 0, i3 = 0, s3 = e3.timeRemaining(), r2 = 0;
          for (;this._i < this._tasks.length; ) {
            if (t3 = Date.now(), this._tasks[this._i]() || this._i++, t3 = Math.max(1, Date.now() - t3), i3 = Math.max(t3, i3), r2 = e3.timeRemaining(), 1.5 * i3 > r2)
              return s3 - t3 < -20 && console.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(s3 - t3))}ms`), void this._start();
            s3 = r2;
          }
          this.clear();
        }
      }

      class n extends r {
        _requestCallback(e3) {
          return setTimeout(() => e3(this._createDeadline(16)));
        }
        _cancelCallback(e3) {
          clearTimeout(e3);
        }
        _createDeadline(e3) {
          const t3 = Date.now() + e3;
          return { timeRemaining: () => Math.max(0, t3 - Date.now()) };
        }
      }
      t2.PriorityTaskQueue = n, t2.IdleTaskQueue = !s2.isNode && ("requestIdleCallback" in window) ? class extends r {
        _requestCallback(e3) {
          return requestIdleCallback(e3);
        }
        _cancelCallback(e3) {
          cancelIdleCallback(e3);
        }
      } : n, t2.DebouncedIdleTask = class {
        constructor() {
          this._queue = new t2.IdleTaskQueue;
        }
        set(e3) {
          this._queue.clear(), this._queue.enqueue(e3);
        }
        flush() {
          this._queue.flush();
        }
      };
    }, 9282: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.updateWindowsModeWrappedState = undefined;
      const s2 = i2(643);
      t2.updateWindowsModeWrappedState = function(e3) {
        const t3 = e3.buffer.lines.get(e3.buffer.ybase + e3.buffer.y - 1), i3 = t3?.get(e3.cols - 1), r = e3.buffer.lines.get(e3.buffer.ybase + e3.buffer.y);
        r && i3 && (r.isWrapped = i3[s2.CHAR_DATA_CODE_INDEX] !== s2.NULL_CELL_CODE && i3[s2.CHAR_DATA_CODE_INDEX] !== s2.WHITESPACE_CELL_CODE);
      };
    }, 3734: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.ExtendedAttrs = t2.AttributeData = undefined;

      class i2 {
        constructor() {
          this.fg = 0, this.bg = 0, this.extended = new s2;
        }
        static toColorRGB(e3) {
          return [e3 >>> 16 & 255, e3 >>> 8 & 255, 255 & e3];
        }
        static fromColorRGB(e3) {
          return (255 & e3[0]) << 16 | (255 & e3[1]) << 8 | 255 & e3[2];
        }
        clone() {
          const e3 = new i2;
          return e3.fg = this.fg, e3.bg = this.bg, e3.extended = this.extended.clone(), e3;
        }
        isInverse() {
          return 67108864 & this.fg;
        }
        isBold() {
          return 134217728 & this.fg;
        }
        isUnderline() {
          return this.hasExtendedAttrs() && this.extended.underlineStyle !== 0 ? 1 : 268435456 & this.fg;
        }
        isBlink() {
          return 536870912 & this.fg;
        }
        isInvisible() {
          return 1073741824 & this.fg;
        }
        isItalic() {
          return 67108864 & this.bg;
        }
        isDim() {
          return 134217728 & this.bg;
        }
        isStrikethrough() {
          return 2147483648 & this.fg;
        }
        isProtected() {
          return 536870912 & this.bg;
        }
        isOverline() {
          return 1073741824 & this.bg;
        }
        getFgColorMode() {
          return 50331648 & this.fg;
        }
        getBgColorMode() {
          return 50331648 & this.bg;
        }
        isFgRGB() {
          return (50331648 & this.fg) == 50331648;
        }
        isBgRGB() {
          return (50331648 & this.bg) == 50331648;
        }
        isFgPalette() {
          return (50331648 & this.fg) == 16777216 || (50331648 & this.fg) == 33554432;
        }
        isBgPalette() {
          return (50331648 & this.bg) == 16777216 || (50331648 & this.bg) == 33554432;
        }
        isFgDefault() {
          return (50331648 & this.fg) == 0;
        }
        isBgDefault() {
          return (50331648 & this.bg) == 0;
        }
        isAttributeDefault() {
          return this.fg === 0 && this.bg === 0;
        }
        getFgColor() {
          switch (50331648 & this.fg) {
            case 16777216:
            case 33554432:
              return 255 & this.fg;
            case 50331648:
              return 16777215 & this.fg;
            default:
              return -1;
          }
        }
        getBgColor() {
          switch (50331648 & this.bg) {
            case 16777216:
            case 33554432:
              return 255 & this.bg;
            case 50331648:
              return 16777215 & this.bg;
            default:
              return -1;
          }
        }
        hasExtendedAttrs() {
          return 268435456 & this.bg;
        }
        updateExtended() {
          this.extended.isEmpty() ? this.bg &= -268435457 : this.bg |= 268435456;
        }
        getUnderlineColor() {
          if (268435456 & this.bg && ~this.extended.underlineColor)
            switch (50331648 & this.extended.underlineColor) {
              case 16777216:
              case 33554432:
                return 255 & this.extended.underlineColor;
              case 50331648:
                return 16777215 & this.extended.underlineColor;
              default:
                return this.getFgColor();
            }
          return this.getFgColor();
        }
        getUnderlineColorMode() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 & this.extended.underlineColor : this.getFgColorMode();
        }
        isUnderlineColorRGB() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 50331648 : this.isFgRGB();
        }
        isUnderlineColorPalette() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 16777216 || (50331648 & this.extended.underlineColor) == 33554432 : this.isFgPalette();
        }
        isUnderlineColorDefault() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 0 : this.isFgDefault();
        }
        getUnderlineStyle() {
          return 268435456 & this.fg ? 268435456 & this.bg ? this.extended.underlineStyle : 1 : 0;
        }
      }
      t2.AttributeData = i2;

      class s2 {
        get ext() {
          return this._urlId ? -469762049 & this._ext | this.underlineStyle << 26 : this._ext;
        }
        set ext(e3) {
          this._ext = e3;
        }
        get underlineStyle() {
          return this._urlId ? 5 : (469762048 & this._ext) >> 26;
        }
        set underlineStyle(e3) {
          this._ext &= -469762049, this._ext |= e3 << 26 & 469762048;
        }
        get underlineColor() {
          return 67108863 & this._ext;
        }
        set underlineColor(e3) {
          this._ext &= -67108864, this._ext |= 67108863 & e3;
        }
        get urlId() {
          return this._urlId;
        }
        set urlId(e3) {
          this._urlId = e3;
        }
        constructor(e3 = 0, t3 = 0) {
          this._ext = 0, this._urlId = 0, this._ext = e3, this._urlId = t3;
        }
        clone() {
          return new s2(this._ext, this._urlId);
        }
        isEmpty() {
          return this.underlineStyle === 0 && this._urlId === 0;
        }
      }
      t2.ExtendedAttrs = s2;
    }, 9092: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.Buffer = t2.MAX_BUFFER_SIZE = undefined;
      const s2 = i2(6349), r = i2(7226), n = i2(3734), o = i2(8437), a = i2(4634), h = i2(511), c = i2(643), l = i2(4863), d = i2(7116);
      t2.MAX_BUFFER_SIZE = 4294967295, t2.Buffer = class {
        constructor(e3, t3, i3) {
          this._hasScrollback = e3, this._optionsService = t3, this._bufferService = i3, this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.tabs = {}, this.savedY = 0, this.savedX = 0, this.savedCurAttrData = o.DEFAULT_ATTR_DATA.clone(), this.savedCharset = d.DEFAULT_CHARSET, this.markers = [], this._nullCell = h.CellData.fromCharData([0, c.NULL_CELL_CHAR, c.NULL_CELL_WIDTH, c.NULL_CELL_CODE]), this._whitespaceCell = h.CellData.fromCharData([0, c.WHITESPACE_CELL_CHAR, c.WHITESPACE_CELL_WIDTH, c.WHITESPACE_CELL_CODE]), this._isClearing = false, this._memoryCleanupQueue = new r.IdleTaskQueue, this._memoryCleanupPosition = 0, this._cols = this._bufferService.cols, this._rows = this._bufferService.rows, this.lines = new s2.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
        }
        getNullCell(e3) {
          return e3 ? (this._nullCell.fg = e3.fg, this._nullCell.bg = e3.bg, this._nullCell.extended = e3.extended) : (this._nullCell.fg = 0, this._nullCell.bg = 0, this._nullCell.extended = new n.ExtendedAttrs), this._nullCell;
        }
        getWhitespaceCell(e3) {
          return e3 ? (this._whitespaceCell.fg = e3.fg, this._whitespaceCell.bg = e3.bg, this._whitespaceCell.extended = e3.extended) : (this._whitespaceCell.fg = 0, this._whitespaceCell.bg = 0, this._whitespaceCell.extended = new n.ExtendedAttrs), this._whitespaceCell;
        }
        getBlankLine(e3, t3) {
          return new o.BufferLine(this._bufferService.cols, this.getNullCell(e3), t3);
        }
        get hasScrollback() {
          return this._hasScrollback && this.lines.maxLength > this._rows;
        }
        get isCursorInViewport() {
          const e3 = this.ybase + this.y - this.ydisp;
          return e3 >= 0 && e3 < this._rows;
        }
        _getCorrectBufferLength(e3) {
          if (!this._hasScrollback)
            return e3;
          const i3 = e3 + this._optionsService.rawOptions.scrollback;
          return i3 > t2.MAX_BUFFER_SIZE ? t2.MAX_BUFFER_SIZE : i3;
        }
        fillViewportRows(e3) {
          if (this.lines.length === 0) {
            e3 === undefined && (e3 = o.DEFAULT_ATTR_DATA);
            let t3 = this._rows;
            for (;t3--; )
              this.lines.push(this.getBlankLine(e3));
          }
        }
        clear() {
          this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.lines = new s2.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
        }
        resize(e3, t3) {
          const i3 = this.getNullCell(o.DEFAULT_ATTR_DATA);
          let s3 = 0;
          const r2 = this._getCorrectBufferLength(t3);
          if (r2 > this.lines.maxLength && (this.lines.maxLength = r2), this.lines.length > 0) {
            if (this._cols < e3)
              for (let t4 = 0;t4 < this.lines.length; t4++)
                s3 += +this.lines.get(t4).resize(e3, i3);
            let n2 = 0;
            if (this._rows < t3)
              for (let s4 = this._rows;s4 < t3; s4++)
                this.lines.length < t3 + this.ybase && (this._optionsService.rawOptions.windowsMode || this._optionsService.rawOptions.windowsPty.backend !== undefined || this._optionsService.rawOptions.windowsPty.buildNumber !== undefined ? this.lines.push(new o.BufferLine(e3, i3)) : this.ybase > 0 && this.lines.length <= this.ybase + this.y + n2 + 1 ? (this.ybase--, n2++, this.ydisp > 0 && this.ydisp--) : this.lines.push(new o.BufferLine(e3, i3)));
            else
              for (let e4 = this._rows;e4 > t3; e4--)
                this.lines.length > t3 + this.ybase && (this.lines.length > this.ybase + this.y + 1 ? this.lines.pop() : (this.ybase++, this.ydisp++));
            if (r2 < this.lines.maxLength) {
              const e4 = this.lines.length - r2;
              e4 > 0 && (this.lines.trimStart(e4), this.ybase = Math.max(this.ybase - e4, 0), this.ydisp = Math.max(this.ydisp - e4, 0), this.savedY = Math.max(this.savedY - e4, 0)), this.lines.maxLength = r2;
            }
            this.x = Math.min(this.x, e3 - 1), this.y = Math.min(this.y, t3 - 1), n2 && (this.y += n2), this.savedX = Math.min(this.savedX, e3 - 1), this.scrollTop = 0;
          }
          if (this.scrollBottom = t3 - 1, this._isReflowEnabled && (this._reflow(e3, t3), this._cols > e3))
            for (let t4 = 0;t4 < this.lines.length; t4++)
              s3 += +this.lines.get(t4).resize(e3, i3);
          this._cols = e3, this._rows = t3, this._memoryCleanupQueue.clear(), s3 > 0.1 * this.lines.length && (this._memoryCleanupPosition = 0, this._memoryCleanupQueue.enqueue(() => this._batchedMemoryCleanup()));
        }
        _batchedMemoryCleanup() {
          let e3 = true;
          this._memoryCleanupPosition >= this.lines.length && (this._memoryCleanupPosition = 0, e3 = false);
          let t3 = 0;
          for (;this._memoryCleanupPosition < this.lines.length; )
            if (t3 += this.lines.get(this._memoryCleanupPosition++).cleanupMemory(), t3 > 100)
              return true;
          return e3;
        }
        get _isReflowEnabled() {
          const e3 = this._optionsService.rawOptions.windowsPty;
          return e3 && e3.buildNumber ? this._hasScrollback && e3.backend === "conpty" && e3.buildNumber >= 21376 : this._hasScrollback && !this._optionsService.rawOptions.windowsMode;
        }
        _reflow(e3, t3) {
          this._cols !== e3 && (e3 > this._cols ? this._reflowLarger(e3, t3) : this._reflowSmaller(e3, t3));
        }
        _reflowLarger(e3, t3) {
          const i3 = (0, a.reflowLargerGetLinesToRemove)(this.lines, this._cols, e3, this.ybase + this.y, this.getNullCell(o.DEFAULT_ATTR_DATA));
          if (i3.length > 0) {
            const s3 = (0, a.reflowLargerCreateNewLayout)(this.lines, i3);
            (0, a.reflowLargerApplyNewLayout)(this.lines, s3.layout), this._reflowLargerAdjustViewport(e3, t3, s3.countRemoved);
          }
        }
        _reflowLargerAdjustViewport(e3, t3, i3) {
          const s3 = this.getNullCell(o.DEFAULT_ATTR_DATA);
          let r2 = i3;
          for (;r2-- > 0; )
            this.ybase === 0 ? (this.y > 0 && this.y--, this.lines.length < t3 && this.lines.push(new o.BufferLine(e3, s3))) : (this.ydisp === this.ybase && this.ydisp--, this.ybase--);
          this.savedY = Math.max(this.savedY - i3, 0);
        }
        _reflowSmaller(e3, t3) {
          const i3 = this.getNullCell(o.DEFAULT_ATTR_DATA), s3 = [];
          let r2 = 0;
          for (let n2 = this.lines.length - 1;n2 >= 0; n2--) {
            let h2 = this.lines.get(n2);
            if (!h2 || !h2.isWrapped && h2.getTrimmedLength() <= e3)
              continue;
            const c2 = [h2];
            for (;h2.isWrapped && n2 > 0; )
              h2 = this.lines.get(--n2), c2.unshift(h2);
            const l2 = this.ybase + this.y;
            if (l2 >= n2 && l2 < n2 + c2.length)
              continue;
            const d2 = c2[c2.length - 1].getTrimmedLength(), _ = (0, a.reflowSmallerGetNewLineLengths)(c2, this._cols, e3), u = _.length - c2.length;
            let f;
            f = this.ybase === 0 && this.y !== this.lines.length - 1 ? Math.max(0, this.y - this.lines.maxLength + u) : Math.max(0, this.lines.length - this.lines.maxLength + u);
            const v = [];
            for (let e4 = 0;e4 < u; e4++) {
              const e5 = this.getBlankLine(o.DEFAULT_ATTR_DATA, true);
              v.push(e5);
            }
            v.length > 0 && (s3.push({ start: n2 + c2.length + r2, newLines: v }), r2 += v.length), c2.push(...v);
            let g = _.length - 1, p = _[g];
            p === 0 && (g--, p = _[g]);
            let m = c2.length - u - 1, S = d2;
            for (;m >= 0; ) {
              const e4 = Math.min(S, p);
              if (c2[g] === undefined)
                break;
              if (c2[g].copyCellsFrom(c2[m], S - e4, p - e4, e4, true), p -= e4, p === 0 && (g--, p = _[g]), S -= e4, S === 0) {
                m--;
                const e5 = Math.max(m, 0);
                S = (0, a.getWrappedLineTrimmedLength)(c2, e5, this._cols);
              }
            }
            for (let t4 = 0;t4 < c2.length; t4++)
              _[t4] < e3 && c2[t4].setCell(_[t4], i3);
            let C = u - f;
            for (;C-- > 0; )
              this.ybase === 0 ? this.y < t3 - 1 ? (this.y++, this.lines.pop()) : (this.ybase++, this.ydisp++) : this.ybase < Math.min(this.lines.maxLength, this.lines.length + r2) - t3 && (this.ybase === this.ydisp && this.ydisp++, this.ybase++);
            this.savedY = Math.min(this.savedY + u, this.ybase + t3 - 1);
          }
          if (s3.length > 0) {
            const e4 = [], t4 = [];
            for (let e5 = 0;e5 < this.lines.length; e5++)
              t4.push(this.lines.get(e5));
            const i4 = this.lines.length;
            let n2 = i4 - 1, o2 = 0, a2 = s3[o2];
            this.lines.length = Math.min(this.lines.maxLength, this.lines.length + r2);
            let h2 = 0;
            for (let c3 = Math.min(this.lines.maxLength - 1, i4 + r2 - 1);c3 >= 0; c3--)
              if (a2 && a2.start > n2 + h2) {
                for (let e5 = a2.newLines.length - 1;e5 >= 0; e5--)
                  this.lines.set(c3--, a2.newLines[e5]);
                c3++, e4.push({ index: n2 + 1, amount: a2.newLines.length }), h2 += a2.newLines.length, a2 = s3[++o2];
              } else
                this.lines.set(c3, t4[n2--]);
            let c2 = 0;
            for (let t5 = e4.length - 1;t5 >= 0; t5--)
              e4[t5].index += c2, this.lines.onInsertEmitter.fire(e4[t5]), c2 += e4[t5].amount;
            const l2 = Math.max(0, i4 + r2 - this.lines.maxLength);
            l2 > 0 && this.lines.onTrimEmitter.fire(l2);
          }
        }
        translateBufferLineToString(e3, t3, i3 = 0, s3) {
          const r2 = this.lines.get(e3);
          return r2 ? r2.translateToString(t3, i3, s3) : "";
        }
        getWrappedRangeForLine(e3) {
          let t3 = e3, i3 = e3;
          for (;t3 > 0 && this.lines.get(t3).isWrapped; )
            t3--;
          for (;i3 + 1 < this.lines.length && this.lines.get(i3 + 1).isWrapped; )
            i3++;
          return { first: t3, last: i3 };
        }
        setupTabStops(e3) {
          for (e3 != null ? this.tabs[e3] || (e3 = this.prevStop(e3)) : (this.tabs = {}, e3 = 0);e3 < this._cols; e3 += this._optionsService.rawOptions.tabStopWidth)
            this.tabs[e3] = true;
        }
        prevStop(e3) {
          for (e3 == null && (e3 = this.x);!this.tabs[--e3] && e3 > 0; )
            ;
          return e3 >= this._cols ? this._cols - 1 : e3 < 0 ? 0 : e3;
        }
        nextStop(e3) {
          for (e3 == null && (e3 = this.x);!this.tabs[++e3] && e3 < this._cols; )
            ;
          return e3 >= this._cols ? this._cols - 1 : e3 < 0 ? 0 : e3;
        }
        clearMarkers(e3) {
          this._isClearing = true;
          for (let t3 = 0;t3 < this.markers.length; t3++)
            this.markers[t3].line === e3 && (this.markers[t3].dispose(), this.markers.splice(t3--, 1));
          this._isClearing = false;
        }
        clearAllMarkers() {
          this._isClearing = true;
          for (let e3 = 0;e3 < this.markers.length; e3++)
            this.markers[e3].dispose(), this.markers.splice(e3--, 1);
          this._isClearing = false;
        }
        addMarker(e3) {
          const t3 = new l.Marker(e3);
          return this.markers.push(t3), t3.register(this.lines.onTrim((e4) => {
            t3.line -= e4, t3.line < 0 && t3.dispose();
          })), t3.register(this.lines.onInsert((e4) => {
            t3.line >= e4.index && (t3.line += e4.amount);
          })), t3.register(this.lines.onDelete((e4) => {
            t3.line >= e4.index && t3.line < e4.index + e4.amount && t3.dispose(), t3.line > e4.index && (t3.line -= e4.amount);
          })), t3.register(t3.onDispose(() => this._removeMarker(t3))), t3;
        }
        _removeMarker(e3) {
          this._isClearing || this.markers.splice(this.markers.indexOf(e3), 1);
        }
      };
    }, 8437: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferLine = t2.DEFAULT_ATTR_DATA = undefined;
      const s2 = i2(3734), r = i2(511), n = i2(643), o = i2(482);
      t2.DEFAULT_ATTR_DATA = Object.freeze(new s2.AttributeData);
      let a = 0;

      class h {
        constructor(e3, t3, i3 = false) {
          this.isWrapped = i3, this._combined = {}, this._extendedAttrs = {}, this._data = new Uint32Array(3 * e3);
          const s3 = t3 || r.CellData.fromCharData([0, n.NULL_CELL_CHAR, n.NULL_CELL_WIDTH, n.NULL_CELL_CODE]);
          for (let t4 = 0;t4 < e3; ++t4)
            this.setCell(t4, s3);
          this.length = e3;
        }
        get(e3) {
          const t3 = this._data[3 * e3 + 0], i3 = 2097151 & t3;
          return [this._data[3 * e3 + 1], 2097152 & t3 ? this._combined[e3] : i3 ? (0, o.stringFromCodePoint)(i3) : "", t3 >> 22, 2097152 & t3 ? this._combined[e3].charCodeAt(this._combined[e3].length - 1) : i3];
        }
        set(e3, t3) {
          this._data[3 * e3 + 1] = t3[n.CHAR_DATA_ATTR_INDEX], t3[n.CHAR_DATA_CHAR_INDEX].length > 1 ? (this._combined[e3] = t3[1], this._data[3 * e3 + 0] = 2097152 | e3 | t3[n.CHAR_DATA_WIDTH_INDEX] << 22) : this._data[3 * e3 + 0] = t3[n.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | t3[n.CHAR_DATA_WIDTH_INDEX] << 22;
        }
        getWidth(e3) {
          return this._data[3 * e3 + 0] >> 22;
        }
        hasWidth(e3) {
          return 12582912 & this._data[3 * e3 + 0];
        }
        getFg(e3) {
          return this._data[3 * e3 + 1];
        }
        getBg(e3) {
          return this._data[3 * e3 + 2];
        }
        hasContent(e3) {
          return 4194303 & this._data[3 * e3 + 0];
        }
        getCodePoint(e3) {
          const t3 = this._data[3 * e3 + 0];
          return 2097152 & t3 ? this._combined[e3].charCodeAt(this._combined[e3].length - 1) : 2097151 & t3;
        }
        isCombined(e3) {
          return 2097152 & this._data[3 * e3 + 0];
        }
        getString(e3) {
          const t3 = this._data[3 * e3 + 0];
          return 2097152 & t3 ? this._combined[e3] : 2097151 & t3 ? (0, o.stringFromCodePoint)(2097151 & t3) : "";
        }
        isProtected(e3) {
          return 536870912 & this._data[3 * e3 + 2];
        }
        loadCell(e3, t3) {
          return a = 3 * e3, t3.content = this._data[a + 0], t3.fg = this._data[a + 1], t3.bg = this._data[a + 2], 2097152 & t3.content && (t3.combinedData = this._combined[e3]), 268435456 & t3.bg && (t3.extended = this._extendedAttrs[e3]), t3;
        }
        setCell(e3, t3) {
          2097152 & t3.content && (this._combined[e3] = t3.combinedData), 268435456 & t3.bg && (this._extendedAttrs[e3] = t3.extended), this._data[3 * e3 + 0] = t3.content, this._data[3 * e3 + 1] = t3.fg, this._data[3 * e3 + 2] = t3.bg;
        }
        setCellFromCodePoint(e3, t3, i3, s3, r2, n2) {
          268435456 & r2 && (this._extendedAttrs[e3] = n2), this._data[3 * e3 + 0] = t3 | i3 << 22, this._data[3 * e3 + 1] = s3, this._data[3 * e3 + 2] = r2;
        }
        addCodepointToCell(e3, t3, i3) {
          let s3 = this._data[3 * e3 + 0];
          2097152 & s3 ? this._combined[e3] += (0, o.stringFromCodePoint)(t3) : 2097151 & s3 ? (this._combined[e3] = (0, o.stringFromCodePoint)(2097151 & s3) + (0, o.stringFromCodePoint)(t3), s3 &= -2097152, s3 |= 2097152) : s3 = t3 | 1 << 22, i3 && (s3 &= -12582913, s3 |= i3 << 22), this._data[3 * e3 + 0] = s3;
        }
        insertCells(e3, t3, i3, n2) {
          if ((e3 %= this.length) && this.getWidth(e3 - 1) === 2 && this.setCellFromCodePoint(e3 - 1, 0, 1, n2?.fg || 0, n2?.bg || 0, n2?.extended || new s2.ExtendedAttrs), t3 < this.length - e3) {
            const s3 = new r.CellData;
            for (let i4 = this.length - e3 - t3 - 1;i4 >= 0; --i4)
              this.setCell(e3 + t3 + i4, this.loadCell(e3 + i4, s3));
            for (let s4 = 0;s4 < t3; ++s4)
              this.setCell(e3 + s4, i3);
          } else
            for (let t4 = e3;t4 < this.length; ++t4)
              this.setCell(t4, i3);
          this.getWidth(this.length - 1) === 2 && this.setCellFromCodePoint(this.length - 1, 0, 1, n2?.fg || 0, n2?.bg || 0, n2?.extended || new s2.ExtendedAttrs);
        }
        deleteCells(e3, t3, i3, n2) {
          if (e3 %= this.length, t3 < this.length - e3) {
            const s3 = new r.CellData;
            for (let i4 = 0;i4 < this.length - e3 - t3; ++i4)
              this.setCell(e3 + i4, this.loadCell(e3 + t3 + i4, s3));
            for (let e4 = this.length - t3;e4 < this.length; ++e4)
              this.setCell(e4, i3);
          } else
            for (let t4 = e3;t4 < this.length; ++t4)
              this.setCell(t4, i3);
          e3 && this.getWidth(e3 - 1) === 2 && this.setCellFromCodePoint(e3 - 1, 0, 1, n2?.fg || 0, n2?.bg || 0, n2?.extended || new s2.ExtendedAttrs), this.getWidth(e3) !== 0 || this.hasContent(e3) || this.setCellFromCodePoint(e3, 0, 1, n2?.fg || 0, n2?.bg || 0, n2?.extended || new s2.ExtendedAttrs);
        }
        replaceCells(e3, t3, i3, r2, n2 = false) {
          if (n2)
            for (e3 && this.getWidth(e3 - 1) === 2 && !this.isProtected(e3 - 1) && this.setCellFromCodePoint(e3 - 1, 0, 1, r2?.fg || 0, r2?.bg || 0, r2?.extended || new s2.ExtendedAttrs), t3 < this.length && this.getWidth(t3 - 1) === 2 && !this.isProtected(t3) && this.setCellFromCodePoint(t3, 0, 1, r2?.fg || 0, r2?.bg || 0, r2?.extended || new s2.ExtendedAttrs);e3 < t3 && e3 < this.length; )
              this.isProtected(e3) || this.setCell(e3, i3), e3++;
          else
            for (e3 && this.getWidth(e3 - 1) === 2 && this.setCellFromCodePoint(e3 - 1, 0, 1, r2?.fg || 0, r2?.bg || 0, r2?.extended || new s2.ExtendedAttrs), t3 < this.length && this.getWidth(t3 - 1) === 2 && this.setCellFromCodePoint(t3, 0, 1, r2?.fg || 0, r2?.bg || 0, r2?.extended || new s2.ExtendedAttrs);e3 < t3 && e3 < this.length; )
              this.setCell(e3++, i3);
        }
        resize(e3, t3) {
          if (e3 === this.length)
            return 4 * this._data.length * 2 < this._data.buffer.byteLength;
          const i3 = 3 * e3;
          if (e3 > this.length) {
            if (this._data.buffer.byteLength >= 4 * i3)
              this._data = new Uint32Array(this._data.buffer, 0, i3);
            else {
              const e4 = new Uint32Array(i3);
              e4.set(this._data), this._data = e4;
            }
            for (let i4 = this.length;i4 < e3; ++i4)
              this.setCell(i4, t3);
          } else {
            this._data = this._data.subarray(0, i3);
            const t4 = Object.keys(this._combined);
            for (let i4 = 0;i4 < t4.length; i4++) {
              const s4 = parseInt(t4[i4], 10);
              s4 >= e3 && delete this._combined[s4];
            }
            const s3 = Object.keys(this._extendedAttrs);
            for (let t5 = 0;t5 < s3.length; t5++) {
              const i4 = parseInt(s3[t5], 10);
              i4 >= e3 && delete this._extendedAttrs[i4];
            }
          }
          return this.length = e3, 4 * i3 * 2 < this._data.buffer.byteLength;
        }
        cleanupMemory() {
          if (4 * this._data.length * 2 < this._data.buffer.byteLength) {
            const e3 = new Uint32Array(this._data.length);
            return e3.set(this._data), this._data = e3, 1;
          }
          return 0;
        }
        fill(e3, t3 = false) {
          if (t3)
            for (let t4 = 0;t4 < this.length; ++t4)
              this.isProtected(t4) || this.setCell(t4, e3);
          else {
            this._combined = {}, this._extendedAttrs = {};
            for (let t4 = 0;t4 < this.length; ++t4)
              this.setCell(t4, e3);
          }
        }
        copyFrom(e3) {
          this.length !== e3.length ? this._data = new Uint32Array(e3._data) : this._data.set(e3._data), this.length = e3.length, this._combined = {};
          for (const t3 in e3._combined)
            this._combined[t3] = e3._combined[t3];
          this._extendedAttrs = {};
          for (const t3 in e3._extendedAttrs)
            this._extendedAttrs[t3] = e3._extendedAttrs[t3];
          this.isWrapped = e3.isWrapped;
        }
        clone() {
          const e3 = new h(0);
          e3._data = new Uint32Array(this._data), e3.length = this.length;
          for (const t3 in this._combined)
            e3._combined[t3] = this._combined[t3];
          for (const t3 in this._extendedAttrs)
            e3._extendedAttrs[t3] = this._extendedAttrs[t3];
          return e3.isWrapped = this.isWrapped, e3;
        }
        getTrimmedLength() {
          for (let e3 = this.length - 1;e3 >= 0; --e3)
            if (4194303 & this._data[3 * e3 + 0])
              return e3 + (this._data[3 * e3 + 0] >> 22);
          return 0;
        }
        getNoBgTrimmedLength() {
          for (let e3 = this.length - 1;e3 >= 0; --e3)
            if (4194303 & this._data[3 * e3 + 0] || 50331648 & this._data[3 * e3 + 2])
              return e3 + (this._data[3 * e3 + 0] >> 22);
          return 0;
        }
        copyCellsFrom(e3, t3, i3, s3, r2) {
          const n2 = e3._data;
          if (r2)
            for (let r3 = s3 - 1;r3 >= 0; r3--) {
              for (let e4 = 0;e4 < 3; e4++)
                this._data[3 * (i3 + r3) + e4] = n2[3 * (t3 + r3) + e4];
              268435456 & n2[3 * (t3 + r3) + 2] && (this._extendedAttrs[i3 + r3] = e3._extendedAttrs[t3 + r3]);
            }
          else
            for (let r3 = 0;r3 < s3; r3++) {
              for (let e4 = 0;e4 < 3; e4++)
                this._data[3 * (i3 + r3) + e4] = n2[3 * (t3 + r3) + e4];
              268435456 & n2[3 * (t3 + r3) + 2] && (this._extendedAttrs[i3 + r3] = e3._extendedAttrs[t3 + r3]);
            }
          const o2 = Object.keys(e3._combined);
          for (let s4 = 0;s4 < o2.length; s4++) {
            const r3 = parseInt(o2[s4], 10);
            r3 >= t3 && (this._combined[r3 - t3 + i3] = e3._combined[r3]);
          }
        }
        translateToString(e3 = false, t3 = 0, i3 = this.length) {
          e3 && (i3 = Math.min(i3, this.getTrimmedLength()));
          let s3 = "";
          for (;t3 < i3; ) {
            const e4 = this._data[3 * t3 + 0], i4 = 2097151 & e4;
            s3 += 2097152 & e4 ? this._combined[t3] : i4 ? (0, o.stringFromCodePoint)(i4) : n.WHITESPACE_CELL_CHAR, t3 += e4 >> 22 || 1;
          }
          return s3;
        }
      }
      t2.BufferLine = h;
    }, 4841: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.getRangeLength = undefined, t2.getRangeLength = function(e3, t3) {
        if (e3.start.y > e3.end.y)
          throw new Error(`Buffer range end (${e3.end.x}, ${e3.end.y}) cannot be before start (${e3.start.x}, ${e3.start.y})`);
        return t3 * (e3.end.y - e3.start.y) + (e3.end.x - e3.start.x + 1);
      };
    }, 4634: (e2, t2) => {
      function i2(e3, t3, i3) {
        if (t3 === e3.length - 1)
          return e3[t3].getTrimmedLength();
        const s2 = !e3[t3].hasContent(i3 - 1) && e3[t3].getWidth(i3 - 1) === 1, r = e3[t3 + 1].getWidth(0) === 2;
        return s2 && r ? i3 - 1 : i3;
      }
      Object.defineProperty(t2, "__esModule", { value: true }), t2.getWrappedLineTrimmedLength = t2.reflowSmallerGetNewLineLengths = t2.reflowLargerApplyNewLayout = t2.reflowLargerCreateNewLayout = t2.reflowLargerGetLinesToRemove = undefined, t2.reflowLargerGetLinesToRemove = function(e3, t3, s2, r, n) {
        const o = [];
        for (let a = 0;a < e3.length - 1; a++) {
          let h = a, c = e3.get(++h);
          if (!c.isWrapped)
            continue;
          const l = [e3.get(a)];
          for (;h < e3.length && c.isWrapped; )
            l.push(c), c = e3.get(++h);
          if (r >= a && r < h) {
            a += l.length - 1;
            continue;
          }
          let d = 0, _ = i2(l, d, t3), u = 1, f = 0;
          for (;u < l.length; ) {
            const e4 = i2(l, u, t3), r2 = e4 - f, o2 = s2 - _, a2 = Math.min(r2, o2);
            l[d].copyCellsFrom(l[u], f, _, a2, false), _ += a2, _ === s2 && (d++, _ = 0), f += a2, f === e4 && (u++, f = 0), _ === 0 && d !== 0 && l[d - 1].getWidth(s2 - 1) === 2 && (l[d].copyCellsFrom(l[d - 1], s2 - 1, _++, 1, false), l[d - 1].setCell(s2 - 1, n));
          }
          l[d].replaceCells(_, s2, n);
          let v = 0;
          for (let e4 = l.length - 1;e4 > 0 && (e4 > d || l[e4].getTrimmedLength() === 0); e4--)
            v++;
          v > 0 && (o.push(a + l.length - v), o.push(v)), a += l.length - 1;
        }
        return o;
      }, t2.reflowLargerCreateNewLayout = function(e3, t3) {
        const i3 = [];
        let s2 = 0, r = t3[s2], n = 0;
        for (let o = 0;o < e3.length; o++)
          if (r === o) {
            const i4 = t3[++s2];
            e3.onDeleteEmitter.fire({ index: o - n, amount: i4 }), o += i4 - 1, n += i4, r = t3[++s2];
          } else
            i3.push(o);
        return { layout: i3, countRemoved: n };
      }, t2.reflowLargerApplyNewLayout = function(e3, t3) {
        const i3 = [];
        for (let s2 = 0;s2 < t3.length; s2++)
          i3.push(e3.get(t3[s2]));
        for (let t4 = 0;t4 < i3.length; t4++)
          e3.set(t4, i3[t4]);
        e3.length = t3.length;
      }, t2.reflowSmallerGetNewLineLengths = function(e3, t3, s2) {
        const r = [], n = e3.map((s3, r2) => i2(e3, r2, t3)).reduce((e4, t4) => e4 + t4);
        let o = 0, a = 0, h = 0;
        for (;h < n; ) {
          if (n - h < s2) {
            r.push(n - h);
            break;
          }
          o += s2;
          const c = i2(e3, a, t3);
          o > c && (o -= c, a++);
          const l = e3[a].getWidth(o - 1) === 2;
          l && o--;
          const d = l ? s2 - 1 : s2;
          r.push(d), h += d;
        }
        return r;
      }, t2.getWrappedLineTrimmedLength = i2;
    }, 5295: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferSet = undefined;
      const s2 = i2(8460), r = i2(844), n = i2(9092);

      class o extends r.Disposable {
        constructor(e3, t3) {
          super(), this._optionsService = e3, this._bufferService = t3, this._onBufferActivate = this.register(new s2.EventEmitter), this.onBufferActivate = this._onBufferActivate.event, this.reset(), this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.resize(this._bufferService.cols, this._bufferService.rows))), this.register(this._optionsService.onSpecificOptionChange("tabStopWidth", () => this.setupTabStops()));
        }
        reset() {
          this._normal = new n.Buffer(true, this._optionsService, this._bufferService), this._normal.fillViewportRows(), this._alt = new n.Buffer(false, this._optionsService, this._bufferService), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }), this.setupTabStops();
        }
        get alt() {
          return this._alt;
        }
        get active() {
          return this._activeBuffer;
        }
        get normal() {
          return this._normal;
        }
        activateNormalBuffer() {
          this._activeBuffer !== this._normal && (this._normal.x = this._alt.x, this._normal.y = this._alt.y, this._alt.clearAllMarkers(), this._alt.clear(), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }));
        }
        activateAltBuffer(e3) {
          this._activeBuffer !== this._alt && (this._alt.fillViewportRows(e3), this._alt.x = this._normal.x, this._alt.y = this._normal.y, this._activeBuffer = this._alt, this._onBufferActivate.fire({ activeBuffer: this._alt, inactiveBuffer: this._normal }));
        }
        resize(e3, t3) {
          this._normal.resize(e3, t3), this._alt.resize(e3, t3), this.setupTabStops(e3);
        }
        setupTabStops(e3) {
          this._normal.setupTabStops(e3), this._alt.setupTabStops(e3);
        }
      }
      t2.BufferSet = o;
    }, 511: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.CellData = undefined;
      const s2 = i2(482), r = i2(643), n = i2(3734);

      class o extends n.AttributeData {
        constructor() {
          super(...arguments), this.content = 0, this.fg = 0, this.bg = 0, this.extended = new n.ExtendedAttrs, this.combinedData = "";
        }
        static fromCharData(e3) {
          const t3 = new o;
          return t3.setFromCharData(e3), t3;
        }
        isCombined() {
          return 2097152 & this.content;
        }
        getWidth() {
          return this.content >> 22;
        }
        getChars() {
          return 2097152 & this.content ? this.combinedData : 2097151 & this.content ? (0, s2.stringFromCodePoint)(2097151 & this.content) : "";
        }
        getCode() {
          return this.isCombined() ? this.combinedData.charCodeAt(this.combinedData.length - 1) : 2097151 & this.content;
        }
        setFromCharData(e3) {
          this.fg = e3[r.CHAR_DATA_ATTR_INDEX], this.bg = 0;
          let t3 = false;
          if (e3[r.CHAR_DATA_CHAR_INDEX].length > 2)
            t3 = true;
          else if (e3[r.CHAR_DATA_CHAR_INDEX].length === 2) {
            const i3 = e3[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0);
            if (55296 <= i3 && i3 <= 56319) {
              const s3 = e3[r.CHAR_DATA_CHAR_INDEX].charCodeAt(1);
              56320 <= s3 && s3 <= 57343 ? this.content = 1024 * (i3 - 55296) + s3 - 56320 + 65536 | e3[r.CHAR_DATA_WIDTH_INDEX] << 22 : t3 = true;
            } else
              t3 = true;
          } else
            this.content = e3[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | e3[r.CHAR_DATA_WIDTH_INDEX] << 22;
          t3 && (this.combinedData = e3[r.CHAR_DATA_CHAR_INDEX], this.content = 2097152 | e3[r.CHAR_DATA_WIDTH_INDEX] << 22);
        }
        getAsCharData() {
          return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
        }
      }
      t2.CellData = o;
    }, 643: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.WHITESPACE_CELL_CODE = t2.WHITESPACE_CELL_WIDTH = t2.WHITESPACE_CELL_CHAR = t2.NULL_CELL_CODE = t2.NULL_CELL_WIDTH = t2.NULL_CELL_CHAR = t2.CHAR_DATA_CODE_INDEX = t2.CHAR_DATA_WIDTH_INDEX = t2.CHAR_DATA_CHAR_INDEX = t2.CHAR_DATA_ATTR_INDEX = t2.DEFAULT_EXT = t2.DEFAULT_ATTR = t2.DEFAULT_COLOR = undefined, t2.DEFAULT_COLOR = 0, t2.DEFAULT_ATTR = 256 | t2.DEFAULT_COLOR << 9, t2.DEFAULT_EXT = 0, t2.CHAR_DATA_ATTR_INDEX = 0, t2.CHAR_DATA_CHAR_INDEX = 1, t2.CHAR_DATA_WIDTH_INDEX = 2, t2.CHAR_DATA_CODE_INDEX = 3, t2.NULL_CELL_CHAR = "", t2.NULL_CELL_WIDTH = 1, t2.NULL_CELL_CODE = 0, t2.WHITESPACE_CELL_CHAR = " ", t2.WHITESPACE_CELL_WIDTH = 1, t2.WHITESPACE_CELL_CODE = 32;
    }, 4863: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.Marker = undefined;
      const s2 = i2(8460), r = i2(844);

      class n {
        get id() {
          return this._id;
        }
        constructor(e3) {
          this.line = e3, this.isDisposed = false, this._disposables = [], this._id = n._nextId++, this._onDispose = this.register(new s2.EventEmitter), this.onDispose = this._onDispose.event;
        }
        dispose() {
          this.isDisposed || (this.isDisposed = true, this.line = -1, this._onDispose.fire(), (0, r.disposeArray)(this._disposables), this._disposables.length = 0);
        }
        register(e3) {
          return this._disposables.push(e3), e3;
        }
      }
      t2.Marker = n, n._nextId = 1;
    }, 7116: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.DEFAULT_CHARSET = t2.CHARSETS = undefined, t2.CHARSETS = {}, t2.DEFAULT_CHARSET = t2.CHARSETS.B, t2.CHARSETS[0] = { "`": "\u25C6", a: "\u2592", b: "\u2409", c: "\u240C", d: "\u240D", e: "\u240A", f: "\xB0", g: "\xB1", h: "\u2424", i: "\u240B", j: "\u2518", k: "\u2510", l: "\u250C", m: "\u2514", n: "\u253C", o: "\u23BA", p: "\u23BB", q: "\u2500", r: "\u23BC", s: "\u23BD", t: "\u251C", u: "\u2524", v: "\u2534", w: "\u252C", x: "\u2502", y: "\u2264", z: "\u2265", "{": "\u03C0", "|": "\u2260", "}": "\xA3", "~": "\xB7" }, t2.CHARSETS.A = { "#": "\xA3" }, t2.CHARSETS.B = undefined, t2.CHARSETS[4] = { "#": "\xA3", "@": "\xBE", "[": "ij", "\\": "\xBD", "]": "|", "{": "\xA8", "|": "f", "}": "\xBC", "~": "\xB4" }, t2.CHARSETS.C = t2.CHARSETS[5] = { "[": "\xC4", "\\": "\xD6", "]": "\xC5", "^": "\xDC", "`": "\xE9", "{": "\xE4", "|": "\xF6", "}": "\xE5", "~": "\xFC" }, t2.CHARSETS.R = { "#": "\xA3", "@": "\xE0", "[": "\xB0", "\\": "\xE7", "]": "\xA7", "{": "\xE9", "|": "\xF9", "}": "\xE8", "~": "\xA8" }, t2.CHARSETS.Q = { "@": "\xE0", "[": "\xE2", "\\": "\xE7", "]": "\xEA", "^": "\xEE", "`": "\xF4", "{": "\xE9", "|": "\xF9", "}": "\xE8", "~": "\xFB" }, t2.CHARSETS.K = { "@": "\xA7", "[": "\xC4", "\\": "\xD6", "]": "\xDC", "{": "\xE4", "|": "\xF6", "}": "\xFC", "~": "\xDF" }, t2.CHARSETS.Y = { "#": "\xA3", "@": "\xA7", "[": "\xB0", "\\": "\xE7", "]": "\xE9", "`": "\xF9", "{": "\xE0", "|": "\xF2", "}": "\xE8", "~": "\xEC" }, t2.CHARSETS.E = t2.CHARSETS[6] = { "@": "\xC4", "[": "\xC6", "\\": "\xD8", "]": "\xC5", "^": "\xDC", "`": "\xE4", "{": "\xE6", "|": "\xF8", "}": "\xE5", "~": "\xFC" }, t2.CHARSETS.Z = { "#": "\xA3", "@": "\xA7", "[": "\xA1", "\\": "\xD1", "]": "\xBF", "{": "\xB0", "|": "\xF1", "}": "\xE7" }, t2.CHARSETS.H = t2.CHARSETS[7] = { "@": "\xC9", "[": "\xC4", "\\": "\xD6", "]": "\xC5", "^": "\xDC", "`": "\xE9", "{": "\xE4", "|": "\xF6", "}": "\xE5", "~": "\xFC" }, t2.CHARSETS["="] = { "#": "\xF9", "@": "\xE0", "[": "\xE9", "\\": "\xE7", "]": "\xEA", "^": "\xEE", _: "\xE8", "`": "\xF4", "{": "\xE4", "|": "\xF6", "}": "\xFC", "~": "\xFB" };
    }, 2584: (e2, t2) => {
      var i2, s2, r;
      Object.defineProperty(t2, "__esModule", { value: true }), t2.C1_ESCAPED = t2.C1 = t2.C0 = undefined, function(e3) {
        e3.NUL = "\0", e3.SOH = "", e3.STX = "", e3.ETX = "", e3.EOT = "", e3.ENQ = "", e3.ACK = "", e3.BEL = "", e3.BS = "\b", e3.HT = "\t", e3.LF = "\n", e3.VT = "\v", e3.FF = "\f", e3.CR = "\r", e3.SO = "", e3.SI = "", e3.DLE = "", e3.DC1 = "", e3.DC2 = "", e3.DC3 = "", e3.DC4 = "", e3.NAK = "", e3.SYN = "", e3.ETB = "", e3.CAN = "", e3.EM = "", e3.SUB = "", e3.ESC = "", e3.FS = "", e3.GS = "", e3.RS = "", e3.US = "", e3.SP = " ", e3.DEL = "";
      }(i2 || (t2.C0 = i2 = {})), function(e3) {
        e3.PAD = "\x80", e3.HOP = "\x81", e3.BPH = "\x82", e3.NBH = "\x83", e3.IND = "\x84", e3.NEL = "\x85", e3.SSA = "\x86", e3.ESA = "\x87", e3.HTS = "\x88", e3.HTJ = "\x89", e3.VTS = "\x8A", e3.PLD = "\x8B", e3.PLU = "\x8C", e3.RI = "\x8D", e3.SS2 = "\x8E", e3.SS3 = "\x8F", e3.DCS = "\x90", e3.PU1 = "\x91", e3.PU2 = "\x92", e3.STS = "\x93", e3.CCH = "\x94", e3.MW = "\x95", e3.SPA = "\x96", e3.EPA = "\x97", e3.SOS = "\x98", e3.SGCI = "\x99", e3.SCI = "\x9A", e3.CSI = "\x9B", e3.ST = "\x9C", e3.OSC = "\x9D", e3.PM = "\x9E", e3.APC = "\x9F";
      }(s2 || (t2.C1 = s2 = {})), function(e3) {
        e3.ST = `${i2.ESC}\\`;
      }(r || (t2.C1_ESCAPED = r = {}));
    }, 7399: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.evaluateKeyboardEvent = undefined;
      const s2 = i2(2584), r = { 48: ["0", ")"], 49: ["1", "!"], 50: ["2", "@"], 51: ["3", "#"], 52: ["4", "$"], 53: ["5", "%"], 54: ["6", "^"], 55: ["7", "&"], 56: ["8", "*"], 57: ["9", "("], 186: [";", ":"], 187: ["=", "+"], 188: [",", "<"], 189: ["-", "_"], 190: [".", ">"], 191: ["/", "?"], 192: ["`", "~"], 219: ["[", "{"], 220: ["\\", "|"], 221: ["]", "}"], 222: ["'", '"'] };
      t2.evaluateKeyboardEvent = function(e3, t3, i3, n) {
        const o = { type: 0, cancel: false, key: undefined }, a = (e3.shiftKey ? 1 : 0) | (e3.altKey ? 2 : 0) | (e3.ctrlKey ? 4 : 0) | (e3.metaKey ? 8 : 0);
        switch (e3.keyCode) {
          case 0:
            e3.key === "UIKeyInputUpArrow" ? o.key = t3 ? s2.C0.ESC + "OA" : s2.C0.ESC + "[A" : e3.key === "UIKeyInputLeftArrow" ? o.key = t3 ? s2.C0.ESC + "OD" : s2.C0.ESC + "[D" : e3.key === "UIKeyInputRightArrow" ? o.key = t3 ? s2.C0.ESC + "OC" : s2.C0.ESC + "[C" : e3.key === "UIKeyInputDownArrow" && (o.key = t3 ? s2.C0.ESC + "OB" : s2.C0.ESC + "[B");
            break;
          case 8:
            if (e3.altKey) {
              o.key = s2.C0.ESC + s2.C0.DEL;
              break;
            }
            o.key = s2.C0.DEL;
            break;
          case 9:
            if (e3.shiftKey) {
              o.key = s2.C0.ESC + "[Z";
              break;
            }
            o.key = s2.C0.HT, o.cancel = true;
            break;
          case 13:
            o.key = e3.altKey ? s2.C0.ESC + s2.C0.CR : s2.C0.CR, o.cancel = true;
            break;
          case 27:
            o.key = s2.C0.ESC, e3.altKey && (o.key = s2.C0.ESC + s2.C0.ESC), o.cancel = true;
            break;
          case 37:
            if (e3.metaKey)
              break;
            a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "D", o.key === s2.C0.ESC + "[1;3D" && (o.key = s2.C0.ESC + (i3 ? "b" : "[1;5D"))) : o.key = t3 ? s2.C0.ESC + "OD" : s2.C0.ESC + "[D";
            break;
          case 39:
            if (e3.metaKey)
              break;
            a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "C", o.key === s2.C0.ESC + "[1;3C" && (o.key = s2.C0.ESC + (i3 ? "f" : "[1;5C"))) : o.key = t3 ? s2.C0.ESC + "OC" : s2.C0.ESC + "[C";
            break;
          case 38:
            if (e3.metaKey)
              break;
            a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "A", i3 || o.key !== s2.C0.ESC + "[1;3A" || (o.key = s2.C0.ESC + "[1;5A")) : o.key = t3 ? s2.C0.ESC + "OA" : s2.C0.ESC + "[A";
            break;
          case 40:
            if (e3.metaKey)
              break;
            a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "B", i3 || o.key !== s2.C0.ESC + "[1;3B" || (o.key = s2.C0.ESC + "[1;5B")) : o.key = t3 ? s2.C0.ESC + "OB" : s2.C0.ESC + "[B";
            break;
          case 45:
            e3.shiftKey || e3.ctrlKey || (o.key = s2.C0.ESC + "[2~");
            break;
          case 46:
            o.key = a ? s2.C0.ESC + "[3;" + (a + 1) + "~" : s2.C0.ESC + "[3~";
            break;
          case 36:
            o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "H" : t3 ? s2.C0.ESC + "OH" : s2.C0.ESC + "[H";
            break;
          case 35:
            o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "F" : t3 ? s2.C0.ESC + "OF" : s2.C0.ESC + "[F";
            break;
          case 33:
            e3.shiftKey ? o.type = 2 : e3.ctrlKey ? o.key = s2.C0.ESC + "[5;" + (a + 1) + "~" : o.key = s2.C0.ESC + "[5~";
            break;
          case 34:
            e3.shiftKey ? o.type = 3 : e3.ctrlKey ? o.key = s2.C0.ESC + "[6;" + (a + 1) + "~" : o.key = s2.C0.ESC + "[6~";
            break;
          case 112:
            o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "P" : s2.C0.ESC + "OP";
            break;
          case 113:
            o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "Q" : s2.C0.ESC + "OQ";
            break;
          case 114:
            o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "R" : s2.C0.ESC + "OR";
            break;
          case 115:
            o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "S" : s2.C0.ESC + "OS";
            break;
          case 116:
            o.key = a ? s2.C0.ESC + "[15;" + (a + 1) + "~" : s2.C0.ESC + "[15~";
            break;
          case 117:
            o.key = a ? s2.C0.ESC + "[17;" + (a + 1) + "~" : s2.C0.ESC + "[17~";
            break;
          case 118:
            o.key = a ? s2.C0.ESC + "[18;" + (a + 1) + "~" : s2.C0.ESC + "[18~";
            break;
          case 119:
            o.key = a ? s2.C0.ESC + "[19;" + (a + 1) + "~" : s2.C0.ESC + "[19~";
            break;
          case 120:
            o.key = a ? s2.C0.ESC + "[20;" + (a + 1) + "~" : s2.C0.ESC + "[20~";
            break;
          case 121:
            o.key = a ? s2.C0.ESC + "[21;" + (a + 1) + "~" : s2.C0.ESC + "[21~";
            break;
          case 122:
            o.key = a ? s2.C0.ESC + "[23;" + (a + 1) + "~" : s2.C0.ESC + "[23~";
            break;
          case 123:
            o.key = a ? s2.C0.ESC + "[24;" + (a + 1) + "~" : s2.C0.ESC + "[24~";
            break;
          default:
            if (!e3.ctrlKey || e3.shiftKey || e3.altKey || e3.metaKey)
              if (i3 && !n || !e3.altKey || e3.metaKey)
                !i3 || e3.altKey || e3.ctrlKey || e3.shiftKey || !e3.metaKey ? e3.key && !e3.ctrlKey && !e3.altKey && !e3.metaKey && e3.keyCode >= 48 && e3.key.length === 1 ? o.key = e3.key : e3.key && e3.ctrlKey && (e3.key === "_" && (o.key = s2.C0.US), e3.key === "@" && (o.key = s2.C0.NUL)) : e3.keyCode === 65 && (o.type = 1);
              else {
                const t4 = r[e3.keyCode], i4 = t4?.[e3.shiftKey ? 1 : 0];
                if (i4)
                  o.key = s2.C0.ESC + i4;
                else if (e3.keyCode >= 65 && e3.keyCode <= 90) {
                  const t5 = e3.ctrlKey ? e3.keyCode - 64 : e3.keyCode + 32;
                  let i5 = String.fromCharCode(t5);
                  e3.shiftKey && (i5 = i5.toUpperCase()), o.key = s2.C0.ESC + i5;
                } else if (e3.keyCode === 32)
                  o.key = s2.C0.ESC + (e3.ctrlKey ? s2.C0.NUL : " ");
                else if (e3.key === "Dead" && e3.code.startsWith("Key")) {
                  let t5 = e3.code.slice(3, 4);
                  e3.shiftKey || (t5 = t5.toLowerCase()), o.key = s2.C0.ESC + t5, o.cancel = true;
                }
              }
            else
              e3.keyCode >= 65 && e3.keyCode <= 90 ? o.key = String.fromCharCode(e3.keyCode - 64) : e3.keyCode === 32 ? o.key = s2.C0.NUL : e3.keyCode >= 51 && e3.keyCode <= 55 ? o.key = String.fromCharCode(e3.keyCode - 51 + 27) : e3.keyCode === 56 ? o.key = s2.C0.DEL : e3.keyCode === 219 ? o.key = s2.C0.ESC : e3.keyCode === 220 ? o.key = s2.C0.FS : e3.keyCode === 221 && (o.key = s2.C0.GS);
        }
        return o;
      };
    }, 482: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.Utf8ToUtf32 = t2.StringToUtf32 = t2.utf32ToString = t2.stringFromCodePoint = undefined, t2.stringFromCodePoint = function(e3) {
        return e3 > 65535 ? (e3 -= 65536, String.fromCharCode(55296 + (e3 >> 10)) + String.fromCharCode(e3 % 1024 + 56320)) : String.fromCharCode(e3);
      }, t2.utf32ToString = function(e3, t3 = 0, i2 = e3.length) {
        let s2 = "";
        for (let r = t3;r < i2; ++r) {
          let t4 = e3[r];
          t4 > 65535 ? (t4 -= 65536, s2 += String.fromCharCode(55296 + (t4 >> 10)) + String.fromCharCode(t4 % 1024 + 56320)) : s2 += String.fromCharCode(t4);
        }
        return s2;
      }, t2.StringToUtf32 = class {
        constructor() {
          this._interim = 0;
        }
        clear() {
          this._interim = 0;
        }
        decode(e3, t3) {
          const i2 = e3.length;
          if (!i2)
            return 0;
          let s2 = 0, r = 0;
          if (this._interim) {
            const i3 = e3.charCodeAt(r++);
            56320 <= i3 && i3 <= 57343 ? t3[s2++] = 1024 * (this._interim - 55296) + i3 - 56320 + 65536 : (t3[s2++] = this._interim, t3[s2++] = i3), this._interim = 0;
          }
          for (let n = r;n < i2; ++n) {
            const r2 = e3.charCodeAt(n);
            if (55296 <= r2 && r2 <= 56319) {
              if (++n >= i2)
                return this._interim = r2, s2;
              const o = e3.charCodeAt(n);
              56320 <= o && o <= 57343 ? t3[s2++] = 1024 * (r2 - 55296) + o - 56320 + 65536 : (t3[s2++] = r2, t3[s2++] = o);
            } else
              r2 !== 65279 && (t3[s2++] = r2);
          }
          return s2;
        }
      }, t2.Utf8ToUtf32 = class {
        constructor() {
          this.interim = new Uint8Array(3);
        }
        clear() {
          this.interim.fill(0);
        }
        decode(e3, t3) {
          const i2 = e3.length;
          if (!i2)
            return 0;
          let s2, r, n, o, a = 0, h = 0, c = 0;
          if (this.interim[0]) {
            let s3 = false, r2 = this.interim[0];
            r2 &= (224 & r2) == 192 ? 31 : (240 & r2) == 224 ? 15 : 7;
            let n2, o2 = 0;
            for (;(n2 = 63 & this.interim[++o2]) && o2 < 4; )
              r2 <<= 6, r2 |= n2;
            const h2 = (224 & this.interim[0]) == 192 ? 2 : (240 & this.interim[0]) == 224 ? 3 : 4, l2 = h2 - o2;
            for (;c < l2; ) {
              if (c >= i2)
                return 0;
              if (n2 = e3[c++], (192 & n2) != 128) {
                c--, s3 = true;
                break;
              }
              this.interim[o2++] = n2, r2 <<= 6, r2 |= 63 & n2;
            }
            s3 || (h2 === 2 ? r2 < 128 ? c-- : t3[a++] = r2 : h2 === 3 ? r2 < 2048 || r2 >= 55296 && r2 <= 57343 || r2 === 65279 || (t3[a++] = r2) : r2 < 65536 || r2 > 1114111 || (t3[a++] = r2)), this.interim.fill(0);
          }
          const l = i2 - 4;
          let d = c;
          for (;d < i2; ) {
            for (;!(!(d < l) || 128 & (s2 = e3[d]) || 128 & (r = e3[d + 1]) || 128 & (n = e3[d + 2]) || 128 & (o = e3[d + 3])); )
              t3[a++] = s2, t3[a++] = r, t3[a++] = n, t3[a++] = o, d += 4;
            if (s2 = e3[d++], s2 < 128)
              t3[a++] = s2;
            else if ((224 & s2) == 192) {
              if (d >= i2)
                return this.interim[0] = s2, a;
              if (r = e3[d++], (192 & r) != 128) {
                d--;
                continue;
              }
              if (h = (31 & s2) << 6 | 63 & r, h < 128) {
                d--;
                continue;
              }
              t3[a++] = h;
            } else if ((240 & s2) == 224) {
              if (d >= i2)
                return this.interim[0] = s2, a;
              if (r = e3[d++], (192 & r) != 128) {
                d--;
                continue;
              }
              if (d >= i2)
                return this.interim[0] = s2, this.interim[1] = r, a;
              if (n = e3[d++], (192 & n) != 128) {
                d--;
                continue;
              }
              if (h = (15 & s2) << 12 | (63 & r) << 6 | 63 & n, h < 2048 || h >= 55296 && h <= 57343 || h === 65279)
                continue;
              t3[a++] = h;
            } else if ((248 & s2) == 240) {
              if (d >= i2)
                return this.interim[0] = s2, a;
              if (r = e3[d++], (192 & r) != 128) {
                d--;
                continue;
              }
              if (d >= i2)
                return this.interim[0] = s2, this.interim[1] = r, a;
              if (n = e3[d++], (192 & n) != 128) {
                d--;
                continue;
              }
              if (d >= i2)
                return this.interim[0] = s2, this.interim[1] = r, this.interim[2] = n, a;
              if (o = e3[d++], (192 & o) != 128) {
                d--;
                continue;
              }
              if (h = (7 & s2) << 18 | (63 & r) << 12 | (63 & n) << 6 | 63 & o, h < 65536 || h > 1114111)
                continue;
              t3[a++] = h;
            }
          }
          return a;
        }
      };
    }, 225: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.UnicodeV6 = undefined;
      const s2 = i2(1480), r = [[768, 879], [1155, 1158], [1160, 1161], [1425, 1469], [1471, 1471], [1473, 1474], [1476, 1477], [1479, 1479], [1536, 1539], [1552, 1557], [1611, 1630], [1648, 1648], [1750, 1764], [1767, 1768], [1770, 1773], [1807, 1807], [1809, 1809], [1840, 1866], [1958, 1968], [2027, 2035], [2305, 2306], [2364, 2364], [2369, 2376], [2381, 2381], [2385, 2388], [2402, 2403], [2433, 2433], [2492, 2492], [2497, 2500], [2509, 2509], [2530, 2531], [2561, 2562], [2620, 2620], [2625, 2626], [2631, 2632], [2635, 2637], [2672, 2673], [2689, 2690], [2748, 2748], [2753, 2757], [2759, 2760], [2765, 2765], [2786, 2787], [2817, 2817], [2876, 2876], [2879, 2879], [2881, 2883], [2893, 2893], [2902, 2902], [2946, 2946], [3008, 3008], [3021, 3021], [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3260, 3260], [3263, 3263], [3270, 3270], [3276, 3277], [3298, 3299], [3393, 3395], [3405, 3405], [3530, 3530], [3538, 3540], [3542, 3542], [3633, 3633], [3636, 3642], [3655, 3662], [3761, 3761], [3764, 3769], [3771, 3772], [3784, 3789], [3864, 3865], [3893, 3893], [3895, 3895], [3897, 3897], [3953, 3966], [3968, 3972], [3974, 3975], [3984, 3991], [3993, 4028], [4038, 4038], [4141, 4144], [4146, 4146], [4150, 4151], [4153, 4153], [4184, 4185], [4448, 4607], [4959, 4959], [5906, 5908], [5938, 5940], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], [6086, 6086], [6089, 6099], [6109, 6109], [6155, 6157], [6313, 6313], [6432, 6434], [6439, 6440], [6450, 6450], [6457, 6459], [6679, 6680], [6912, 6915], [6964, 6964], [6966, 6970], [6972, 6972], [6978, 6978], [7019, 7027], [7616, 7626], [7678, 7679], [8203, 8207], [8234, 8238], [8288, 8291], [8298, 8303], [8400, 8431], [12330, 12335], [12441, 12442], [43014, 43014], [43019, 43019], [43045, 43046], [64286, 64286], [65024, 65039], [65056, 65059], [65279, 65279], [65529, 65531]], n = [[68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], [68159, 68159], [119143, 119145], [119155, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [917505, 917505], [917536, 917631], [917760, 917999]];
      let o;
      t2.UnicodeV6 = class {
        constructor() {
          if (this.version = "6", !o) {
            o = new Uint8Array(65536), o.fill(1), o[0] = 0, o.fill(0, 1, 32), o.fill(0, 127, 160), o.fill(2, 4352, 4448), o[9001] = 2, o[9002] = 2, o.fill(2, 11904, 42192), o[12351] = 1, o.fill(2, 44032, 55204), o.fill(2, 63744, 64256), o.fill(2, 65040, 65050), o.fill(2, 65072, 65136), o.fill(2, 65280, 65377), o.fill(2, 65504, 65511);
            for (let e3 = 0;e3 < r.length; ++e3)
              o.fill(0, r[e3][0], r[e3][1] + 1);
          }
        }
        wcwidth(e3) {
          return e3 < 32 ? 0 : e3 < 127 ? 1 : e3 < 65536 ? o[e3] : function(e4, t3) {
            let i3, s3 = 0, r2 = t3.length - 1;
            if (e4 < t3[0][0] || e4 > t3[r2][1])
              return false;
            for (;r2 >= s3; )
              if (i3 = s3 + r2 >> 1, e4 > t3[i3][1])
                s3 = i3 + 1;
              else {
                if (!(e4 < t3[i3][0]))
                  return true;
                r2 = i3 - 1;
              }
            return false;
          }(e3, n) ? 0 : e3 >= 131072 && e3 <= 196605 || e3 >= 196608 && e3 <= 262141 ? 2 : 1;
        }
        charProperties(e3, t3) {
          let i3 = this.wcwidth(e3), r2 = i3 === 0 && t3 !== 0;
          if (r2) {
            const e4 = s2.UnicodeService.extractWidth(t3);
            e4 === 0 ? r2 = false : e4 > i3 && (i3 = e4);
          }
          return s2.UnicodeService.createPropertyValue(0, i3, r2);
        }
      };
    }, 5981: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.WriteBuffer = undefined;
      const s2 = i2(8460), r = i2(844);

      class n extends r.Disposable {
        constructor(e3) {
          super(), this._action = e3, this._writeBuffer = [], this._callbacks = [], this._pendingData = 0, this._bufferOffset = 0, this._isSyncWriting = false, this._syncCalls = 0, this._didUserInput = false, this._onWriteParsed = this.register(new s2.EventEmitter), this.onWriteParsed = this._onWriteParsed.event;
        }
        handleUserInput() {
          this._didUserInput = true;
        }
        writeSync(e3, t3) {
          if (t3 !== undefined && this._syncCalls > t3)
            return void (this._syncCalls = 0);
          if (this._pendingData += e3.length, this._writeBuffer.push(e3), this._callbacks.push(undefined), this._syncCalls++, this._isSyncWriting)
            return;
          let i3;
          for (this._isSyncWriting = true;i3 = this._writeBuffer.shift(); ) {
            this._action(i3);
            const e4 = this._callbacks.shift();
            e4 && e4();
          }
          this._pendingData = 0, this._bufferOffset = 2147483647, this._isSyncWriting = false, this._syncCalls = 0;
        }
        write(e3, t3) {
          if (this._pendingData > 50000000)
            throw new Error("write data discarded, use flow control to avoid losing data");
          if (!this._writeBuffer.length) {
            if (this._bufferOffset = 0, this._didUserInput)
              return this._didUserInput = false, this._pendingData += e3.length, this._writeBuffer.push(e3), this._callbacks.push(t3), void this._innerWrite();
            setTimeout(() => this._innerWrite());
          }
          this._pendingData += e3.length, this._writeBuffer.push(e3), this._callbacks.push(t3);
        }
        _innerWrite(e3 = 0, t3 = true) {
          const i3 = e3 || Date.now();
          for (;this._writeBuffer.length > this._bufferOffset; ) {
            const e4 = this._writeBuffer[this._bufferOffset], s3 = this._action(e4, t3);
            if (s3) {
              const e5 = (e6) => Date.now() - i3 >= 12 ? setTimeout(() => this._innerWrite(0, e6)) : this._innerWrite(i3, e6);
              return void s3.catch((e6) => (queueMicrotask(() => {
                throw e6;
              }), Promise.resolve(false))).then(e5);
            }
            const r2 = this._callbacks[this._bufferOffset];
            if (r2 && r2(), this._bufferOffset++, this._pendingData -= e4.length, Date.now() - i3 >= 12)
              break;
          }
          this._writeBuffer.length > this._bufferOffset ? (this._bufferOffset > 50 && (this._writeBuffer = this._writeBuffer.slice(this._bufferOffset), this._callbacks = this._callbacks.slice(this._bufferOffset), this._bufferOffset = 0), setTimeout(() => this._innerWrite())) : (this._writeBuffer.length = 0, this._callbacks.length = 0, this._pendingData = 0, this._bufferOffset = 0), this._onWriteParsed.fire();
        }
      }
      t2.WriteBuffer = n;
    }, 5941: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.toRgbString = t2.parseColor = undefined;
      const i2 = /^([\da-f])\/([\da-f])\/([\da-f])$|^([\da-f]{2})\/([\da-f]{2})\/([\da-f]{2})$|^([\da-f]{3})\/([\da-f]{3})\/([\da-f]{3})$|^([\da-f]{4})\/([\da-f]{4})\/([\da-f]{4})$/, s2 = /^[\da-f]+$/;
      function r(e3, t3) {
        const i3 = e3.toString(16), s3 = i3.length < 2 ? "0" + i3 : i3;
        switch (t3) {
          case 4:
            return i3[0];
          case 8:
            return s3;
          case 12:
            return (s3 + s3).slice(0, 3);
          default:
            return s3 + s3;
        }
      }
      t2.parseColor = function(e3) {
        if (!e3)
          return;
        let t3 = e3.toLowerCase();
        if (t3.indexOf("rgb:") === 0) {
          t3 = t3.slice(4);
          const e4 = i2.exec(t3);
          if (e4) {
            const t4 = e4[1] ? 15 : e4[4] ? 255 : e4[7] ? 4095 : 65535;
            return [Math.round(parseInt(e4[1] || e4[4] || e4[7] || e4[10], 16) / t4 * 255), Math.round(parseInt(e4[2] || e4[5] || e4[8] || e4[11], 16) / t4 * 255), Math.round(parseInt(e4[3] || e4[6] || e4[9] || e4[12], 16) / t4 * 255)];
          }
        } else if (t3.indexOf("#") === 0 && (t3 = t3.slice(1), s2.exec(t3) && [3, 6, 9, 12].includes(t3.length))) {
          const e4 = t3.length / 3, i3 = [0, 0, 0];
          for (let s3 = 0;s3 < 3; ++s3) {
            const r2 = parseInt(t3.slice(e4 * s3, e4 * s3 + e4), 16);
            i3[s3] = e4 === 1 ? r2 << 4 : e4 === 2 ? r2 : e4 === 3 ? r2 >> 4 : r2 >> 8;
          }
          return i3;
        }
      }, t2.toRgbString = function(e3, t3 = 16) {
        const [i3, s3, n] = e3;
        return `rgb:${r(i3, t3)}/${r(s3, t3)}/${r(n, t3)}`;
      };
    }, 5770: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.PAYLOAD_LIMIT = undefined, t2.PAYLOAD_LIMIT = 1e7;
    }, 6351: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.DcsHandler = t2.DcsParser = undefined;
      const s2 = i2(482), r = i2(8742), n = i2(5770), o = [];
      t2.DcsParser = class {
        constructor() {
          this._handlers = Object.create(null), this._active = o, this._ident = 0, this._handlerFb = () => {
          }, this._stack = { paused: false, loopPosition: 0, fallThrough: false };
        }
        dispose() {
          this._handlers = Object.create(null), this._handlerFb = () => {
          }, this._active = o;
        }
        registerHandler(e3, t3) {
          this._handlers[e3] === undefined && (this._handlers[e3] = []);
          const i3 = this._handlers[e3];
          return i3.push(t3), { dispose: () => {
            const e4 = i3.indexOf(t3);
            e4 !== -1 && i3.splice(e4, 1);
          } };
        }
        clearHandler(e3) {
          this._handlers[e3] && delete this._handlers[e3];
        }
        setHandlerFallback(e3) {
          this._handlerFb = e3;
        }
        reset() {
          if (this._active.length)
            for (let e3 = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1;e3 >= 0; --e3)
              this._active[e3].unhook(false);
          this._stack.paused = false, this._active = o, this._ident = 0;
        }
        hook(e3, t3) {
          if (this.reset(), this._ident = e3, this._active = this._handlers[e3] || o, this._active.length)
            for (let e4 = this._active.length - 1;e4 >= 0; e4--)
              this._active[e4].hook(t3);
          else
            this._handlerFb(this._ident, "HOOK", t3);
        }
        put(e3, t3, i3) {
          if (this._active.length)
            for (let s3 = this._active.length - 1;s3 >= 0; s3--)
              this._active[s3].put(e3, t3, i3);
          else
            this._handlerFb(this._ident, "PUT", (0, s2.utf32ToString)(e3, t3, i3));
        }
        unhook(e3, t3 = true) {
          if (this._active.length) {
            let i3 = false, s3 = this._active.length - 1, r2 = false;
            if (this._stack.paused && (s3 = this._stack.loopPosition - 1, i3 = t3, r2 = this._stack.fallThrough, this._stack.paused = false), !r2 && i3 === false) {
              for (;s3 >= 0 && (i3 = this._active[s3].unhook(e3), i3 !== true); s3--)
                if (i3 instanceof Promise)
                  return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = false, i3;
              s3--;
            }
            for (;s3 >= 0; s3--)
              if (i3 = this._active[s3].unhook(false), i3 instanceof Promise)
                return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = true, i3;
          } else
            this._handlerFb(this._ident, "UNHOOK", e3);
          this._active = o, this._ident = 0;
        }
      };
      const a = new r.Params;
      a.addParam(0), t2.DcsHandler = class {
        constructor(e3) {
          this._handler = e3, this._data = "", this._params = a, this._hitLimit = false;
        }
        hook(e3) {
          this._params = e3.length > 1 || e3.params[0] ? e3.clone() : a, this._data = "", this._hitLimit = false;
        }
        put(e3, t3, i3) {
          this._hitLimit || (this._data += (0, s2.utf32ToString)(e3, t3, i3), this._data.length > n.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = true));
        }
        unhook(e3) {
          let t3 = false;
          if (this._hitLimit)
            t3 = false;
          else if (e3 && (t3 = this._handler(this._data, this._params), t3 instanceof Promise))
            return t3.then((e4) => (this._params = a, this._data = "", this._hitLimit = false, e4));
          return this._params = a, this._data = "", this._hitLimit = false, t3;
        }
      };
    }, 2015: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.EscapeSequenceParser = t2.VT500_TRANSITION_TABLE = t2.TransitionTable = undefined;
      const s2 = i2(844), r = i2(8742), n = i2(6242), o = i2(6351);

      class a {
        constructor(e3) {
          this.table = new Uint8Array(e3);
        }
        setDefault(e3, t3) {
          this.table.fill(e3 << 4 | t3);
        }
        add(e3, t3, i3, s3) {
          this.table[t3 << 8 | e3] = i3 << 4 | s3;
        }
        addMany(e3, t3, i3, s3) {
          for (let r2 = 0;r2 < e3.length; r2++)
            this.table[t3 << 8 | e3[r2]] = i3 << 4 | s3;
        }
      }
      t2.TransitionTable = a;
      const h = 160;
      t2.VT500_TRANSITION_TABLE = function() {
        const e3 = new a(4095), t3 = Array.apply(null, Array(256)).map((e4, t4) => t4), i3 = (e4, i4) => t3.slice(e4, i4), s3 = i3(32, 127), r2 = i3(0, 24);
        r2.push(25), r2.push.apply(r2, i3(28, 32));
        const n2 = i3(0, 14);
        let o2;
        for (o2 in e3.setDefault(1, 0), e3.addMany(s3, 0, 2, 0), n2)
          e3.addMany([24, 26, 153, 154], o2, 3, 0), e3.addMany(i3(128, 144), o2, 3, 0), e3.addMany(i3(144, 152), o2, 3, 0), e3.add(156, o2, 0, 0), e3.add(27, o2, 11, 1), e3.add(157, o2, 4, 8), e3.addMany([152, 158, 159], o2, 0, 7), e3.add(155, o2, 11, 3), e3.add(144, o2, 11, 9);
        return e3.addMany(r2, 0, 3, 0), e3.addMany(r2, 1, 3, 1), e3.add(127, 1, 0, 1), e3.addMany(r2, 8, 0, 8), e3.addMany(r2, 3, 3, 3), e3.add(127, 3, 0, 3), e3.addMany(r2, 4, 3, 4), e3.add(127, 4, 0, 4), e3.addMany(r2, 6, 3, 6), e3.addMany(r2, 5, 3, 5), e3.add(127, 5, 0, 5), e3.addMany(r2, 2, 3, 2), e3.add(127, 2, 0, 2), e3.add(93, 1, 4, 8), e3.addMany(s3, 8, 5, 8), e3.add(127, 8, 5, 8), e3.addMany([156, 27, 24, 26, 7], 8, 6, 0), e3.addMany(i3(28, 32), 8, 0, 8), e3.addMany([88, 94, 95], 1, 0, 7), e3.addMany(s3, 7, 0, 7), e3.addMany(r2, 7, 0, 7), e3.add(156, 7, 0, 0), e3.add(127, 7, 0, 7), e3.add(91, 1, 11, 3), e3.addMany(i3(64, 127), 3, 7, 0), e3.addMany(i3(48, 60), 3, 8, 4), e3.addMany([60, 61, 62, 63], 3, 9, 4), e3.addMany(i3(48, 60), 4, 8, 4), e3.addMany(i3(64, 127), 4, 7, 0), e3.addMany([60, 61, 62, 63], 4, 0, 6), e3.addMany(i3(32, 64), 6, 0, 6), e3.add(127, 6, 0, 6), e3.addMany(i3(64, 127), 6, 0, 0), e3.addMany(i3(32, 48), 3, 9, 5), e3.addMany(i3(32, 48), 5, 9, 5), e3.addMany(i3(48, 64), 5, 0, 6), e3.addMany(i3(64, 127), 5, 7, 0), e3.addMany(i3(32, 48), 4, 9, 5), e3.addMany(i3(32, 48), 1, 9, 2), e3.addMany(i3(32, 48), 2, 9, 2), e3.addMany(i3(48, 127), 2, 10, 0), e3.addMany(i3(48, 80), 1, 10, 0), e3.addMany(i3(81, 88), 1, 10, 0), e3.addMany([89, 90, 92], 1, 10, 0), e3.addMany(i3(96, 127), 1, 10, 0), e3.add(80, 1, 11, 9), e3.addMany(r2, 9, 0, 9), e3.add(127, 9, 0, 9), e3.addMany(i3(28, 32), 9, 0, 9), e3.addMany(i3(32, 48), 9, 9, 12), e3.addMany(i3(48, 60), 9, 8, 10), e3.addMany([60, 61, 62, 63], 9, 9, 10), e3.addMany(r2, 11, 0, 11), e3.addMany(i3(32, 128), 11, 0, 11), e3.addMany(i3(28, 32), 11, 0, 11), e3.addMany(r2, 10, 0, 10), e3.add(127, 10, 0, 10), e3.addMany(i3(28, 32), 10, 0, 10), e3.addMany(i3(48, 60), 10, 8, 10), e3.addMany([60, 61, 62, 63], 10, 0, 11), e3.addMany(i3(32, 48), 10, 9, 12), e3.addMany(r2, 12, 0, 12), e3.add(127, 12, 0, 12), e3.addMany(i3(28, 32), 12, 0, 12), e3.addMany(i3(32, 48), 12, 9, 12), e3.addMany(i3(48, 64), 12, 0, 11), e3.addMany(i3(64, 127), 12, 12, 13), e3.addMany(i3(64, 127), 10, 12, 13), e3.addMany(i3(64, 127), 9, 12, 13), e3.addMany(r2, 13, 13, 13), e3.addMany(s3, 13, 13, 13), e3.add(127, 13, 0, 13), e3.addMany([27, 156, 24, 26], 13, 14, 0), e3.add(h, 0, 2, 0), e3.add(h, 8, 5, 8), e3.add(h, 6, 0, 6), e3.add(h, 11, 0, 11), e3.add(h, 13, 13, 13), e3;
      }();

      class c extends s2.Disposable {
        constructor(e3 = t2.VT500_TRANSITION_TABLE) {
          super(), this._transitions = e3, this._parseStack = { state: 0, handlers: [], handlerPos: 0, transition: 0, chunkPos: 0 }, this.initialState = 0, this.currentState = this.initialState, this._params = new r.Params, this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0, this._printHandlerFb = (e4, t3, i3) => {
          }, this._executeHandlerFb = (e4) => {
          }, this._csiHandlerFb = (e4, t3) => {
          }, this._escHandlerFb = (e4) => {
          }, this._errorHandlerFb = (e4) => e4, this._printHandler = this._printHandlerFb, this._executeHandlers = Object.create(null), this._csiHandlers = Object.create(null), this._escHandlers = Object.create(null), this.register((0, s2.toDisposable)(() => {
            this._csiHandlers = Object.create(null), this._executeHandlers = Object.create(null), this._escHandlers = Object.create(null);
          })), this._oscParser = this.register(new n.OscParser), this._dcsParser = this.register(new o.DcsParser), this._errorHandler = this._errorHandlerFb, this.registerEscHandler({ final: "\\" }, () => true);
        }
        _identifier(e3, t3 = [64, 126]) {
          let i3 = 0;
          if (e3.prefix) {
            if (e3.prefix.length > 1)
              throw new Error("only one byte as prefix supported");
            if (i3 = e3.prefix.charCodeAt(0), i3 && 60 > i3 || i3 > 63)
              throw new Error("prefix must be in range 0x3c .. 0x3f");
          }
          if (e3.intermediates) {
            if (e3.intermediates.length > 2)
              throw new Error("only two bytes as intermediates are supported");
            for (let t4 = 0;t4 < e3.intermediates.length; ++t4) {
              const s4 = e3.intermediates.charCodeAt(t4);
              if (32 > s4 || s4 > 47)
                throw new Error("intermediate must be in range 0x20 .. 0x2f");
              i3 <<= 8, i3 |= s4;
            }
          }
          if (e3.final.length !== 1)
            throw new Error("final must be a single byte");
          const s3 = e3.final.charCodeAt(0);
          if (t3[0] > s3 || s3 > t3[1])
            throw new Error(`final must be in range ${t3[0]} .. ${t3[1]}`);
          return i3 <<= 8, i3 |= s3, i3;
        }
        identToString(e3) {
          const t3 = [];
          for (;e3; )
            t3.push(String.fromCharCode(255 & e3)), e3 >>= 8;
          return t3.reverse().join("");
        }
        setPrintHandler(e3) {
          this._printHandler = e3;
        }
        clearPrintHandler() {
          this._printHandler = this._printHandlerFb;
        }
        registerEscHandler(e3, t3) {
          const i3 = this._identifier(e3, [48, 126]);
          this._escHandlers[i3] === undefined && (this._escHandlers[i3] = []);
          const s3 = this._escHandlers[i3];
          return s3.push(t3), { dispose: () => {
            const e4 = s3.indexOf(t3);
            e4 !== -1 && s3.splice(e4, 1);
          } };
        }
        clearEscHandler(e3) {
          this._escHandlers[this._identifier(e3, [48, 126])] && delete this._escHandlers[this._identifier(e3, [48, 126])];
        }
        setEscHandlerFallback(e3) {
          this._escHandlerFb = e3;
        }
        setExecuteHandler(e3, t3) {
          this._executeHandlers[e3.charCodeAt(0)] = t3;
        }
        clearExecuteHandler(e3) {
          this._executeHandlers[e3.charCodeAt(0)] && delete this._executeHandlers[e3.charCodeAt(0)];
        }
        setExecuteHandlerFallback(e3) {
          this._executeHandlerFb = e3;
        }
        registerCsiHandler(e3, t3) {
          const i3 = this._identifier(e3);
          this._csiHandlers[i3] === undefined && (this._csiHandlers[i3] = []);
          const s3 = this._csiHandlers[i3];
          return s3.push(t3), { dispose: () => {
            const e4 = s3.indexOf(t3);
            e4 !== -1 && s3.splice(e4, 1);
          } };
        }
        clearCsiHandler(e3) {
          this._csiHandlers[this._identifier(e3)] && delete this._csiHandlers[this._identifier(e3)];
        }
        setCsiHandlerFallback(e3) {
          this._csiHandlerFb = e3;
        }
        registerDcsHandler(e3, t3) {
          return this._dcsParser.registerHandler(this._identifier(e3), t3);
        }
        clearDcsHandler(e3) {
          this._dcsParser.clearHandler(this._identifier(e3));
        }
        setDcsHandlerFallback(e3) {
          this._dcsParser.setHandlerFallback(e3);
        }
        registerOscHandler(e3, t3) {
          return this._oscParser.registerHandler(e3, t3);
        }
        clearOscHandler(e3) {
          this._oscParser.clearHandler(e3);
        }
        setOscHandlerFallback(e3) {
          this._oscParser.setHandlerFallback(e3);
        }
        setErrorHandler(e3) {
          this._errorHandler = e3;
        }
        clearErrorHandler() {
          this._errorHandler = this._errorHandlerFb;
        }
        reset() {
          this.currentState = this.initialState, this._oscParser.reset(), this._dcsParser.reset(), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0, this._parseStack.state !== 0 && (this._parseStack.state = 2, this._parseStack.handlers = []);
        }
        _preserveStack(e3, t3, i3, s3, r2) {
          this._parseStack.state = e3, this._parseStack.handlers = t3, this._parseStack.handlerPos = i3, this._parseStack.transition = s3, this._parseStack.chunkPos = r2;
        }
        parse(e3, t3, i3) {
          let s3, r2 = 0, n2 = 0, o2 = 0;
          if (this._parseStack.state)
            if (this._parseStack.state === 2)
              this._parseStack.state = 0, o2 = this._parseStack.chunkPos + 1;
            else {
              if (i3 === undefined || this._parseStack.state === 1)
                throw this._parseStack.state = 1, new Error("improper continuation due to previous async handler, giving up parsing");
              const t4 = this._parseStack.handlers;
              let n3 = this._parseStack.handlerPos - 1;
              switch (this._parseStack.state) {
                case 3:
                  if (i3 === false && n3 > -1) {
                    for (;n3 >= 0 && (s3 = t4[n3](this._params), s3 !== true); n3--)
                      if (s3 instanceof Promise)
                        return this._parseStack.handlerPos = n3, s3;
                  }
                  this._parseStack.handlers = [];
                  break;
                case 4:
                  if (i3 === false && n3 > -1) {
                    for (;n3 >= 0 && (s3 = t4[n3](), s3 !== true); n3--)
                      if (s3 instanceof Promise)
                        return this._parseStack.handlerPos = n3, s3;
                  }
                  this._parseStack.handlers = [];
                  break;
                case 6:
                  if (r2 = e3[this._parseStack.chunkPos], s3 = this._dcsParser.unhook(r2 !== 24 && r2 !== 26, i3), s3)
                    return s3;
                  r2 === 27 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
                  break;
                case 5:
                  if (r2 = e3[this._parseStack.chunkPos], s3 = this._oscParser.end(r2 !== 24 && r2 !== 26, i3), s3)
                    return s3;
                  r2 === 27 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
              }
              this._parseStack.state = 0, o2 = this._parseStack.chunkPos + 1, this.precedingJoinState = 0, this.currentState = 15 & this._parseStack.transition;
            }
          for (let i4 = o2;i4 < t3; ++i4) {
            switch (r2 = e3[i4], n2 = this._transitions.table[this.currentState << 8 | (r2 < 160 ? r2 : h)], n2 >> 4) {
              case 2:
                for (let s4 = i4 + 1;; ++s4) {
                  if (s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h) {
                    this._printHandler(e3, i4, s4), i4 = s4 - 1;
                    break;
                  }
                  if (++s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h) {
                    this._printHandler(e3, i4, s4), i4 = s4 - 1;
                    break;
                  }
                  if (++s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h) {
                    this._printHandler(e3, i4, s4), i4 = s4 - 1;
                    break;
                  }
                  if (++s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h) {
                    this._printHandler(e3, i4, s4), i4 = s4 - 1;
                    break;
                  }
                }
                break;
              case 3:
                this._executeHandlers[r2] ? this._executeHandlers[r2]() : this._executeHandlerFb(r2), this.precedingJoinState = 0;
                break;
              case 0:
                break;
              case 1:
                if (this._errorHandler({ position: i4, code: r2, currentState: this.currentState, collect: this._collect, params: this._params, abort: false }).abort)
                  return;
                break;
              case 7:
                const o3 = this._csiHandlers[this._collect << 8 | r2];
                let a2 = o3 ? o3.length - 1 : -1;
                for (;a2 >= 0 && (s3 = o3[a2](this._params), s3 !== true); a2--)
                  if (s3 instanceof Promise)
                    return this._preserveStack(3, o3, a2, n2, i4), s3;
                a2 < 0 && this._csiHandlerFb(this._collect << 8 | r2, this._params), this.precedingJoinState = 0;
                break;
              case 8:
                do {
                  switch (r2) {
                    case 59:
                      this._params.addParam(0);
                      break;
                    case 58:
                      this._params.addSubParam(-1);
                      break;
                    default:
                      this._params.addDigit(r2 - 48);
                  }
                } while (++i4 < t3 && (r2 = e3[i4]) > 47 && r2 < 60);
                i4--;
                break;
              case 9:
                this._collect <<= 8, this._collect |= r2;
                break;
              case 10:
                const c2 = this._escHandlers[this._collect << 8 | r2];
                let l = c2 ? c2.length - 1 : -1;
                for (;l >= 0 && (s3 = c2[l](), s3 !== true); l--)
                  if (s3 instanceof Promise)
                    return this._preserveStack(4, c2, l, n2, i4), s3;
                l < 0 && this._escHandlerFb(this._collect << 8 | r2), this.precedingJoinState = 0;
                break;
              case 11:
                this._params.reset(), this._params.addParam(0), this._collect = 0;
                break;
              case 12:
                this._dcsParser.hook(this._collect << 8 | r2, this._params);
                break;
              case 13:
                for (let s4 = i4 + 1;; ++s4)
                  if (s4 >= t3 || (r2 = e3[s4]) === 24 || r2 === 26 || r2 === 27 || r2 > 127 && r2 < h) {
                    this._dcsParser.put(e3, i4, s4), i4 = s4 - 1;
                    break;
                  }
                break;
              case 14:
                if (s3 = this._dcsParser.unhook(r2 !== 24 && r2 !== 26), s3)
                  return this._preserveStack(6, [], 0, n2, i4), s3;
                r2 === 27 && (n2 |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0;
                break;
              case 4:
                this._oscParser.start();
                break;
              case 5:
                for (let s4 = i4 + 1;; s4++)
                  if (s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 127 && r2 < h) {
                    this._oscParser.put(e3, i4, s4), i4 = s4 - 1;
                    break;
                  }
                break;
              case 6:
                if (s3 = this._oscParser.end(r2 !== 24 && r2 !== 26), s3)
                  return this._preserveStack(5, [], 0, n2, i4), s3;
                r2 === 27 && (n2 |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0;
            }
            this.currentState = 15 & n2;
          }
        }
      }
      t2.EscapeSequenceParser = c;
    }, 6242: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.OscHandler = t2.OscParser = undefined;
      const s2 = i2(5770), r = i2(482), n = [];
      t2.OscParser = class {
        constructor() {
          this._state = 0, this._active = n, this._id = -1, this._handlers = Object.create(null), this._handlerFb = () => {
          }, this._stack = { paused: false, loopPosition: 0, fallThrough: false };
        }
        registerHandler(e3, t3) {
          this._handlers[e3] === undefined && (this._handlers[e3] = []);
          const i3 = this._handlers[e3];
          return i3.push(t3), { dispose: () => {
            const e4 = i3.indexOf(t3);
            e4 !== -1 && i3.splice(e4, 1);
          } };
        }
        clearHandler(e3) {
          this._handlers[e3] && delete this._handlers[e3];
        }
        setHandlerFallback(e3) {
          this._handlerFb = e3;
        }
        dispose() {
          this._handlers = Object.create(null), this._handlerFb = () => {
          }, this._active = n;
        }
        reset() {
          if (this._state === 2)
            for (let e3 = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1;e3 >= 0; --e3)
              this._active[e3].end(false);
          this._stack.paused = false, this._active = n, this._id = -1, this._state = 0;
        }
        _start() {
          if (this._active = this._handlers[this._id] || n, this._active.length)
            for (let e3 = this._active.length - 1;e3 >= 0; e3--)
              this._active[e3].start();
          else
            this._handlerFb(this._id, "START");
        }
        _put(e3, t3, i3) {
          if (this._active.length)
            for (let s3 = this._active.length - 1;s3 >= 0; s3--)
              this._active[s3].put(e3, t3, i3);
          else
            this._handlerFb(this._id, "PUT", (0, r.utf32ToString)(e3, t3, i3));
        }
        start() {
          this.reset(), this._state = 1;
        }
        put(e3, t3, i3) {
          if (this._state !== 3) {
            if (this._state === 1)
              for (;t3 < i3; ) {
                const i4 = e3[t3++];
                if (i4 === 59) {
                  this._state = 2, this._start();
                  break;
                }
                if (i4 < 48 || 57 < i4)
                  return void (this._state = 3);
                this._id === -1 && (this._id = 0), this._id = 10 * this._id + i4 - 48;
              }
            this._state === 2 && i3 - t3 > 0 && this._put(e3, t3, i3);
          }
        }
        end(e3, t3 = true) {
          if (this._state !== 0) {
            if (this._state !== 3)
              if (this._state === 1 && this._start(), this._active.length) {
                let i3 = false, s3 = this._active.length - 1, r2 = false;
                if (this._stack.paused && (s3 = this._stack.loopPosition - 1, i3 = t3, r2 = this._stack.fallThrough, this._stack.paused = false), !r2 && i3 === false) {
                  for (;s3 >= 0 && (i3 = this._active[s3].end(e3), i3 !== true); s3--)
                    if (i3 instanceof Promise)
                      return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = false, i3;
                  s3--;
                }
                for (;s3 >= 0; s3--)
                  if (i3 = this._active[s3].end(false), i3 instanceof Promise)
                    return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = true, i3;
              } else
                this._handlerFb(this._id, "END", e3);
            this._active = n, this._id = -1, this._state = 0;
          }
        }
      }, t2.OscHandler = class {
        constructor(e3) {
          this._handler = e3, this._data = "", this._hitLimit = false;
        }
        start() {
          this._data = "", this._hitLimit = false;
        }
        put(e3, t3, i3) {
          this._hitLimit || (this._data += (0, r.utf32ToString)(e3, t3, i3), this._data.length > s2.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = true));
        }
        end(e3) {
          let t3 = false;
          if (this._hitLimit)
            t3 = false;
          else if (e3 && (t3 = this._handler(this._data), t3 instanceof Promise))
            return t3.then((e4) => (this._data = "", this._hitLimit = false, e4));
          return this._data = "", this._hitLimit = false, t3;
        }
      };
    }, 8742: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.Params = undefined;
      const i2 = 2147483647;

      class s2 {
        static fromArray(e3) {
          const t3 = new s2;
          if (!e3.length)
            return t3;
          for (let i3 = Array.isArray(e3[0]) ? 1 : 0;i3 < e3.length; ++i3) {
            const s3 = e3[i3];
            if (Array.isArray(s3))
              for (let e4 = 0;e4 < s3.length; ++e4)
                t3.addSubParam(s3[e4]);
            else
              t3.addParam(s3);
          }
          return t3;
        }
        constructor(e3 = 32, t3 = 32) {
          if (this.maxLength = e3, this.maxSubParamsLength = t3, t3 > 256)
            throw new Error("maxSubParamsLength must not be greater than 256");
          this.params = new Int32Array(e3), this.length = 0, this._subParams = new Int32Array(t3), this._subParamsLength = 0, this._subParamsIdx = new Uint16Array(e3), this._rejectDigits = false, this._rejectSubDigits = false, this._digitIsSub = false;
        }
        clone() {
          const e3 = new s2(this.maxLength, this.maxSubParamsLength);
          return e3.params.set(this.params), e3.length = this.length, e3._subParams.set(this._subParams), e3._subParamsLength = this._subParamsLength, e3._subParamsIdx.set(this._subParamsIdx), e3._rejectDigits = this._rejectDigits, e3._rejectSubDigits = this._rejectSubDigits, e3._digitIsSub = this._digitIsSub, e3;
        }
        toArray() {
          const e3 = [];
          for (let t3 = 0;t3 < this.length; ++t3) {
            e3.push(this.params[t3]);
            const i3 = this._subParamsIdx[t3] >> 8, s3 = 255 & this._subParamsIdx[t3];
            s3 - i3 > 0 && e3.push(Array.prototype.slice.call(this._subParams, i3, s3));
          }
          return e3;
        }
        reset() {
          this.length = 0, this._subParamsLength = 0, this._rejectDigits = false, this._rejectSubDigits = false, this._digitIsSub = false;
        }
        addParam(e3) {
          if (this._digitIsSub = false, this.length >= this.maxLength)
            this._rejectDigits = true;
          else {
            if (e3 < -1)
              throw new Error("values lesser than -1 are not allowed");
            this._subParamsIdx[this.length] = this._subParamsLength << 8 | this._subParamsLength, this.params[this.length++] = e3 > i2 ? i2 : e3;
          }
        }
        addSubParam(e3) {
          if (this._digitIsSub = true, this.length)
            if (this._rejectDigits || this._subParamsLength >= this.maxSubParamsLength)
              this._rejectSubDigits = true;
            else {
              if (e3 < -1)
                throw new Error("values lesser than -1 are not allowed");
              this._subParams[this._subParamsLength++] = e3 > i2 ? i2 : e3, this._subParamsIdx[this.length - 1]++;
            }
        }
        hasSubParams(e3) {
          return (255 & this._subParamsIdx[e3]) - (this._subParamsIdx[e3] >> 8) > 0;
        }
        getSubParams(e3) {
          const t3 = this._subParamsIdx[e3] >> 8, i3 = 255 & this._subParamsIdx[e3];
          return i3 - t3 > 0 ? this._subParams.subarray(t3, i3) : null;
        }
        getSubParamsAll() {
          const e3 = {};
          for (let t3 = 0;t3 < this.length; ++t3) {
            const i3 = this._subParamsIdx[t3] >> 8, s3 = 255 & this._subParamsIdx[t3];
            s3 - i3 > 0 && (e3[t3] = this._subParams.slice(i3, s3));
          }
          return e3;
        }
        addDigit(e3) {
          let t3;
          if (this._rejectDigits || !(t3 = this._digitIsSub ? this._subParamsLength : this.length) || this._digitIsSub && this._rejectSubDigits)
            return;
          const s3 = this._digitIsSub ? this._subParams : this.params, r = s3[t3 - 1];
          s3[t3 - 1] = ~r ? Math.min(10 * r + e3, i2) : e3;
        }
      }
      t2.Params = s2;
    }, 5741: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.AddonManager = undefined, t2.AddonManager = class {
        constructor() {
          this._addons = [];
        }
        dispose() {
          for (let e3 = this._addons.length - 1;e3 >= 0; e3--)
            this._addons[e3].instance.dispose();
        }
        loadAddon(e3, t3) {
          const i2 = { instance: t3, dispose: t3.dispose, isDisposed: false };
          this._addons.push(i2), t3.dispose = () => this._wrappedAddonDispose(i2), t3.activate(e3);
        }
        _wrappedAddonDispose(e3) {
          if (e3.isDisposed)
            return;
          let t3 = -1;
          for (let i2 = 0;i2 < this._addons.length; i2++)
            if (this._addons[i2] === e3) {
              t3 = i2;
              break;
            }
          if (t3 === -1)
            throw new Error("Could not dispose an addon that has not been loaded");
          e3.isDisposed = true, e3.dispose.apply(e3.instance), this._addons.splice(t3, 1);
        }
      };
    }, 8771: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferApiView = undefined;
      const s2 = i2(3785), r = i2(511);
      t2.BufferApiView = class {
        constructor(e3, t3) {
          this._buffer = e3, this.type = t3;
        }
        init(e3) {
          return this._buffer = e3, this;
        }
        get cursorY() {
          return this._buffer.y;
        }
        get cursorX() {
          return this._buffer.x;
        }
        get viewportY() {
          return this._buffer.ydisp;
        }
        get baseY() {
          return this._buffer.ybase;
        }
        get length() {
          return this._buffer.lines.length;
        }
        getLine(e3) {
          const t3 = this._buffer.lines.get(e3);
          if (t3)
            return new s2.BufferLineApiView(t3);
        }
        getNullCell() {
          return new r.CellData;
        }
      };
    }, 3785: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferLineApiView = undefined;
      const s2 = i2(511);
      t2.BufferLineApiView = class {
        constructor(e3) {
          this._line = e3;
        }
        get isWrapped() {
          return this._line.isWrapped;
        }
        get length() {
          return this._line.length;
        }
        getCell(e3, t3) {
          if (!(e3 < 0 || e3 >= this._line.length))
            return t3 ? (this._line.loadCell(e3, t3), t3) : this._line.loadCell(e3, new s2.CellData);
        }
        translateToString(e3, t3, i3) {
          return this._line.translateToString(e3, t3, i3);
        }
      };
    }, 8285: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferNamespaceApi = undefined;
      const s2 = i2(8771), r = i2(8460), n = i2(844);

      class o extends n.Disposable {
        constructor(e3) {
          super(), this._core = e3, this._onBufferChange = this.register(new r.EventEmitter), this.onBufferChange = this._onBufferChange.event, this._normal = new s2.BufferApiView(this._core.buffers.normal, "normal"), this._alternate = new s2.BufferApiView(this._core.buffers.alt, "alternate"), this._core.buffers.onBufferActivate(() => this._onBufferChange.fire(this.active));
        }
        get active() {
          if (this._core.buffers.active === this._core.buffers.normal)
            return this.normal;
          if (this._core.buffers.active === this._core.buffers.alt)
            return this.alternate;
          throw new Error("Active buffer is neither normal nor alternate");
        }
        get normal() {
          return this._normal.init(this._core.buffers.normal);
        }
        get alternate() {
          return this._alternate.init(this._core.buffers.alt);
        }
      }
      t2.BufferNamespaceApi = o;
    }, 7975: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.ParserApi = undefined, t2.ParserApi = class {
        constructor(e3) {
          this._core = e3;
        }
        registerCsiHandler(e3, t3) {
          return this._core.registerCsiHandler(e3, (e4) => t3(e4.toArray()));
        }
        addCsiHandler(e3, t3) {
          return this.registerCsiHandler(e3, t3);
        }
        registerDcsHandler(e3, t3) {
          return this._core.registerDcsHandler(e3, (e4, i2) => t3(e4, i2.toArray()));
        }
        addDcsHandler(e3, t3) {
          return this.registerDcsHandler(e3, t3);
        }
        registerEscHandler(e3, t3) {
          return this._core.registerEscHandler(e3, t3);
        }
        addEscHandler(e3, t3) {
          return this.registerEscHandler(e3, t3);
        }
        registerOscHandler(e3, t3) {
          return this._core.registerOscHandler(e3, t3);
        }
        addOscHandler(e3, t3) {
          return this.registerOscHandler(e3, t3);
        }
      };
    }, 7090: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.UnicodeApi = undefined, t2.UnicodeApi = class {
        constructor(e3) {
          this._core = e3;
        }
        register(e3) {
          this._core.unicodeService.register(e3);
        }
        get versions() {
          return this._core.unicodeService.versions;
        }
        get activeVersion() {
          return this._core.unicodeService.activeVersion;
        }
        set activeVersion(e3) {
          this._core.unicodeService.activeVersion = e3;
        }
      };
    }, 744: function(e2, t2, i2) {
      var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : s3 === null ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          o2 = Reflect.decorate(e3, t3, i3, s3);
        else
          for (var a2 = e3.length - 1;a2 >= 0; a2--)
            (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i3, s3) {
          t3(i3, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferService = t2.MINIMUM_ROWS = t2.MINIMUM_COLS = undefined;
      const n = i2(8460), o = i2(844), a = i2(5295), h = i2(2585);
      t2.MINIMUM_COLS = 2, t2.MINIMUM_ROWS = 1;
      let c = t2.BufferService = class extends o.Disposable {
        get buffer() {
          return this.buffers.active;
        }
        constructor(e3) {
          super(), this.isUserScrolling = false, this._onResize = this.register(new n.EventEmitter), this.onResize = this._onResize.event, this._onScroll = this.register(new n.EventEmitter), this.onScroll = this._onScroll.event, this.cols = Math.max(e3.rawOptions.cols || 0, t2.MINIMUM_COLS), this.rows = Math.max(e3.rawOptions.rows || 0, t2.MINIMUM_ROWS), this.buffers = this.register(new a.BufferSet(e3, this));
        }
        resize(e3, t3) {
          this.cols = e3, this.rows = t3, this.buffers.resize(e3, t3), this._onResize.fire({ cols: e3, rows: t3 });
        }
        reset() {
          this.buffers.reset(), this.isUserScrolling = false;
        }
        scroll(e3, t3 = false) {
          const i3 = this.buffer;
          let s3;
          s3 = this._cachedBlankLine, s3 && s3.length === this.cols && s3.getFg(0) === e3.fg && s3.getBg(0) === e3.bg || (s3 = i3.getBlankLine(e3, t3), this._cachedBlankLine = s3), s3.isWrapped = t3;
          const r2 = i3.ybase + i3.scrollTop, n2 = i3.ybase + i3.scrollBottom;
          if (i3.scrollTop === 0) {
            const e4 = i3.lines.isFull;
            n2 === i3.lines.length - 1 ? e4 ? i3.lines.recycle().copyFrom(s3) : i3.lines.push(s3.clone()) : i3.lines.splice(n2 + 1, 0, s3.clone()), e4 ? this.isUserScrolling && (i3.ydisp = Math.max(i3.ydisp - 1, 0)) : (i3.ybase++, this.isUserScrolling || i3.ydisp++);
          } else {
            const e4 = n2 - r2 + 1;
            i3.lines.shiftElements(r2 + 1, e4 - 1, -1), i3.lines.set(n2, s3.clone());
          }
          this.isUserScrolling || (i3.ydisp = i3.ybase), this._onScroll.fire(i3.ydisp);
        }
        scrollLines(e3, t3, i3) {
          const s3 = this.buffer;
          if (e3 < 0) {
            if (s3.ydisp === 0)
              return;
            this.isUserScrolling = true;
          } else
            e3 + s3.ydisp >= s3.ybase && (this.isUserScrolling = false);
          const r2 = s3.ydisp;
          s3.ydisp = Math.max(Math.min(s3.ydisp + e3, s3.ybase), 0), r2 !== s3.ydisp && (t3 || this._onScroll.fire(s3.ydisp));
        }
      };
      t2.BufferService = c = s2([r(0, h.IOptionsService)], c);
    }, 7994: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.CharsetService = undefined, t2.CharsetService = class {
        constructor() {
          this.glevel = 0, this._charsets = [];
        }
        reset() {
          this.charset = undefined, this._charsets = [], this.glevel = 0;
        }
        setgLevel(e3) {
          this.glevel = e3, this.charset = this._charsets[e3];
        }
        setgCharset(e3, t3) {
          this._charsets[e3] = t3, this.glevel === e3 && (this.charset = t3);
        }
      };
    }, 1753: function(e2, t2, i2) {
      var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : s3 === null ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          o2 = Reflect.decorate(e3, t3, i3, s3);
        else
          for (var a2 = e3.length - 1;a2 >= 0; a2--)
            (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i3, s3) {
          t3(i3, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.CoreMouseService = undefined;
      const n = i2(2585), o = i2(8460), a = i2(844), h = { NONE: { events: 0, restrict: () => false }, X10: { events: 1, restrict: (e3) => e3.button !== 4 && e3.action === 1 && (e3.ctrl = false, e3.alt = false, e3.shift = false, true) }, VT200: { events: 19, restrict: (e3) => e3.action !== 32 }, DRAG: { events: 23, restrict: (e3) => e3.action !== 32 || e3.button !== 3 }, ANY: { events: 31, restrict: (e3) => true } };
      function c(e3, t3) {
        let i3 = (e3.ctrl ? 16 : 0) | (e3.shift ? 4 : 0) | (e3.alt ? 8 : 0);
        return e3.button === 4 ? (i3 |= 64, i3 |= e3.action) : (i3 |= 3 & e3.button, 4 & e3.button && (i3 |= 64), 8 & e3.button && (i3 |= 128), e3.action === 32 ? i3 |= 32 : e3.action !== 0 || t3 || (i3 |= 3)), i3;
      }
      const l = String.fromCharCode, d = { DEFAULT: (e3) => {
        const t3 = [c(e3, false) + 32, e3.col + 32, e3.row + 32];
        return t3[0] > 255 || t3[1] > 255 || t3[2] > 255 ? "" : `[M${l(t3[0])}${l(t3[1])}${l(t3[2])}`;
      }, SGR: (e3) => {
        const t3 = e3.action === 0 && e3.button !== 4 ? "m" : "M";
        return `[<${c(e3, true)};${e3.col};${e3.row}${t3}`;
      }, SGR_PIXELS: (e3) => {
        const t3 = e3.action === 0 && e3.button !== 4 ? "m" : "M";
        return `[<${c(e3, true)};${e3.x};${e3.y}${t3}`;
      } };
      let _ = t2.CoreMouseService = class extends a.Disposable {
        constructor(e3, t3) {
          super(), this._bufferService = e3, this._coreService = t3, this._protocols = {}, this._encodings = {}, this._activeProtocol = "", this._activeEncoding = "", this._lastEvent = null, this._onProtocolChange = this.register(new o.EventEmitter), this.onProtocolChange = this._onProtocolChange.event;
          for (const e4 of Object.keys(h))
            this.addProtocol(e4, h[e4]);
          for (const e4 of Object.keys(d))
            this.addEncoding(e4, d[e4]);
          this.reset();
        }
        addProtocol(e3, t3) {
          this._protocols[e3] = t3;
        }
        addEncoding(e3, t3) {
          this._encodings[e3] = t3;
        }
        get activeProtocol() {
          return this._activeProtocol;
        }
        get areMouseEventsActive() {
          return this._protocols[this._activeProtocol].events !== 0;
        }
        set activeProtocol(e3) {
          if (!this._protocols[e3])
            throw new Error(`unknown protocol "${e3}"`);
          this._activeProtocol = e3, this._onProtocolChange.fire(this._protocols[e3].events);
        }
        get activeEncoding() {
          return this._activeEncoding;
        }
        set activeEncoding(e3) {
          if (!this._encodings[e3])
            throw new Error(`unknown encoding "${e3}"`);
          this._activeEncoding = e3;
        }
        reset() {
          this.activeProtocol = "NONE", this.activeEncoding = "DEFAULT", this._lastEvent = null;
        }
        triggerMouseEvent(e3) {
          if (e3.col < 0 || e3.col >= this._bufferService.cols || e3.row < 0 || e3.row >= this._bufferService.rows)
            return false;
          if (e3.button === 4 && e3.action === 32)
            return false;
          if (e3.button === 3 && e3.action !== 32)
            return false;
          if (e3.button !== 4 && (e3.action === 2 || e3.action === 3))
            return false;
          if (e3.col++, e3.row++, e3.action === 32 && this._lastEvent && this._equalEvents(this._lastEvent, e3, this._activeEncoding === "SGR_PIXELS"))
            return false;
          if (!this._protocols[this._activeProtocol].restrict(e3))
            return false;
          const t3 = this._encodings[this._activeEncoding](e3);
          return t3 && (this._activeEncoding === "DEFAULT" ? this._coreService.triggerBinaryEvent(t3) : this._coreService.triggerDataEvent(t3, true)), this._lastEvent = e3, true;
        }
        explainEvents(e3) {
          return { down: !!(1 & e3), up: !!(2 & e3), drag: !!(4 & e3), move: !!(8 & e3), wheel: !!(16 & e3) };
        }
        _equalEvents(e3, t3, i3) {
          if (i3) {
            if (e3.x !== t3.x)
              return false;
            if (e3.y !== t3.y)
              return false;
          } else {
            if (e3.col !== t3.col)
              return false;
            if (e3.row !== t3.row)
              return false;
          }
          return e3.button === t3.button && e3.action === t3.action && e3.ctrl === t3.ctrl && e3.alt === t3.alt && e3.shift === t3.shift;
        }
      };
      t2.CoreMouseService = _ = s2([r(0, n.IBufferService), r(1, n.ICoreService)], _);
    }, 6975: function(e2, t2, i2) {
      var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : s3 === null ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          o2 = Reflect.decorate(e3, t3, i3, s3);
        else
          for (var a2 = e3.length - 1;a2 >= 0; a2--)
            (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i3, s3) {
          t3(i3, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.CoreService = undefined;
      const n = i2(1439), o = i2(8460), a = i2(844), h = i2(2585), c = Object.freeze({ insertMode: false }), l = Object.freeze({ applicationCursorKeys: false, applicationKeypad: false, bracketedPasteMode: false, origin: false, reverseWraparound: false, sendFocus: false, wraparound: true });
      let d = t2.CoreService = class extends a.Disposable {
        constructor(e3, t3, i3) {
          super(), this._bufferService = e3, this._logService = t3, this._optionsService = i3, this.isCursorInitialized = false, this.isCursorHidden = false, this._onData = this.register(new o.EventEmitter), this.onData = this._onData.event, this._onUserInput = this.register(new o.EventEmitter), this.onUserInput = this._onUserInput.event, this._onBinary = this.register(new o.EventEmitter), this.onBinary = this._onBinary.event, this._onRequestScrollToBottom = this.register(new o.EventEmitter), this.onRequestScrollToBottom = this._onRequestScrollToBottom.event, this.modes = (0, n.clone)(c), this.decPrivateModes = (0, n.clone)(l);
        }
        reset() {
          this.modes = (0, n.clone)(c), this.decPrivateModes = (0, n.clone)(l);
        }
        triggerDataEvent(e3, t3 = false) {
          if (this._optionsService.rawOptions.disableStdin)
            return;
          const i3 = this._bufferService.buffer;
          t3 && this._optionsService.rawOptions.scrollOnUserInput && i3.ybase !== i3.ydisp && this._onRequestScrollToBottom.fire(), t3 && this._onUserInput.fire(), this._logService.debug(`sending data "${e3}"`, () => e3.split("").map((e4) => e4.charCodeAt(0))), this._onData.fire(e3);
        }
        triggerBinaryEvent(e3) {
          this._optionsService.rawOptions.disableStdin || (this._logService.debug(`sending binary "${e3}"`, () => e3.split("").map((e4) => e4.charCodeAt(0))), this._onBinary.fire(e3));
        }
      };
      t2.CoreService = d = s2([r(0, h.IBufferService), r(1, h.ILogService), r(2, h.IOptionsService)], d);
    }, 9074: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.DecorationService = undefined;
      const s2 = i2(8055), r = i2(8460), n = i2(844), o = i2(6106);
      let a = 0, h = 0;

      class c extends n.Disposable {
        get decorations() {
          return this._decorations.values();
        }
        constructor() {
          super(), this._decorations = new o.SortedList((e3) => e3?.marker.line), this._onDecorationRegistered = this.register(new r.EventEmitter), this.onDecorationRegistered = this._onDecorationRegistered.event, this._onDecorationRemoved = this.register(new r.EventEmitter), this.onDecorationRemoved = this._onDecorationRemoved.event, this.register((0, n.toDisposable)(() => this.reset()));
        }
        registerDecoration(e3) {
          if (e3.marker.isDisposed)
            return;
          const t3 = new l(e3);
          if (t3) {
            const e4 = t3.marker.onDispose(() => t3.dispose());
            t3.onDispose(() => {
              t3 && (this._decorations.delete(t3) && this._onDecorationRemoved.fire(t3), e4.dispose());
            }), this._decorations.insert(t3), this._onDecorationRegistered.fire(t3);
          }
          return t3;
        }
        reset() {
          for (const e3 of this._decorations.values())
            e3.dispose();
          this._decorations.clear();
        }
        *getDecorationsAtCell(e3, t3, i3) {
          let s3 = 0, r2 = 0;
          for (const n2 of this._decorations.getKeyIterator(t3))
            s3 = n2.options.x ?? 0, r2 = s3 + (n2.options.width ?? 1), e3 >= s3 && e3 < r2 && (!i3 || (n2.options.layer ?? "bottom") === i3) && (yield n2);
        }
        forEachDecorationAtCell(e3, t3, i3, s3) {
          this._decorations.forEachByKey(t3, (t4) => {
            a = t4.options.x ?? 0, h = a + (t4.options.width ?? 1), e3 >= a && e3 < h && (!i3 || (t4.options.layer ?? "bottom") === i3) && s3(t4);
          });
        }
      }
      t2.DecorationService = c;

      class l extends n.Disposable {
        get isDisposed() {
          return this._isDisposed;
        }
        get backgroundColorRGB() {
          return this._cachedBg === null && (this.options.backgroundColor ? this._cachedBg = s2.css.toColor(this.options.backgroundColor) : this._cachedBg = undefined), this._cachedBg;
        }
        get foregroundColorRGB() {
          return this._cachedFg === null && (this.options.foregroundColor ? this._cachedFg = s2.css.toColor(this.options.foregroundColor) : this._cachedFg = undefined), this._cachedFg;
        }
        constructor(e3) {
          super(), this.options = e3, this.onRenderEmitter = this.register(new r.EventEmitter), this.onRender = this.onRenderEmitter.event, this._onDispose = this.register(new r.EventEmitter), this.onDispose = this._onDispose.event, this._cachedBg = null, this._cachedFg = null, this.marker = e3.marker, this.options.overviewRulerOptions && !this.options.overviewRulerOptions.position && (this.options.overviewRulerOptions.position = "full");
        }
        dispose() {
          this._onDispose.fire(), super.dispose();
        }
      }
    }, 4348: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.InstantiationService = t2.ServiceCollection = undefined;
      const s2 = i2(2585), r = i2(8343);

      class n {
        constructor(...e3) {
          this._entries = new Map;
          for (const [t3, i3] of e3)
            this.set(t3, i3);
        }
        set(e3, t3) {
          const i3 = this._entries.get(e3);
          return this._entries.set(e3, t3), i3;
        }
        forEach(e3) {
          for (const [t3, i3] of this._entries.entries())
            e3(t3, i3);
        }
        has(e3) {
          return this._entries.has(e3);
        }
        get(e3) {
          return this._entries.get(e3);
        }
      }
      t2.ServiceCollection = n, t2.InstantiationService = class {
        constructor() {
          this._services = new n, this._services.set(s2.IInstantiationService, this);
        }
        setService(e3, t3) {
          this._services.set(e3, t3);
        }
        getService(e3) {
          return this._services.get(e3);
        }
        createInstance(e3, ...t3) {
          const i3 = (0, r.getServiceDependencies)(e3).sort((e4, t4) => e4.index - t4.index), s3 = [];
          for (const t4 of i3) {
            const i4 = this._services.get(t4.id);
            if (!i4)
              throw new Error(`[createInstance] ${e3.name} depends on UNKNOWN service ${t4.id}.`);
            s3.push(i4);
          }
          const n2 = i3.length > 0 ? i3[0].index : t3.length;
          if (t3.length !== n2)
            throw new Error(`[createInstance] First service dependency of ${e3.name} at position ${n2 + 1} conflicts with ${t3.length} static arguments`);
          return new e3(...[...t3, ...s3]);
        }
      };
    }, 7866: function(e2, t2, i2) {
      var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : s3 === null ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          o2 = Reflect.decorate(e3, t3, i3, s3);
        else
          for (var a2 = e3.length - 1;a2 >= 0; a2--)
            (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i3, s3) {
          t3(i3, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.traceCall = t2.setTraceLogger = t2.LogService = undefined;
      const n = i2(844), o = i2(2585), a = { trace: o.LogLevelEnum.TRACE, debug: o.LogLevelEnum.DEBUG, info: o.LogLevelEnum.INFO, warn: o.LogLevelEnum.WARN, error: o.LogLevelEnum.ERROR, off: o.LogLevelEnum.OFF };
      let h, c = t2.LogService = class extends n.Disposable {
        get logLevel() {
          return this._logLevel;
        }
        constructor(e3) {
          super(), this._optionsService = e3, this._logLevel = o.LogLevelEnum.OFF, this._updateLogLevel(), this.register(this._optionsService.onSpecificOptionChange("logLevel", () => this._updateLogLevel())), h = this;
        }
        _updateLogLevel() {
          this._logLevel = a[this._optionsService.rawOptions.logLevel];
        }
        _evalLazyOptionalParams(e3) {
          for (let t3 = 0;t3 < e3.length; t3++)
            typeof e3[t3] == "function" && (e3[t3] = e3[t3]());
        }
        _log(e3, t3, i3) {
          this._evalLazyOptionalParams(i3), e3.call(console, (this._optionsService.options.logger ? "" : "xterm.js: ") + t3, ...i3);
        }
        trace(e3, ...t3) {
          this._logLevel <= o.LogLevelEnum.TRACE && this._log(this._optionsService.options.logger?.trace.bind(this._optionsService.options.logger) ?? console.log, e3, t3);
        }
        debug(e3, ...t3) {
          this._logLevel <= o.LogLevelEnum.DEBUG && this._log(this._optionsService.options.logger?.debug.bind(this._optionsService.options.logger) ?? console.log, e3, t3);
        }
        info(e3, ...t3) {
          this._logLevel <= o.LogLevelEnum.INFO && this._log(this._optionsService.options.logger?.info.bind(this._optionsService.options.logger) ?? console.info, e3, t3);
        }
        warn(e3, ...t3) {
          this._logLevel <= o.LogLevelEnum.WARN && this._log(this._optionsService.options.logger?.warn.bind(this._optionsService.options.logger) ?? console.warn, e3, t3);
        }
        error(e3, ...t3) {
          this._logLevel <= o.LogLevelEnum.ERROR && this._log(this._optionsService.options.logger?.error.bind(this._optionsService.options.logger) ?? console.error, e3, t3);
        }
      };
      t2.LogService = c = s2([r(0, o.IOptionsService)], c), t2.setTraceLogger = function(e3) {
        h = e3;
      }, t2.traceCall = function(e3, t3, i3) {
        if (typeof i3.value != "function")
          throw new Error("not supported");
        const s3 = i3.value;
        i3.value = function(...e4) {
          if (h.logLevel !== o.LogLevelEnum.TRACE)
            return s3.apply(this, e4);
          h.trace(`GlyphRenderer#${s3.name}(${e4.map((e5) => JSON.stringify(e5)).join(", ")})`);
          const t4 = s3.apply(this, e4);
          return h.trace(`GlyphRenderer#${s3.name} return`, t4), t4;
        };
      };
    }, 7302: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.OptionsService = t2.DEFAULT_OPTIONS = undefined;
      const s2 = i2(8460), r = i2(844), n = i2(6114);
      t2.DEFAULT_OPTIONS = { cols: 80, rows: 24, cursorBlink: false, cursorStyle: "block", cursorWidth: 1, cursorInactiveStyle: "outline", customGlyphs: true, drawBoldTextInBrightColors: true, documentOverride: null, fastScrollModifier: "alt", fastScrollSensitivity: 5, fontFamily: "courier-new, courier, monospace", fontSize: 15, fontWeight: "normal", fontWeightBold: "bold", ignoreBracketedPasteMode: false, lineHeight: 1, letterSpacing: 0, linkHandler: null, logLevel: "info", logger: null, scrollback: 1000, scrollOnUserInput: true, scrollSensitivity: 1, screenReaderMode: false, smoothScrollDuration: 0, macOptionIsMeta: false, macOptionClickForcesSelection: false, minimumContrastRatio: 1, disableStdin: false, allowProposedApi: false, allowTransparency: false, tabStopWidth: 8, theme: {}, rightClickSelectsWord: n.isMac, windowOptions: {}, windowsMode: false, windowsPty: {}, wordSeparator: " ()[]{}',\"`", altClickMovesCursor: true, convertEol: false, termName: "xterm", cancelEvents: false, overviewRulerWidth: 0 };
      const o = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"];

      class a extends r.Disposable {
        constructor(e3) {
          super(), this._onOptionChange = this.register(new s2.EventEmitter), this.onOptionChange = this._onOptionChange.event;
          const i3 = { ...t2.DEFAULT_OPTIONS };
          for (const t3 in e3)
            if (t3 in i3)
              try {
                const s3 = e3[t3];
                i3[t3] = this._sanitizeAndValidateOption(t3, s3);
              } catch (e4) {
                console.error(e4);
              }
          this.rawOptions = i3, this.options = { ...i3 }, this._setupOptions();
        }
        onSpecificOptionChange(e3, t3) {
          return this.onOptionChange((i3) => {
            i3 === e3 && t3(this.rawOptions[e3]);
          });
        }
        onMultipleOptionChange(e3, t3) {
          return this.onOptionChange((i3) => {
            e3.indexOf(i3) !== -1 && t3();
          });
        }
        _setupOptions() {
          const e3 = (e4) => {
            if (!(e4 in t2.DEFAULT_OPTIONS))
              throw new Error(`No option with key "${e4}"`);
            return this.rawOptions[e4];
          }, i3 = (e4, i4) => {
            if (!(e4 in t2.DEFAULT_OPTIONS))
              throw new Error(`No option with key "${e4}"`);
            i4 = this._sanitizeAndValidateOption(e4, i4), this.rawOptions[e4] !== i4 && (this.rawOptions[e4] = i4, this._onOptionChange.fire(e4));
          };
          for (const t3 in this.rawOptions) {
            const s3 = { get: e3.bind(this, t3), set: i3.bind(this, t3) };
            Object.defineProperty(this.options, t3, s3);
          }
        }
        _sanitizeAndValidateOption(e3, i3) {
          switch (e3) {
            case "cursorStyle":
              if (i3 || (i3 = t2.DEFAULT_OPTIONS[e3]), !function(e4) {
                return e4 === "block" || e4 === "underline" || e4 === "bar";
              }(i3))
                throw new Error(`"${i3}" is not a valid value for ${e3}`);
              break;
            case "wordSeparator":
              i3 || (i3 = t2.DEFAULT_OPTIONS[e3]);
              break;
            case "fontWeight":
            case "fontWeightBold":
              if (typeof i3 == "number" && 1 <= i3 && i3 <= 1000)
                break;
              i3 = o.includes(i3) ? i3 : t2.DEFAULT_OPTIONS[e3];
              break;
            case "cursorWidth":
              i3 = Math.floor(i3);
            case "lineHeight":
            case "tabStopWidth":
              if (i3 < 1)
                throw new Error(`${e3} cannot be less than 1, value: ${i3}`);
              break;
            case "minimumContrastRatio":
              i3 = Math.max(1, Math.min(21, Math.round(10 * i3) / 10));
              break;
            case "scrollback":
              if ((i3 = Math.min(i3, 4294967295)) < 0)
                throw new Error(`${e3} cannot be less than 0, value: ${i3}`);
              break;
            case "fastScrollSensitivity":
            case "scrollSensitivity":
              if (i3 <= 0)
                throw new Error(`${e3} cannot be less than or equal to 0, value: ${i3}`);
              break;
            case "rows":
            case "cols":
              if (!i3 && i3 !== 0)
                throw new Error(`${e3} must be numeric, value: ${i3}`);
              break;
            case "windowsPty":
              i3 = i3 ?? {};
          }
          return i3;
        }
      }
      t2.OptionsService = a;
    }, 2660: function(e2, t2, i2) {
      var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : s3 === null ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          o2 = Reflect.decorate(e3, t3, i3, s3);
        else
          for (var a = e3.length - 1;a >= 0; a--)
            (r2 = e3[a]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i3, s3) {
          t3(i3, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.OscLinkService = undefined;
      const n = i2(2585);
      let o = t2.OscLinkService = class {
        constructor(e3) {
          this._bufferService = e3, this._nextId = 1, this._entriesWithId = new Map, this._dataByLinkId = new Map;
        }
        registerLink(e3) {
          const t3 = this._bufferService.buffer;
          if (e3.id === undefined) {
            const i4 = t3.addMarker(t3.ybase + t3.y), s4 = { data: e3, id: this._nextId++, lines: [i4] };
            return i4.onDispose(() => this._removeMarkerFromLink(s4, i4)), this._dataByLinkId.set(s4.id, s4), s4.id;
          }
          const i3 = e3, s3 = this._getEntryIdKey(i3), r2 = this._entriesWithId.get(s3);
          if (r2)
            return this.addLineToLink(r2.id, t3.ybase + t3.y), r2.id;
          const n2 = t3.addMarker(t3.ybase + t3.y), o2 = { id: this._nextId++, key: this._getEntryIdKey(i3), data: i3, lines: [n2] };
          return n2.onDispose(() => this._removeMarkerFromLink(o2, n2)), this._entriesWithId.set(o2.key, o2), this._dataByLinkId.set(o2.id, o2), o2.id;
        }
        addLineToLink(e3, t3) {
          const i3 = this._dataByLinkId.get(e3);
          if (i3 && i3.lines.every((e4) => e4.line !== t3)) {
            const e4 = this._bufferService.buffer.addMarker(t3);
            i3.lines.push(e4), e4.onDispose(() => this._removeMarkerFromLink(i3, e4));
          }
        }
        getLinkData(e3) {
          return this._dataByLinkId.get(e3)?.data;
        }
        _getEntryIdKey(e3) {
          return `${e3.id};;${e3.uri}`;
        }
        _removeMarkerFromLink(e3, t3) {
          const i3 = e3.lines.indexOf(t3);
          i3 !== -1 && (e3.lines.splice(i3, 1), e3.lines.length === 0 && (e3.data.id !== undefined && this._entriesWithId.delete(e3.key), this._dataByLinkId.delete(e3.id)));
        }
      };
      t2.OscLinkService = o = s2([r(0, n.IBufferService)], o);
    }, 8343: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.createDecorator = t2.getServiceDependencies = t2.serviceRegistry = undefined;
      const i2 = "di$target", s2 = "di$dependencies";
      t2.serviceRegistry = new Map, t2.getServiceDependencies = function(e3) {
        return e3[s2] || [];
      }, t2.createDecorator = function(e3) {
        if (t2.serviceRegistry.has(e3))
          return t2.serviceRegistry.get(e3);
        const r = function(e4, t3, n) {
          if (arguments.length !== 3)
            throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
          (function(e5, t4, r2) {
            t4[i2] === t4 ? t4[s2].push({ id: e5, index: r2 }) : (t4[s2] = [{ id: e5, index: r2 }], t4[i2] = t4);
          })(r, e4, n);
        };
        return r.toString = () => e3, t2.serviceRegistry.set(e3, r), r;
      };
    }, 2585: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.IDecorationService = t2.IUnicodeService = t2.IOscLinkService = t2.IOptionsService = t2.ILogService = t2.LogLevelEnum = t2.IInstantiationService = t2.ICharsetService = t2.ICoreService = t2.ICoreMouseService = t2.IBufferService = undefined;
      const s2 = i2(8343);
      var r;
      t2.IBufferService = (0, s2.createDecorator)("BufferService"), t2.ICoreMouseService = (0, s2.createDecorator)("CoreMouseService"), t2.ICoreService = (0, s2.createDecorator)("CoreService"), t2.ICharsetService = (0, s2.createDecorator)("CharsetService"), t2.IInstantiationService = (0, s2.createDecorator)("InstantiationService"), function(e3) {
        e3[e3.TRACE = 0] = "TRACE", e3[e3.DEBUG = 1] = "DEBUG", e3[e3.INFO = 2] = "INFO", e3[e3.WARN = 3] = "WARN", e3[e3.ERROR = 4] = "ERROR", e3[e3.OFF = 5] = "OFF";
      }(r || (t2.LogLevelEnum = r = {})), t2.ILogService = (0, s2.createDecorator)("LogService"), t2.IOptionsService = (0, s2.createDecorator)("OptionsService"), t2.IOscLinkService = (0, s2.createDecorator)("OscLinkService"), t2.IUnicodeService = (0, s2.createDecorator)("UnicodeService"), t2.IDecorationService = (0, s2.createDecorator)("DecorationService");
    }, 1480: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.UnicodeService = undefined;
      const s2 = i2(8460), r = i2(225);

      class n {
        static extractShouldJoin(e3) {
          return (1 & e3) != 0;
        }
        static extractWidth(e3) {
          return e3 >> 1 & 3;
        }
        static extractCharKind(e3) {
          return e3 >> 3;
        }
        static createPropertyValue(e3, t3, i3 = false) {
          return (16777215 & e3) << 3 | (3 & t3) << 1 | (i3 ? 1 : 0);
        }
        constructor() {
          this._providers = Object.create(null), this._active = "", this._onChange = new s2.EventEmitter, this.onChange = this._onChange.event;
          const e3 = new r.UnicodeV6;
          this.register(e3), this._active = e3.version, this._activeProvider = e3;
        }
        dispose() {
          this._onChange.dispose();
        }
        get versions() {
          return Object.keys(this._providers);
        }
        get activeVersion() {
          return this._active;
        }
        set activeVersion(e3) {
          if (!this._providers[e3])
            throw new Error(`unknown Unicode version "${e3}"`);
          this._active = e3, this._activeProvider = this._providers[e3], this._onChange.fire(e3);
        }
        register(e3) {
          this._providers[e3.version] = e3;
        }
        wcwidth(e3) {
          return this._activeProvider.wcwidth(e3);
        }
        getStringCellWidth(e3) {
          let t3 = 0, i3 = 0;
          const s3 = e3.length;
          for (let r2 = 0;r2 < s3; ++r2) {
            let o = e3.charCodeAt(r2);
            if (55296 <= o && o <= 56319) {
              if (++r2 >= s3)
                return t3 + this.wcwidth(o);
              const i4 = e3.charCodeAt(r2);
              56320 <= i4 && i4 <= 57343 ? o = 1024 * (o - 55296) + i4 - 56320 + 65536 : t3 += this.wcwidth(i4);
            }
            const a = this.charProperties(o, i3);
            let h = n.extractWidth(a);
            n.extractShouldJoin(a) && (h -= n.extractWidth(i3)), t3 += h, i3 = a;
          }
          return t3;
        }
        charProperties(e3, t3) {
          return this._activeProvider.charProperties(e3, t3);
        }
      }
      t2.UnicodeService = n;
    } }, t = {};
    function i(s2) {
      var r = t[s2];
      if (r !== undefined)
        return r.exports;
      var n = t[s2] = { exports: {} };
      return e[s2].call(n.exports, n, n.exports, i), n.exports;
    }
    var s = {};
    return (() => {
      var e2 = s;
      Object.defineProperty(e2, "__esModule", { value: true }), e2.Terminal = undefined;
      const t2 = i(9042), r = i(3236), n = i(844), o = i(5741), a = i(8285), h = i(7975), c = i(7090), l = ["cols", "rows"];

      class d extends n.Disposable {
        constructor(e3) {
          super(), this._core = this.register(new r.Terminal(e3)), this._addonManager = this.register(new o.AddonManager), this._publicOptions = { ...this._core.options };
          const t3 = (e4) => this._core.options[e4], i2 = (e4, t4) => {
            this._checkReadonlyOptions(e4), this._core.options[e4] = t4;
          };
          for (const e4 in this._core.options) {
            const s2 = { get: t3.bind(this, e4), set: i2.bind(this, e4) };
            Object.defineProperty(this._publicOptions, e4, s2);
          }
        }
        _checkReadonlyOptions(e3) {
          if (l.includes(e3))
            throw new Error(`Option "${e3}" can only be set in the constructor`);
        }
        _checkProposedApi() {
          if (!this._core.optionsService.rawOptions.allowProposedApi)
            throw new Error("You must set the allowProposedApi option to true to use proposed API");
        }
        get onBell() {
          return this._core.onBell;
        }
        get onBinary() {
          return this._core.onBinary;
        }
        get onCursorMove() {
          return this._core.onCursorMove;
        }
        get onData() {
          return this._core.onData;
        }
        get onKey() {
          return this._core.onKey;
        }
        get onLineFeed() {
          return this._core.onLineFeed;
        }
        get onRender() {
          return this._core.onRender;
        }
        get onResize() {
          return this._core.onResize;
        }
        get onScroll() {
          return this._core.onScroll;
        }
        get onSelectionChange() {
          return this._core.onSelectionChange;
        }
        get onTitleChange() {
          return this._core.onTitleChange;
        }
        get onWriteParsed() {
          return this._core.onWriteParsed;
        }
        get element() {
          return this._core.element;
        }
        get parser() {
          return this._parser || (this._parser = new h.ParserApi(this._core)), this._parser;
        }
        get unicode() {
          return this._checkProposedApi(), new c.UnicodeApi(this._core);
        }
        get textarea() {
          return this._core.textarea;
        }
        get rows() {
          return this._core.rows;
        }
        get cols() {
          return this._core.cols;
        }
        get buffer() {
          return this._buffer || (this._buffer = this.register(new a.BufferNamespaceApi(this._core))), this._buffer;
        }
        get markers() {
          return this._checkProposedApi(), this._core.markers;
        }
        get modes() {
          const e3 = this._core.coreService.decPrivateModes;
          let t3 = "none";
          switch (this._core.coreMouseService.activeProtocol) {
            case "X10":
              t3 = "x10";
              break;
            case "VT200":
              t3 = "vt200";
              break;
            case "DRAG":
              t3 = "drag";
              break;
            case "ANY":
              t3 = "any";
          }
          return { applicationCursorKeysMode: e3.applicationCursorKeys, applicationKeypadMode: e3.applicationKeypad, bracketedPasteMode: e3.bracketedPasteMode, insertMode: this._core.coreService.modes.insertMode, mouseTrackingMode: t3, originMode: e3.origin, reverseWraparoundMode: e3.reverseWraparound, sendFocusMode: e3.sendFocus, wraparoundMode: e3.wraparound };
        }
        get options() {
          return this._publicOptions;
        }
        set options(e3) {
          for (const t3 in e3)
            this._publicOptions[t3] = e3[t3];
        }
        blur() {
          this._core.blur();
        }
        focus() {
          this._core.focus();
        }
        resize(e3, t3) {
          this._verifyIntegers(e3, t3), this._core.resize(e3, t3);
        }
        open(e3) {
          this._core.open(e3);
        }
        attachCustomKeyEventHandler(e3) {
          this._core.attachCustomKeyEventHandler(e3);
        }
        registerLinkProvider(e3) {
          return this._core.registerLinkProvider(e3);
        }
        registerCharacterJoiner(e3) {
          return this._checkProposedApi(), this._core.registerCharacterJoiner(e3);
        }
        deregisterCharacterJoiner(e3) {
          this._checkProposedApi(), this._core.deregisterCharacterJoiner(e3);
        }
        registerMarker(e3 = 0) {
          return this._verifyIntegers(e3), this._core.registerMarker(e3);
        }
        registerDecoration(e3) {
          return this._checkProposedApi(), this._verifyPositiveIntegers(e3.x ?? 0, e3.width ?? 0, e3.height ?? 0), this._core.registerDecoration(e3);
        }
        hasSelection() {
          return this._core.hasSelection();
        }
        select(e3, t3, i2) {
          this._verifyIntegers(e3, t3, i2), this._core.select(e3, t3, i2);
        }
        getSelection() {
          return this._core.getSelection();
        }
        getSelectionPosition() {
          return this._core.getSelectionPosition();
        }
        clearSelection() {
          this._core.clearSelection();
        }
        selectAll() {
          this._core.selectAll();
        }
        selectLines(e3, t3) {
          this._verifyIntegers(e3, t3), this._core.selectLines(e3, t3);
        }
        dispose() {
          super.dispose();
        }
        scrollLines(e3) {
          this._verifyIntegers(e3), this._core.scrollLines(e3);
        }
        scrollPages(e3) {
          this._verifyIntegers(e3), this._core.scrollPages(e3);
        }
        scrollToTop() {
          this._core.scrollToTop();
        }
        scrollToBottom() {
          this._core.scrollToBottom();
        }
        scrollToLine(e3) {
          this._verifyIntegers(e3), this._core.scrollToLine(e3);
        }
        clear() {
          this._core.clear();
        }
        write(e3, t3) {
          this._core.write(e3, t3);
        }
        writeln(e3, t3) {
          this._core.write(e3), this._core.write("\r\n", t3);
        }
        paste(e3) {
          this._core.paste(e3);
        }
        refresh(e3, t3) {
          this._verifyIntegers(e3, t3), this._core.refresh(e3, t3);
        }
        reset() {
          this._core.reset();
        }
        clearTextureAtlas() {
          this._core.clearTextureAtlas();
        }
        loadAddon(e3) {
          this._addonManager.loadAddon(this, e3);
        }
        static get strings() {
          return t2;
        }
        _verifyIntegers(...e3) {
          for (const t3 of e3)
            if (t3 === 1 / 0 || isNaN(t3) || t3 % 1 != 0)
              throw new Error("This API only accepts integers");
        }
        _verifyPositiveIntegers(...e3) {
          for (const t3 of e3)
            if (t3 && (t3 === 1 / 0 || isNaN(t3) || t3 % 1 != 0 || t3 < 0))
              throw new Error("This API only accepts positive integers");
        }
      }
      e2.Terminal = d;
    })(), s;
  })());
});

// node_modules/string.fromcodepoint/fromcodepoint.js
var exports_fromcodepoint = {};
var init_fromcodepoint = __esm(() => {
  /*! http://mths.be/fromcodepoint v0.2.1 by @mathias */
  if (!String.fromCodePoint) {
    (function() {
      var defineProperty = function() {
        try {
          var object = {};
          var $defineProperty = Object.defineProperty;
          var result = $defineProperty(object, object, object) && $defineProperty;
        } catch (error2) {
        }
        return result;
      }();
      var stringFromCharCode = String.fromCharCode;
      var floor = Math.floor;
      var fromCodePoint = function(_) {
        var MAX_SIZE = 16384;
        var codeUnits = [];
        var highSurrogate;
        var lowSurrogate;
        var index = -1;
        var length = arguments.length;
        if (!length) {
          return "";
        }
        var result = "";
        while (++index < length) {
          var codePoint = Number(arguments[index]);
          if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) != codePoint) {
            throw RangeError("Invalid code point: " + codePoint);
          }
          if (codePoint <= 65535) {
            codeUnits.push(codePoint);
          } else {
            codePoint -= 65536;
            highSurrogate = (codePoint >> 10) + 55296;
            lowSurrogate = codePoint % 1024 + 56320;
            codeUnits.push(highSurrogate, lowSurrogate);
          }
          if (index + 1 == length || codeUnits.length > MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits);
            codeUnits.length = 0;
          }
        }
        return result;
      };
      if (defineProperty) {
        defineProperty(String, "fromCodePoint", {
          value: fromCodePoint,
          configurable: true,
          writable: true
        });
      } else {
        String.fromCodePoint = fromCodePoint;
      }
    })();
  }
});

// node_modules/unescape-js/dist/index.js
var require_dist = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  init_fromcodepoint();
  var jsEscapeRegex = /\\(u\{([0-9A-Fa-f]+)\}|u([0-9A-Fa-f]{4})|x([0-9A-Fa-f]{2})|([1-7][0-7]{0,2}|[0-7]{2,3})|(['"tbrnfv0\\]))|\\U([0-9A-Fa-f]{8})/g;
  var usualEscapeSequences = {
    "0": "\0",
    b: "\b",
    f: "\f",
    n: "\n",
    r: "\r",
    t: "\t",
    v: "\v",
    "\'": "\'",
    '"': '"',
    "\\": "\\"
  };
  var fromHex = function fromHex(str) {
    return String.fromCodePoint(parseInt(str, 16));
  };
  var fromOct = function fromOct(str) {
    return String.fromCodePoint(parseInt(str, 8));
  };
  var _default = function _default(string) {
    return string.replace(jsEscapeRegex, function(_, __, varHex, longHex, shortHex, octal, specialCharacter, python) {
      if (varHex !== undefined) {
        return fromHex(varHex);
      } else if (longHex !== undefined) {
        return fromHex(longHex);
      } else if (shortHex !== undefined) {
        return fromHex(shortHex);
      } else if (octal !== undefined) {
        return fromOct(octal);
      } else if (python !== undefined) {
        return fromHex(python);
      } else {
        return usualEscapeSequences[specialCharacter];
      }
    });
  };
  exports.default = _default;
  module.exports = exports.default;
});

// node_modules/color-name/index.js
var require_color_name = __commonJS((exports, module) => {
  module.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS((exports, module) => {
  module.exports = function isArrayish(obj) {
    if (!obj || typeof obj === "string") {
      return false;
    }
    return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
  };
});

// node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS((exports, module) => {
  var isArrayish = require_is_arrayish();
  var concat = Array.prototype.concat;
  var slice = Array.prototype.slice;
  var swizzle = module.exports = function swizzle(args) {
    var results = [];
    for (var i = 0, len = args.length;i < len; i++) {
      var arg = args[i];
      if (isArrayish(arg)) {
        results = concat.call(results, slice.call(arg));
      } else {
        results.push(arg);
      }
    }
    return results;
  };
  swizzle.wrap = function(fn) {
    return function() {
      return fn(swizzle(arguments));
    };
  };
});

// node_modules/color-string/index.js
var require_color_string = __commonJS((exports, module) => {
  var clamp = function(num, min, max) {
    return Math.min(Math.max(min, num), max);
  };
  var hexDouble = function(num) {
    var str = Math.round(num).toString(16).toUpperCase();
    return str.length < 2 ? "0" + str : str;
  };
  var colorNames = require_color_name();
  var swizzle = require_simple_swizzle();
  var hasOwnProperty = Object.hasOwnProperty;
  var reverseNames = Object.create(null);
  for (name in colorNames) {
    if (hasOwnProperty.call(colorNames, name)) {
      reverseNames[colorNames[name]] = name;
    }
  }
  var name;
  var cs = module.exports = {
    to: {},
    get: {}
  };
  cs.get = function(string) {
    var prefix = string.substring(0, 3).toLowerCase();
    var val;
    var model;
    switch (prefix) {
      case "hsl":
        val = cs.get.hsl(string);
        model = "hsl";
        break;
      case "hwb":
        val = cs.get.hwb(string);
        model = "hwb";
        break;
      default:
        val = cs.get.rgb(string);
        model = "rgb";
        break;
    }
    if (!val) {
      return null;
    }
    return { model, value: val };
  };
  cs.get.rgb = function(string) {
    if (!string) {
      return null;
    }
    var abbr = /^#([a-f0-9]{3,4})$/i;
    var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
    var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
    var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
    var keyword = /^(\w+)$/;
    var rgb = [0, 0, 0, 1];
    var match;
    var i;
    var hexAlpha;
    if (match = string.match(hex)) {
      hexAlpha = match[2];
      match = match[1];
      for (i = 0;i < 3; i++) {
        var i2 = i * 2;
        rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
      }
      if (hexAlpha) {
        rgb[3] = parseInt(hexAlpha, 16) / 255;
      }
    } else if (match = string.match(abbr)) {
      match = match[1];
      hexAlpha = match[3];
      for (i = 0;i < 3; i++) {
        rgb[i] = parseInt(match[i] + match[i], 16);
      }
      if (hexAlpha) {
        rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
      }
    } else if (match = string.match(rgba)) {
      for (i = 0;i < 3; i++) {
        rgb[i] = parseInt(match[i + 1], 0);
      }
      if (match[4]) {
        if (match[5]) {
          rgb[3] = parseFloat(match[4]) * 0.01;
        } else {
          rgb[3] = parseFloat(match[4]);
        }
      }
    } else if (match = string.match(per)) {
      for (i = 0;i < 3; i++) {
        rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
      }
      if (match[4]) {
        if (match[5]) {
          rgb[3] = parseFloat(match[4]) * 0.01;
        } else {
          rgb[3] = parseFloat(match[4]);
        }
      }
    } else if (match = string.match(keyword)) {
      if (match[1] === "transparent") {
        return [0, 0, 0, 0];
      }
      if (!hasOwnProperty.call(colorNames, match[1])) {
        return null;
      }
      rgb = colorNames[match[1]];
      rgb[3] = 1;
      return rgb;
    } else {
      return null;
    }
    for (i = 0;i < 3; i++) {
      rgb[i] = clamp(rgb[i], 0, 255);
    }
    rgb[3] = clamp(rgb[3], 0, 1);
    return rgb;
  };
  cs.get.hsl = function(string) {
    if (!string) {
      return null;
    }
    var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    var match = string.match(hsl);
    if (match) {
      var alpha = parseFloat(match[4]);
      var h = (parseFloat(match[1]) % 360 + 360) % 360;
      var s = clamp(parseFloat(match[2]), 0, 100);
      var l = clamp(parseFloat(match[3]), 0, 100);
      var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, s, l, a];
    }
    return null;
  };
  cs.get.hwb = function(string) {
    if (!string) {
      return null;
    }
    var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    var match = string.match(hwb);
    if (match) {
      var alpha = parseFloat(match[4]);
      var h = (parseFloat(match[1]) % 360 + 360) % 360;
      var w = clamp(parseFloat(match[2]), 0, 100);
      var b = clamp(parseFloat(match[3]), 0, 100);
      var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, w, b, a];
    }
    return null;
  };
  cs.to.hex = function() {
    var rgba = swizzle(arguments);
    return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
  };
  cs.to.rgb = function() {
    var rgba = swizzle(arguments);
    return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
  };
  cs.to.rgb.percent = function() {
    var rgba = swizzle(arguments);
    var r = Math.round(rgba[0] / 255 * 100);
    var g = Math.round(rgba[1] / 255 * 100);
    var b = Math.round(rgba[2] / 255 * 100);
    return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
  };
  cs.to.hsl = function() {
    var hsla = swizzle(arguments);
    return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
  };
  cs.to.hwb = function() {
    var hwba = swizzle(arguments);
    var a = "";
    if (hwba.length >= 4 && hwba[3] !== 1) {
      a = ", " + hwba[3];
    }
    return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
  };
  cs.to.keyword = function(rgb) {
    return reverseNames[rgb.slice(0, 3)];
  };
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS((exports, module) => {
  var comparativeDistance = function(x, y) {
    return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
  };
  var cssKeywords = require_color_name();
  var reverseKeywords = {};
  for (const key of Object.keys(cssKeywords)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
  var convert = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  module.exports = convert;
  for (const model of Object.keys(convert)) {
    if (!("channels" in convert[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert[model].labels.length !== convert[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    const { channels, labels } = convert[model];
    delete convert[model].channels;
    delete convert[model].labels;
    Object.defineProperty(convert[model], "channels", { value: channels });
    Object.defineProperty(convert[model], "labels", { value: labels });
  }
  convert.rgb.hsl = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    let h;
    let s;
    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
      h += 360;
    }
    const l = (min + max) / 2;
    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }
    return [h, s * 100, l * 100];
  };
  convert.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);
    const diffc = function(c) {
      return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h = 0;
      s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return [
      h * 360,
      s * 100,
      v * 100
    ];
  };
  convert.rgb.hwb = function(rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h = convert.rgb.hsl(rgb)[0];
    const w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };
  convert.rgb.cmyk = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  convert.rgb.keyword = function(rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys(cssKeywords)) {
      const value = cssKeywords[keyword];
      const distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
    return currentClosestKeyword;
  };
  convert.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert.rgb.xyz = function(rgb) {
    let r = rgb[0] / 255;
    let g = rgb[1] / 255;
    let b = rgb[2] / 255;
    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };
  convert.rgb.lab = function(rgb) {
    const xyz = convert.rgb.xyz(rgb);
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert.hsl.rgb = function(hsl) {
    const h = hsl[0] / 360;
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }
    const t1 = 2 * l - t2;
    const rgb = [0, 0, 0];
    for (let i = 0;i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert.hsl.hsv = function(hsl) {
    const h = hsl[0];
    let s = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };
  convert.hsv.rgb = function(hsv) {
    const h = hsv[0] / 60;
    const s = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v * (1 - s);
    const q = 255 * v * (1 - s * f);
    const t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert.hsv.hsl = function(hsv) {
    const h = hsv[0];
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s) * v;
    const lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };
  convert.hwb.rgb = function(hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    const i = Math.floor(6 * h);
    const v = 1 - bl;
    f = 6 * h - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    const n = wh + f * (v - wh);
    let r;
    let g;
    let b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert.cmyk.rgb = function(cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.rgb = function(xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.204 + z * 1.057;
    r = r > 0.0031308 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
    g = g > 0.0031308 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
    b = b > 0.0031308 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.lab = function(xyz) {
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert.lab.xyz = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y;
    let z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    const y2 = y ** 3;
    const x2 = x ** 3;
    const z2 = z ** 3;
    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };
  convert.lab.lch = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    const c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };
  convert.lch.lab = function(lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr = h / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert.rgb.ansi16 = function(args, saturation = null) {
    const [r, g, b] = args;
    let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert.hsv.ansi16 = function(args) {
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };
  convert.rgb.ansi256 = function(args) {
    const r = args[0];
    const g = args[1];
    const b = args[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert.ansi16.rgb = function(args) {
    let color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g = (color >> 1 & 1) * mult * 255;
    const b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert.ansi256.rgb = function(args) {
    if (args >= 232) {
      const c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert.rgb.hex = function(args) {
    const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.hex.rgb = function(args) {
    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    let colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString.split("").map((char) => {
        return char + char;
      }).join("");
    }
    const integer = parseInt(colorString, 16);
    const r = integer >> 16 & 255;
    const g = integer >> 8 & 255;
    const b = integer & 255;
    return [r, g, b];
  };
  convert.rgb.hcg = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    const chroma = max - min;
    let grayscale;
    let hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert.hsl.hcg = function(hsl) {
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
    let f = 0;
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert.hsv.hcg = function(hsv) {
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s * v;
    let f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert.hcg.rgb = function(hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    const pure = [0, 0, 0];
    const hi = h % 1 * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  convert.hcg.hsv = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    let f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert.hcg.hsl = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1 - c) + 0.5 * c;
    let s = 0;
    if (l > 0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s = c / (2 * (1 - l));
    }
    return [hcg[0], s * 100, l * 100];
  };
  convert.hcg.hwb = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert.hwb.hcg = function(hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w;
    let g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert.gray.hsl = function(args) {
    return [0, 0, args[0]];
  };
  convert.gray.hsv = convert.gray.hsl;
  convert.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert.gray.hex = function(gray) {
    const val = Math.round(gray[0] / 100 * 255) & 255;
    const integer = (val << 16) + (val << 8) + val;
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.rgb.gray = function(rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
});

// node_modules/color-convert/route.js
var require_route = __commonJS((exports, module) => {
  var buildGraph = function() {
    const graph = {};
    const models = Object.keys(conversions);
    for (let len = models.length, i = 0;i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  };
  var deriveBFS = function(fromModel) {
    const graph = buildGraph();
    const queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      const current = queue.pop();
      const adjacents = Object.keys(conversions[current]);
      for (let len = adjacents.length, i = 0;i < len; i++) {
        const adjacent = adjacents[i];
        const node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  };
  var link = function(from, to) {
    return function(args) {
      return to(from(args));
    };
  };
  var wrapConversion = function(toModel, graph) {
    const path = [graph[toModel].parent, toModel];
    let fn = conversions[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path.unshift(graph[cur].parent);
      fn = link(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path;
    return fn;
  };
  var conversions = require_conversions();
  module.exports = function(fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);
    for (let len = models.length, i = 0;i < len; i++) {
      const toModel = models[i];
      const node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS((exports, module) => {
  var wrapRaw = function(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === undefined || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      return fn(args);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  };
  var wrapRounded = function(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === undefined || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      const result = fn(args);
      if (typeof result === "object") {
        for (let len = result.length, i = 0;i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  };
  var conversions = require_conversions();
  var route = require_route();
  var convert = {};
  var models = Object.keys(conversions);
  models.forEach((fromModel) => {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
    Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
    const routes = route(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel) => {
      const fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  module.exports = convert;
});

// node_modules/color/index.js
var require_color = __commonJS((exports, module) => {
  var Color = function(object, model) {
    if (!(this instanceof Color)) {
      return new Color(object, model);
    }
    if (model && (model in skippedModels)) {
      model = null;
    }
    if (model && !(model in convert)) {
      throw new Error("Unknown model: " + model);
    }
    let i;
    let channels;
    if (object == null) {
      this.model = "rgb";
      this.color = [0, 0, 0];
      this.valpha = 1;
    } else if (object instanceof Color) {
      this.model = object.model;
      this.color = [...object.color];
      this.valpha = object.valpha;
    } else if (typeof object === "string") {
      const result = colorString.get(object);
      if (result === null) {
        throw new Error("Unable to parse color from string: " + object);
      }
      this.model = result.model;
      channels = convert[this.model].channels;
      this.color = result.value.slice(0, channels);
      this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
    } else if (object.length > 0) {
      this.model = model || "rgb";
      channels = convert[this.model].channels;
      const newArray = Array.prototype.slice.call(object, 0, channels);
      this.color = zeroArray(newArray, channels);
      this.valpha = typeof object[channels] === "number" ? object[channels] : 1;
    } else if (typeof object === "number") {
      this.model = "rgb";
      this.color = [
        object >> 16 & 255,
        object >> 8 & 255,
        object & 255
      ];
      this.valpha = 1;
    } else {
      this.valpha = 1;
      const keys = Object.keys(object);
      if ("alpha" in object) {
        keys.splice(keys.indexOf("alpha"), 1);
        this.valpha = typeof object.alpha === "number" ? object.alpha : 0;
      }
      const hashedKeys = keys.sort().join("");
      if (!(hashedKeys in hashedModelKeys)) {
        throw new Error("Unable to parse color from object: " + JSON.stringify(object));
      }
      this.model = hashedModelKeys[hashedKeys];
      const { labels } = convert[this.model];
      const color = [];
      for (i = 0;i < labels.length; i++) {
        color.push(object[labels[i]]);
      }
      this.color = zeroArray(color);
    }
    if (limiters[this.model]) {
      channels = convert[this.model].channels;
      for (i = 0;i < channels; i++) {
        const limit = limiters[this.model][i];
        if (limit) {
          this.color[i] = limit(this.color[i]);
        }
      }
    }
    this.valpha = Math.max(0, Math.min(1, this.valpha));
    if (Object.freeze) {
      Object.freeze(this);
    }
  };
  var roundTo = function(number, places) {
    return Number(number.toFixed(places));
  };
  var roundToPlace = function(places) {
    return function(number) {
      return roundTo(number, places);
    };
  };
  var getset = function(model, channel, modifier) {
    model = Array.isArray(model) ? model : [model];
    for (const m of model) {
      (limiters[m] || (limiters[m] = []))[channel] = modifier;
    }
    model = model[0];
    return function(value) {
      let result;
      if (value !== undefined) {
        if (modifier) {
          value = modifier(value);
        }
        result = this[model]();
        result.color[channel] = value;
        return result;
      }
      result = this[model]().color[channel];
      if (modifier) {
        result = modifier(result);
      }
      return result;
    };
  };
  var maxfn = function(max) {
    return function(v) {
      return Math.max(0, Math.min(max, v));
    };
  };
  var assertArray = function(value) {
    return Array.isArray(value) ? value : [value];
  };
  var zeroArray = function(array, length) {
    for (let i = 0;i < length; i++) {
      if (typeof array[i] !== "number") {
        array[i] = 0;
      }
    }
    return array;
  };
  var colorString = require_color_string();
  var convert = require_color_convert();
  var skippedModels = [
    "keyword",
    "gray",
    "hex"
  ];
  var hashedModelKeys = {};
  for (const model of Object.keys(convert)) {
    hashedModelKeys[[...convert[model].labels].sort().join("")] = model;
  }
  var limiters = {};
  Color.prototype = {
    toString() {
      return this.string();
    },
    toJSON() {
      return this[this.model]();
    },
    string(places) {
      let self2 = this.model in colorString.to ? this : this.rgb();
      self2 = self2.round(typeof places === "number" ? places : 1);
      const args = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
      return colorString.to[self2.model](args);
    },
    percentString(places) {
      const self2 = this.rgb().round(typeof places === "number" ? places : 1);
      const args = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
      return colorString.to.rgb.percent(args);
    },
    array() {
      return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
    },
    object() {
      const result = {};
      const { channels } = convert[this.model];
      const { labels } = convert[this.model];
      for (let i = 0;i < channels; i++) {
        result[labels[i]] = this.color[i];
      }
      if (this.valpha !== 1) {
        result.alpha = this.valpha;
      }
      return result;
    },
    unitArray() {
      const rgb = this.rgb().color;
      rgb[0] /= 255;
      rgb[1] /= 255;
      rgb[2] /= 255;
      if (this.valpha !== 1) {
        rgb.push(this.valpha);
      }
      return rgb;
    },
    unitObject() {
      const rgb = this.rgb().object();
      rgb.r /= 255;
      rgb.g /= 255;
      rgb.b /= 255;
      if (this.valpha !== 1) {
        rgb.alpha = this.valpha;
      }
      return rgb;
    },
    round(places) {
      places = Math.max(places || 0, 0);
      return new Color([...this.color.map(roundToPlace(places)), this.valpha], this.model);
    },
    alpha(value) {
      if (value !== undefined) {
        return new Color([...this.color, Math.max(0, Math.min(1, value))], this.model);
      }
      return this.valpha;
    },
    red: getset("rgb", 0, maxfn(255)),
    green: getset("rgb", 1, maxfn(255)),
    blue: getset("rgb", 2, maxfn(255)),
    hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, (value) => (value % 360 + 360) % 360),
    saturationl: getset("hsl", 1, maxfn(100)),
    lightness: getset("hsl", 2, maxfn(100)),
    saturationv: getset("hsv", 1, maxfn(100)),
    value: getset("hsv", 2, maxfn(100)),
    chroma: getset("hcg", 1, maxfn(100)),
    gray: getset("hcg", 2, maxfn(100)),
    white: getset("hwb", 1, maxfn(100)),
    wblack: getset("hwb", 2, maxfn(100)),
    cyan: getset("cmyk", 0, maxfn(100)),
    magenta: getset("cmyk", 1, maxfn(100)),
    yellow: getset("cmyk", 2, maxfn(100)),
    black: getset("cmyk", 3, maxfn(100)),
    x: getset("xyz", 0, maxfn(95.047)),
    y: getset("xyz", 1, maxfn(100)),
    z: getset("xyz", 2, maxfn(108.833)),
    l: getset("lab", 0, maxfn(100)),
    a: getset("lab", 1),
    b: getset("lab", 2),
    keyword(value) {
      if (value !== undefined) {
        return new Color(value);
      }
      return convert[this.model].keyword(this.color);
    },
    hex(value) {
      if (value !== undefined) {
        return new Color(value);
      }
      return colorString.to.hex(this.rgb().round().color);
    },
    hexa(value) {
      if (value !== undefined) {
        return new Color(value);
      }
      const rgbArray = this.rgb().round().color;
      let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
      if (alphaHex.length === 1) {
        alphaHex = "0" + alphaHex;
      }
      return colorString.to.hex(rgbArray) + alphaHex;
    },
    rgbNumber() {
      const rgb = this.rgb().color;
      return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
    },
    luminosity() {
      const rgb = this.rgb().color;
      const lum = [];
      for (const [i, element] of rgb.entries()) {
        const chan = element / 255;
        lum[i] = chan <= 0.04045 ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;
      }
      return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
    },
    contrast(color2) {
      const lum1 = this.luminosity();
      const lum2 = color2.luminosity();
      if (lum1 > lum2) {
        return (lum1 + 0.05) / (lum2 + 0.05);
      }
      return (lum2 + 0.05) / (lum1 + 0.05);
    },
    level(color2) {
      const contrastRatio = this.contrast(color2);
      if (contrastRatio >= 7) {
        return "AAA";
      }
      return contrastRatio >= 4.5 ? "AA" : "";
    },
    isDark() {
      const rgb = this.rgb().color;
      const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 1e4;
      return yiq < 128;
    },
    isLight() {
      return !this.isDark();
    },
    negate() {
      const rgb = this.rgb();
      for (let i = 0;i < 3; i++) {
        rgb.color[i] = 255 - rgb.color[i];
      }
      return rgb;
    },
    lighten(ratio) {
      const hsl = this.hsl();
      hsl.color[2] += hsl.color[2] * ratio;
      return hsl;
    },
    darken(ratio) {
      const hsl = this.hsl();
      hsl.color[2] -= hsl.color[2] * ratio;
      return hsl;
    },
    saturate(ratio) {
      const hsl = this.hsl();
      hsl.color[1] += hsl.color[1] * ratio;
      return hsl;
    },
    desaturate(ratio) {
      const hsl = this.hsl();
      hsl.color[1] -= hsl.color[1] * ratio;
      return hsl;
    },
    whiten(ratio) {
      const hwb = this.hwb();
      hwb.color[1] += hwb.color[1] * ratio;
      return hwb;
    },
    blacken(ratio) {
      const hwb = this.hwb();
      hwb.color[2] += hwb.color[2] * ratio;
      return hwb;
    },
    grayscale() {
      const rgb = this.rgb().color;
      const value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
      return Color.rgb(value, value, value);
    },
    fade(ratio) {
      return this.alpha(this.valpha - this.valpha * ratio);
    },
    opaquer(ratio) {
      return this.alpha(this.valpha + this.valpha * ratio);
    },
    rotate(degrees) {
      const hsl = this.hsl();
      let hue = hsl.color[0];
      hue = (hue + degrees) % 360;
      hue = hue < 0 ? 360 + hue : hue;
      hsl.color[0] = hue;
      return hsl;
    },
    mix(mixinColor, weight) {
      if (!mixinColor || !mixinColor.rgb) {
        throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
      }
      const color1 = mixinColor.rgb();
      const color2 = this.rgb();
      const p = weight === undefined ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = color1.alpha() - color2.alpha();
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      const w2 = 1 - w1;
      return Color.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue(), color1.alpha() * p + color2.alpha() * (1 - p));
    }
  };
  for (const model of Object.keys(convert)) {
    if (skippedModels.includes(model)) {
      continue;
    }
    const { channels } = convert[model];
    Color.prototype[model] = function(...args) {
      if (this.model === model) {
        return new Color(this);
      }
      if (args.length > 0) {
        return new Color(args, model);
      }
      return new Color([...assertArray(convert[this.model][model].raw(this.color)), this.valpha], model);
    };
    Color[model] = function(...args) {
      let color = args[0];
      if (typeof color === "number") {
        color = zeroArray(args, channels);
      }
      return new Color(color, model);
    };
  }
  module.exports = Color;
});

// node_modules/xterm-addon-fit/lib/xterm-addon-fit.js
var require_xterm_addon_fit = __commonJS((exports, module) => {
  (function(e, t) {
    typeof exports == "object" && typeof module == "object" ? module.exports = t() : typeof define == "function" && define.amd ? define([], t) : typeof exports == "object" ? exports.FitAddon = t() : e.FitAddon = t();
  })(self, () => (() => {
    var e = {};
    return (() => {
      var t = e;
      Object.defineProperty(t, "__esModule", { value: true }), t.FitAddon = undefined, t.FitAddon = class {
        activate(e2) {
          this._terminal = e2;
        }
        dispose() {
        }
        fit() {
          const e2 = this.proposeDimensions();
          if (!e2 || !this._terminal || isNaN(e2.cols) || isNaN(e2.rows))
            return;
          const t2 = this._terminal._core;
          this._terminal.rows === e2.rows && this._terminal.cols === e2.cols || (t2._renderService.clear(), this._terminal.resize(e2.cols, e2.rows));
        }
        proposeDimensions() {
          if (!this._terminal)
            return;
          if (!this._terminal.element || !this._terminal.element.parentElement)
            return;
          const e2 = this._terminal._core, t2 = e2._renderService.dimensions;
          if (t2.css.cell.width === 0 || t2.css.cell.height === 0)
            return;
          const r = this._terminal.options.scrollback === 0 ? 0 : e2.viewport.scrollBarWidth, i = window.getComputedStyle(this._terminal.element.parentElement), o = parseInt(i.getPropertyValue("height")), s = Math.max(0, parseInt(i.getPropertyValue("width"))), n = window.getComputedStyle(this._terminal.element), l = o - (parseInt(n.getPropertyValue("padding-top")) + parseInt(n.getPropertyValue("padding-bottom"))), a = s - (parseInt(n.getPropertyValue("padding-right")) + parseInt(n.getPropertyValue("padding-left"))) - r;
          return { cols: Math.max(2, Math.floor(a / t2.css.cell.width)), rows: Math.max(1, Math.floor(l / t2.css.cell.height)) };
        }
      };
    })(), e;
  })());
});

// node_modules/xterm-addon-web-links/lib/xterm-addon-web-links.js
var require_xterm_addon_web_links = __commonJS((exports, module) => {
  (function(e, t) {
    typeof exports == "object" && typeof module == "object" ? module.exports = t() : typeof define == "function" && define.amd ? define([], t) : typeof exports == "object" ? exports.WebLinksAddon = t() : e.WebLinksAddon = t();
  })(self, () => (() => {
    var e = { 6: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.LinkComputer = t2.WebLinkProvider = undefined, t2.WebLinkProvider = class {
        constructor(e3, t3, n3, i2 = {}) {
          this._terminal = e3, this._regex = t3, this._handler = n3, this._options = i2;
        }
        provideLinks(e3, t3) {
          const i2 = n2.computeLink(e3, this._regex, this._terminal, this._handler);
          t3(this._addCallbacks(i2));
        }
        _addCallbacks(e3) {
          return e3.map((e4) => (e4.leave = this._options.leave, e4.hover = (t3, n3) => {
            if (this._options.hover) {
              const { range: i2 } = e4;
              this._options.hover(t3, n3, i2);
            }
          }, e4));
        }
      };

      class n2 {
        static computeLink(e3, t3, i2, r) {
          const o = new RegExp(t3.source, (t3.flags || "") + "g"), [s, a] = n2._getWindowedLineStrings(e3 - 1, i2), c = s.join("");
          let d;
          const l = [];
          for (;d = o.exec(c); ) {
            const e4 = d[0];
            try {
              const t5 = new URL(e4), n3 = decodeURI(t5.toString());
              if (e4 !== n3 && e4 + "/" !== n3)
                continue;
            } catch (e5) {
              continue;
            }
            const [t4, o2] = n2._mapStrIdx(i2, a, 0, d.index), [s2, c2] = n2._mapStrIdx(i2, t4, o2, e4.length);
            if (t4 === -1 || o2 === -1 || s2 === -1 || c2 === -1)
              continue;
            const p = { start: { x: o2 + 1, y: t4 + 1 }, end: { x: c2, y: s2 + 1 } };
            l.push({ range: p, text: e4, activate: r });
          }
          return l;
        }
        static _getWindowedLineStrings(e3, t3) {
          let n3, i2 = e3, r = e3, o = 0, s = "";
          const a = [];
          if (n3 = t3.buffer.active.getLine(e3)) {
            const e4 = n3.translateToString(true);
            if (n3.isWrapped && e4[0] !== " ") {
              for (o = 0;(n3 = t3.buffer.active.getLine(--i2)) && o < 2048 && (s = n3.translateToString(true), o += s.length, a.push(s), n3.isWrapped && s.indexOf(" ") === -1); )
                ;
              a.reverse();
            }
            for (a.push(e4), o = 0;(n3 = t3.buffer.active.getLine(++r)) && n3.isWrapped && o < 2048 && (s = n3.translateToString(true), o += s.length, a.push(s), s.indexOf(" ") === -1); )
              ;
          }
          return [a, i2];
        }
        static _mapStrIdx(e3, t3, n3, i2) {
          const r = e3.buffer.active, o = r.getNullCell();
          let s = n3;
          for (;i2; ) {
            const e4 = r.getLine(t3);
            if (!e4)
              return [-1, -1];
            for (let n4 = s;n4 < e4.length; ++n4) {
              e4.getCell(n4, o);
              const s2 = o.getChars();
              if (o.getWidth() && (i2 -= s2.length || 1, n4 === e4.length - 1 && s2 === "")) {
                const e5 = r.getLine(t3 + 1);
                e5 && e5.isWrapped && (e5.getCell(0, o), o.getWidth() === 2 && (i2 += 1));
              }
              if (i2 < 0)
                return [t3, n4];
            }
            t3++, s = 0;
          }
          return [t3, s];
        }
      }
      t2.LinkComputer = n2;
    } }, t = {};
    function n(i2) {
      var r = t[i2];
      if (r !== undefined)
        return r.exports;
      var o = t[i2] = { exports: {} };
      return e[i2](o, o.exports, n), o.exports;
    }
    var i = {};
    return (() => {
      var e2 = i;
      Object.defineProperty(e2, "__esModule", { value: true }), e2.WebLinksAddon = undefined;
      const t2 = n(6), r = /https?:[/]{2}[^\s"'!*(){}|\\\^<>`]*[^\s"':,.!?{}|\\\^~\[\]`()<>]/;
      function o(e3, t3) {
        const n2 = window.open();
        if (n2) {
          try {
            n2.opener = null;
          } catch {
          }
          n2.location.href = t3;
        } else
          console.warn("Opening link blocked as opener could not be cleared");
      }
      e2.WebLinksAddon = class {
        constructor(e3 = o, t3 = {}) {
          this._handler = e3, this._options = t3;
        }
        activate(e3) {
          this._terminal = e3;
          const n2 = this._options, i2 = n2.urlRegex || r;
          this._linkProvider = this._terminal.registerLinkProvider(new t2.WebLinkProvider(this._terminal, i2, this._handler, n2));
        }
        dispose() {
          this._linkProvider?.dispose();
        }
      };
    })(), i;
  })());
});

// node_modules/opentype.js/dist/opentype.js
var require_opentype = __commonJS((exports, module) => {
  (function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global.opentype = global.opentype || {});
  })(exports, function(exports2) {
    var TINF_OK = 0;
    var TINF_DATA_ERROR = -3;
    function Tree() {
      this.table = new Uint16Array(16);
      this.trans = new Uint16Array(288);
    }
    function Data(source, dest) {
      this.source = source;
      this.sourceIndex = 0;
      this.tag = 0;
      this.bitcount = 0;
      this.dest = dest;
      this.destLen = 0;
      this.ltree = new Tree;
      this.dtree = new Tree;
    }
    var sltree = new Tree;
    var sdtree = new Tree;
    var length_bits = new Uint8Array(30);
    var length_base = new Uint16Array(30);
    var dist_bits = new Uint8Array(30);
    var dist_base = new Uint16Array(30);
    var clcidx = new Uint8Array([
      16,
      17,
      18,
      0,
      8,
      7,
      9,
      6,
      10,
      5,
      11,
      4,
      12,
      3,
      13,
      2,
      14,
      1,
      15
    ]);
    var code_tree = new Tree;
    var lengths = new Uint8Array(288 + 32);
    function tinf_build_bits_base(bits, base, delta, first) {
      var i, sum;
      for (i = 0;i < delta; ++i) {
        bits[i] = 0;
      }
      for (i = 0;i < 30 - delta; ++i) {
        bits[i + delta] = i / delta | 0;
      }
      for (sum = first, i = 0;i < 30; ++i) {
        base[i] = sum;
        sum += 1 << bits[i];
      }
    }
    function tinf_build_fixed_trees(lt, dt) {
      var i;
      for (i = 0;i < 7; ++i) {
        lt.table[i] = 0;
      }
      lt.table[7] = 24;
      lt.table[8] = 152;
      lt.table[9] = 112;
      for (i = 0;i < 24; ++i) {
        lt.trans[i] = 256 + i;
      }
      for (i = 0;i < 144; ++i) {
        lt.trans[24 + i] = i;
      }
      for (i = 0;i < 8; ++i) {
        lt.trans[24 + 144 + i] = 280 + i;
      }
      for (i = 0;i < 112; ++i) {
        lt.trans[24 + 144 + 8 + i] = 144 + i;
      }
      for (i = 0;i < 5; ++i) {
        dt.table[i] = 0;
      }
      dt.table[5] = 32;
      for (i = 0;i < 32; ++i) {
        dt.trans[i] = i;
      }
    }
    var offs = new Uint16Array(16);
    function tinf_build_tree(t, lengths2, off, num) {
      var i, sum;
      for (i = 0;i < 16; ++i) {
        t.table[i] = 0;
      }
      for (i = 0;i < num; ++i) {
        t.table[lengths2[off + i]]++;
      }
      t.table[0] = 0;
      for (sum = 0, i = 0;i < 16; ++i) {
        offs[i] = sum;
        sum += t.table[i];
      }
      for (i = 0;i < num; ++i) {
        if (lengths2[off + i]) {
          t.trans[offs[lengths2[off + i]]++] = i;
        }
      }
    }
    function tinf_getbit(d) {
      if (!d.bitcount--) {
        d.tag = d.source[d.sourceIndex++];
        d.bitcount = 7;
      }
      var bit = d.tag & 1;
      d.tag >>>= 1;
      return bit;
    }
    function tinf_read_bits(d, num, base) {
      if (!num) {
        return base;
      }
      while (d.bitcount < 24) {
        d.tag |= d.source[d.sourceIndex++] << d.bitcount;
        d.bitcount += 8;
      }
      var val = d.tag & 65535 >>> 16 - num;
      d.tag >>>= num;
      d.bitcount -= num;
      return val + base;
    }
    function tinf_decode_symbol(d, t) {
      while (d.bitcount < 24) {
        d.tag |= d.source[d.sourceIndex++] << d.bitcount;
        d.bitcount += 8;
      }
      var sum = 0, cur = 0, len = 0;
      var tag = d.tag;
      do {
        cur = 2 * cur + (tag & 1);
        tag >>>= 1;
        ++len;
        sum += t.table[len];
        cur -= t.table[len];
      } while (cur >= 0);
      d.tag = tag;
      d.bitcount -= len;
      return t.trans[sum + cur];
    }
    function tinf_decode_trees(d, lt, dt) {
      var hlit, hdist, hclen;
      var i, num, length;
      hlit = tinf_read_bits(d, 5, 257);
      hdist = tinf_read_bits(d, 5, 1);
      hclen = tinf_read_bits(d, 4, 4);
      for (i = 0;i < 19; ++i) {
        lengths[i] = 0;
      }
      for (i = 0;i < hclen; ++i) {
        var clen = tinf_read_bits(d, 3, 0);
        lengths[clcidx[i]] = clen;
      }
      tinf_build_tree(code_tree, lengths, 0, 19);
      for (num = 0;num < hlit + hdist; ) {
        var sym = tinf_decode_symbol(d, code_tree);
        switch (sym) {
          case 16:
            var prev = lengths[num - 1];
            for (length = tinf_read_bits(d, 2, 3);length; --length) {
              lengths[num++] = prev;
            }
            break;
          case 17:
            for (length = tinf_read_bits(d, 3, 3);length; --length) {
              lengths[num++] = 0;
            }
            break;
          case 18:
            for (length = tinf_read_bits(d, 7, 11);length; --length) {
              lengths[num++] = 0;
            }
            break;
          default:
            lengths[num++] = sym;
            break;
        }
      }
      tinf_build_tree(lt, lengths, 0, hlit);
      tinf_build_tree(dt, lengths, hlit, hdist);
    }
    function tinf_inflate_block_data(d, lt, dt) {
      while (true) {
        var sym = tinf_decode_symbol(d, lt);
        if (sym === 256) {
          return TINF_OK;
        }
        if (sym < 256) {
          d.dest[d.destLen++] = sym;
        } else {
          var length, dist, offs2;
          var i;
          sym -= 257;
          length = tinf_read_bits(d, length_bits[sym], length_base[sym]);
          dist = tinf_decode_symbol(d, dt);
          offs2 = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);
          for (i = offs2;i < offs2 + length; ++i) {
            d.dest[d.destLen++] = d.dest[i];
          }
        }
      }
    }
    function tinf_inflate_uncompressed_block(d) {
      var length, invlength;
      var i;
      while (d.bitcount > 8) {
        d.sourceIndex--;
        d.bitcount -= 8;
      }
      length = d.source[d.sourceIndex + 1];
      length = 256 * length + d.source[d.sourceIndex];
      invlength = d.source[d.sourceIndex + 3];
      invlength = 256 * invlength + d.source[d.sourceIndex + 2];
      if (length !== (~invlength & 65535)) {
        return TINF_DATA_ERROR;
      }
      d.sourceIndex += 4;
      for (i = length;i; --i) {
        d.dest[d.destLen++] = d.source[d.sourceIndex++];
      }
      d.bitcount = 0;
      return TINF_OK;
    }
    function tinf_uncompress(source, dest) {
      var d = new Data(source, dest);
      var bfinal, btype, res;
      do {
        bfinal = tinf_getbit(d);
        btype = tinf_read_bits(d, 2, 0);
        switch (btype) {
          case 0:
            res = tinf_inflate_uncompressed_block(d);
            break;
          case 1:
            res = tinf_inflate_block_data(d, sltree, sdtree);
            break;
          case 2:
            tinf_decode_trees(d, d.ltree, d.dtree);
            res = tinf_inflate_block_data(d, d.ltree, d.dtree);
            break;
          default:
            res = TINF_DATA_ERROR;
        }
        if (res !== TINF_OK) {
          throw new Error("Data error");
        }
      } while (!bfinal);
      if (d.destLen < d.dest.length) {
        if (typeof d.dest.slice === "function") {
          return d.dest.slice(0, d.destLen);
        } else {
          return d.dest.subarray(0, d.destLen);
        }
      }
      return d.dest;
    }
    tinf_build_fixed_trees(sltree, sdtree);
    tinf_build_bits_base(length_bits, length_base, 4, 3);
    tinf_build_bits_base(dist_bits, dist_base, 2, 1);
    length_bits[28] = 0;
    length_base[28] = 258;
    var tinyInflate = tinf_uncompress;
    function derive(v0, v1, v2, v3, t) {
      return Math.pow(1 - t, 3) * v0 + 3 * Math.pow(1 - t, 2) * t * v1 + 3 * (1 - t) * Math.pow(t, 2) * v2 + Math.pow(t, 3) * v3;
    }
    function BoundingBox() {
      this.x1 = Number.NaN;
      this.y1 = Number.NaN;
      this.x2 = Number.NaN;
      this.y2 = Number.NaN;
    }
    BoundingBox.prototype.isEmpty = function() {
      return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);
    };
    BoundingBox.prototype.addPoint = function(x, y) {
      if (typeof x === "number") {
        if (isNaN(this.x1) || isNaN(this.x2)) {
          this.x1 = x;
          this.x2 = x;
        }
        if (x < this.x1) {
          this.x1 = x;
        }
        if (x > this.x2) {
          this.x2 = x;
        }
      }
      if (typeof y === "number") {
        if (isNaN(this.y1) || isNaN(this.y2)) {
          this.y1 = y;
          this.y2 = y;
        }
        if (y < this.y1) {
          this.y1 = y;
        }
        if (y > this.y2) {
          this.y2 = y;
        }
      }
    };
    BoundingBox.prototype.addX = function(x) {
      this.addPoint(x, null);
    };
    BoundingBox.prototype.addY = function(y) {
      this.addPoint(null, y);
    };
    BoundingBox.prototype.addBezier = function(x0, y0, x1, y1, x2, y2, x, y) {
      var this$1 = this;
      var p0 = [x0, y0];
      var p1 = [x1, y1];
      var p2 = [x2, y2];
      var p3 = [x, y];
      this.addPoint(x0, y0);
      this.addPoint(x, y);
      for (var i = 0;i <= 1; i++) {
        var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
        var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
        var c = 3 * p1[i] - 3 * p0[i];
        if (a === 0) {
          if (b === 0) {
            continue;
          }
          var t = -c / b;
          if (0 < t && t < 1) {
            if (i === 0) {
              this$1.addX(derive(p0[i], p1[i], p2[i], p3[i], t));
            }
            if (i === 1) {
              this$1.addY(derive(p0[i], p1[i], p2[i], p3[i], t));
            }
          }
          continue;
        }
        var b2ac = Math.pow(b, 2) - 4 * c * a;
        if (b2ac < 0) {
          continue;
        }
        var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
        if (0 < t1 && t1 < 1) {
          if (i === 0) {
            this$1.addX(derive(p0[i], p1[i], p2[i], p3[i], t1));
          }
          if (i === 1) {
            this$1.addY(derive(p0[i], p1[i], p2[i], p3[i], t1));
          }
        }
        var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
        if (0 < t2 && t2 < 1) {
          if (i === 0) {
            this$1.addX(derive(p0[i], p1[i], p2[i], p3[i], t2));
          }
          if (i === 1) {
            this$1.addY(derive(p0[i], p1[i], p2[i], p3[i], t2));
          }
        }
      }
    };
    BoundingBox.prototype.addQuad = function(x0, y0, x1, y1, x, y) {
      var cp1x = x0 + 2 / 3 * (x1 - x0);
      var cp1y = y0 + 2 / 3 * (y1 - y0);
      var cp2x = cp1x + 1 / 3 * (x - x0);
      var cp2y = cp1y + 1 / 3 * (y - y0);
      this.addBezier(x0, y0, cp1x, cp1y, cp2x, cp2y, x, y);
    };
    function Path() {
      this.commands = [];
      this.fill = "black";
      this.stroke = null;
      this.strokeWidth = 1;
    }
    Path.prototype.moveTo = function(x, y) {
      this.commands.push({
        type: "M",
        x,
        y
      });
    };
    Path.prototype.lineTo = function(x, y) {
      this.commands.push({
        type: "L",
        x,
        y
      });
    };
    Path.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {
      this.commands.push({
        type: "C",
        x1,
        y1,
        x2,
        y2,
        x,
        y
      });
    };
    Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {
      this.commands.push({
        type: "Q",
        x1,
        y1,
        x,
        y
      });
    };
    Path.prototype.close = Path.prototype.closePath = function() {
      this.commands.push({
        type: "Z"
      });
    };
    Path.prototype.extend = function(pathOrCommands) {
      if (pathOrCommands.commands) {
        pathOrCommands = pathOrCommands.commands;
      } else if (pathOrCommands instanceof BoundingBox) {
        var box = pathOrCommands;
        this.moveTo(box.x1, box.y1);
        this.lineTo(box.x2, box.y1);
        this.lineTo(box.x2, box.y2);
        this.lineTo(box.x1, box.y2);
        this.close();
        return;
      }
      Array.prototype.push.apply(this.commands, pathOrCommands);
    };
    Path.prototype.getBoundingBox = function() {
      var this$1 = this;
      var box = new BoundingBox;
      var startX = 0;
      var startY = 0;
      var prevX = 0;
      var prevY = 0;
      for (var i = 0;i < this.commands.length; i++) {
        var cmd = this$1.commands[i];
        switch (cmd.type) {
          case "M":
            box.addPoint(cmd.x, cmd.y);
            startX = prevX = cmd.x;
            startY = prevY = cmd.y;
            break;
          case "L":
            box.addPoint(cmd.x, cmd.y);
            prevX = cmd.x;
            prevY = cmd.y;
            break;
          case "Q":
            box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y);
            prevX = cmd.x;
            prevY = cmd.y;
            break;
          case "C":
            box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
            prevX = cmd.x;
            prevY = cmd.y;
            break;
          case "Z":
            prevX = startX;
            prevY = startY;
            break;
          default:
            throw new Error("Unexpected path command " + cmd.type);
        }
      }
      if (box.isEmpty()) {
        box.addPoint(0, 0);
      }
      return box;
    };
    Path.prototype.draw = function(ctx) {
      var this$1 = this;
      ctx.beginPath();
      for (var i = 0;i < this.commands.length; i += 1) {
        var cmd = this$1.commands[i];
        if (cmd.type === "M") {
          ctx.moveTo(cmd.x, cmd.y);
        } else if (cmd.type === "L") {
          ctx.lineTo(cmd.x, cmd.y);
        } else if (cmd.type === "C") {
          ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        } else if (cmd.type === "Q") {
          ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
        } else if (cmd.type === "Z") {
          ctx.closePath();
        }
      }
      if (this.fill) {
        ctx.fillStyle = this.fill;
        ctx.fill();
      }
      if (this.stroke) {
        ctx.strokeStyle = this.stroke;
        ctx.lineWidth = this.strokeWidth;
        ctx.stroke();
      }
    };
    Path.prototype.toPathData = function(decimalPlaces) {
      var this$1 = this;
      decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;
      function floatToString(v) {
        if (Math.round(v) === v) {
          return "" + Math.round(v);
        } else {
          return v.toFixed(decimalPlaces);
        }
      }
      function packValues() {
        var arguments$1 = arguments;
        var s = "";
        for (var i2 = 0;i2 < arguments.length; i2 += 1) {
          var v = arguments$1[i2];
          if (v >= 0 && i2 > 0) {
            s += " ";
          }
          s += floatToString(v);
        }
        return s;
      }
      var d = "";
      for (var i = 0;i < this.commands.length; i += 1) {
        var cmd = this$1.commands[i];
        if (cmd.type === "M") {
          d += "M" + packValues(cmd.x, cmd.y);
        } else if (cmd.type === "L") {
          d += "L" + packValues(cmd.x, cmd.y);
        } else if (cmd.type === "C") {
          d += "C" + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        } else if (cmd.type === "Q") {
          d += "Q" + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);
        } else if (cmd.type === "Z") {
          d += "Z";
        }
      }
      return d;
    };
    Path.prototype.toSVG = function(decimalPlaces) {
      var svg = '<path d="';
      svg += this.toPathData(decimalPlaces);
      svg += '"';
      if (this.fill && this.fill !== "black") {
        if (this.fill === null) {
          svg += ' fill="none"';
        } else {
          svg += ' fill="' + this.fill + '"';
        }
      }
      if (this.stroke) {
        svg += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"';
      }
      svg += "/>";
      return svg;
    };
    Path.prototype.toDOMElement = function(decimalPlaces) {
      var temporaryPath = this.toPathData(decimalPlaces);
      var newPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
      newPath.setAttribute("d", temporaryPath);
      return newPath;
    };
    function fail(message) {
      throw new Error(message);
    }
    function argument(predicate, message) {
      if (!predicate) {
        fail(message);
      }
    }
    var check = { fail, argument, assert: argument };
    var LIMIT16 = 32768;
    var LIMIT32 = 2147483648;
    var decode = {};
    var encode = {};
    var sizeOf = {};
    function constant(v) {
      return function() {
        return v;
      };
    }
    encode.BYTE = function(v) {
      check.argument(v >= 0 && v <= 255, "Byte value should be between 0 and 255.");
      return [v];
    };
    sizeOf.BYTE = constant(1);
    encode.CHAR = function(v) {
      return [v.charCodeAt(0)];
    };
    sizeOf.CHAR = constant(1);
    encode.CHARARRAY = function(v) {
      var b = [];
      for (var i = 0;i < v.length; i += 1) {
        b[i] = v.charCodeAt(i);
      }
      return b;
    };
    sizeOf.CHARARRAY = function(v) {
      return v.length;
    };
    encode.USHORT = function(v) {
      return [v >> 8 & 255, v & 255];
    };
    sizeOf.USHORT = constant(2);
    encode.SHORT = function(v) {
      if (v >= LIMIT16) {
        v = -(2 * LIMIT16 - v);
      }
      return [v >> 8 & 255, v & 255];
    };
    sizeOf.SHORT = constant(2);
    encode.UINT24 = function(v) {
      return [v >> 16 & 255, v >> 8 & 255, v & 255];
    };
    sizeOf.UINT24 = constant(3);
    encode.ULONG = function(v) {
      return [v >> 24 & 255, v >> 16 & 255, v >> 8 & 255, v & 255];
    };
    sizeOf.ULONG = constant(4);
    encode.LONG = function(v) {
      if (v >= LIMIT32) {
        v = -(2 * LIMIT32 - v);
      }
      return [v >> 24 & 255, v >> 16 & 255, v >> 8 & 255, v & 255];
    };
    sizeOf.LONG = constant(4);
    encode.FIXED = encode.ULONG;
    sizeOf.FIXED = sizeOf.ULONG;
    encode.FWORD = encode.SHORT;
    sizeOf.FWORD = sizeOf.SHORT;
    encode.UFWORD = encode.USHORT;
    sizeOf.UFWORD = sizeOf.USHORT;
    encode.LONGDATETIME = function(v) {
      return [0, 0, 0, 0, v >> 24 & 255, v >> 16 & 255, v >> 8 & 255, v & 255];
    };
    sizeOf.LONGDATETIME = constant(8);
    encode.TAG = function(v) {
      check.argument(v.length === 4, "Tag should be exactly 4 ASCII characters.");
      return [
        v.charCodeAt(0),
        v.charCodeAt(1),
        v.charCodeAt(2),
        v.charCodeAt(3)
      ];
    };
    sizeOf.TAG = constant(4);
    encode.Card8 = encode.BYTE;
    sizeOf.Card8 = sizeOf.BYTE;
    encode.Card16 = encode.USHORT;
    sizeOf.Card16 = sizeOf.USHORT;
    encode.OffSize = encode.BYTE;
    sizeOf.OffSize = sizeOf.BYTE;
    encode.SID = encode.USHORT;
    sizeOf.SID = sizeOf.USHORT;
    encode.NUMBER = function(v) {
      if (v >= -107 && v <= 107) {
        return [v + 139];
      } else if (v >= 108 && v <= 1131) {
        v = v - 108;
        return [(v >> 8) + 247, v & 255];
      } else if (v >= -1131 && v <= -108) {
        v = -v - 108;
        return [(v >> 8) + 251, v & 255];
      } else if (v >= -32768 && v <= 32767) {
        return encode.NUMBER16(v);
      } else {
        return encode.NUMBER32(v);
      }
    };
    sizeOf.NUMBER = function(v) {
      return encode.NUMBER(v).length;
    };
    encode.NUMBER16 = function(v) {
      return [28, v >> 8 & 255, v & 255];
    };
    sizeOf.NUMBER16 = constant(3);
    encode.NUMBER32 = function(v) {
      return [29, v >> 24 & 255, v >> 16 & 255, v >> 8 & 255, v & 255];
    };
    sizeOf.NUMBER32 = constant(5);
    encode.REAL = function(v) {
      var value = v.toString();
      var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
      if (m) {
        var epsilon = parseFloat("1e" + ((m[2] ? +m[2] : 0) + m[1].length));
        value = (Math.round(v * epsilon) / epsilon).toString();
      }
      var nibbles = "";
      for (var i = 0, ii = value.length;i < ii; i += 1) {
        var c = value[i];
        if (c === "e") {
          nibbles += value[++i] === "-" ? "c" : "b";
        } else if (c === ".") {
          nibbles += "a";
        } else if (c === "-") {
          nibbles += "e";
        } else {
          nibbles += c;
        }
      }
      nibbles += nibbles.length & 1 ? "f" : "ff";
      var out = [30];
      for (var i$1 = 0, ii$1 = nibbles.length;i$1 < ii$1; i$1 += 2) {
        out.push(parseInt(nibbles.substr(i$1, 2), 16));
      }
      return out;
    };
    sizeOf.REAL = function(v) {
      return encode.REAL(v).length;
    };
    encode.NAME = encode.CHARARRAY;
    sizeOf.NAME = sizeOf.CHARARRAY;
    encode.STRING = encode.CHARARRAY;
    sizeOf.STRING = sizeOf.CHARARRAY;
    decode.UTF8 = function(data, offset, numBytes) {
      var codePoints = [];
      var numChars = numBytes;
      for (var j = 0;j < numChars; j++, offset += 1) {
        codePoints[j] = data.getUint8(offset);
      }
      return String.fromCharCode.apply(null, codePoints);
    };
    decode.UTF16 = function(data, offset, numBytes) {
      var codePoints = [];
      var numChars = numBytes / 2;
      for (var j = 0;j < numChars; j++, offset += 2) {
        codePoints[j] = data.getUint16(offset);
      }
      return String.fromCharCode.apply(null, codePoints);
    };
    encode.UTF16 = function(v) {
      var b = [];
      for (var i = 0;i < v.length; i += 1) {
        var codepoint = v.charCodeAt(i);
        b[b.length] = codepoint >> 8 & 255;
        b[b.length] = codepoint & 255;
      }
      return b;
    };
    sizeOf.UTF16 = function(v) {
      return v.length * 2;
    };
    var eightBitMacEncodings = {
      "x-mac-croatian": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\u0160\u2122\xB4\xA8\u2260\u017D\xD8\u221E\xB1\u2264\u2265\u2206\xB5\u2202\u2211\u220F\u0161\u222B\xAA\xBA\u03A9\u017E\xF8" + "\xBF\xA1\xAC\u221A\u0192\u2248\u0106\xAB\u010C\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u0110\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\uF8FF\xA9\u2044\u20AC\u2039\u203A\xC6\xBB\u2013\xB7\u201A\u201E\u2030\xC2\u0107\xC1\u010D\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u0111\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u03C0\xCB\u02DA\xB8\xCA\xE6\u02C7",
      "x-mac-cyrillic": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xB0\u0490\xA3\xA7\u2022\xB6\u0406\xAE\xA9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xB1\u2264\u2265\u0456\xB5\u0491\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A" + "\u0458\u0405\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E",
      "x-mac-gaelic": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u1E02\xB1\u2264\u2265\u1E03\u010A\u010B\u1E0A\u1E0B\u1E1E\u1E1F\u0120\u0121\u1E40\xE6\xF8" + "\u1E41\u1E56\u1E57\u027C\u0192\u017F\u1E60\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\u1E61\u1E9B\xFF\u0178\u1E6A\u20AC\u2039\u203A\u0176\u0177\u1E6B\xB7\u1EF2\u1EF3\u204A\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u2663\xD2\xDA\xDB\xD9\u0131\xDD\xFD\u0174\u0175\u1E84\u1E85\u1E80\u1E81\u1E82\u1E83",
      "x-mac-greek": "\xC4\xB9\xB2\xC9\xB3\xD6\xDC\u0385\xE0\xE2\xE4\u0384\xA8\xE7\xE9\xE8\xEA\xEB\xA3\u2122\xEE\xEF\u2022\xBD\u2030\xF4\xF6\xA6\u20AC\xF9\xFB\xFC\u2020\u0393\u0394\u0398\u039B\u039E\u03A0\xDF\xAE\xA9\u03A3\u03AA\xA7\u2260\xB0\xB7\u0391\xB1\u2264\u2265\xA5\u0392\u0395\u0396\u0397\u0399\u039A\u039C\u03A6\u03AB\u03A8\u03A9" + "\u03AC\u039D\xAC\u039F\u03A1\u2248\u03A4\xAB\xBB\u2026\xA0\u03A5\u03A7\u0386\u0388\u0153\u2013\u2015\u201C\u201D\u2018\u2019\xF7\u0389\u038A\u038C\u038E\u03AD\u03AE\u03AF\u03CC\u038F\u03CD\u03B1\u03B2\u03C8\u03B4\u03B5\u03C6\u03B3\u03B7\u03B9\u03BE\u03BA\u03BB\u03BC\u03BD\u03BF\u03C0\u03CE\u03C1\u03C3\u03C4\u03B8\u03C9\u03C2\u03C7\u03C5\u03B6\u03CA\u03CB\u0390\u03B0\xAD",
      "x-mac-icelandic": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\xDD\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8" + "\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\xD0\xF0\xDE\xFE\xFD\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7",
      "x-mac-inuit": "\u1403\u1404\u1405\u1406\u140A\u140B\u1431\u1432\u1433\u1434\u1438\u1439\u1449\u144E\u144F\u1450\u1451\u1455\u1456\u1466\u146D\u146E\u146F\u1470\u1472\u1473\u1483\u148B\u148C\u148D\u148E\u1490\u1491\xB0\u14A1\u14A5\u14A6\u2022\xB6\u14A7\xAE\xA9\u2122\u14A8\u14AA\u14AB\u14BB\u14C2\u14C3\u14C4\u14C5\u14C7\u14C8\u14D0\u14EF\u14F0\u14F1\u14F2\u14F4\u14F5\u1505\u14D5\u14D6\u14D7" + "\u14D8\u14DA\u14DB\u14EA\u1528\u1529\u152A\u152B\u152D\u2026\xA0\u152E\u153E\u1555\u1556\u1557\u2013\u2014\u201C\u201D\u2018\u2019\u1558\u1559\u155A\u155D\u1546\u1547\u1548\u1549\u154B\u154C\u1550\u157F\u1580\u1581\u1582\u1583\u1584\u1585\u158F\u1590\u1591\u1592\u1593\u1594\u1595\u1671\u1672\u1673\u1674\u1675\u1676\u1596\u15A0\u15A1\u15A2\u15A3\u15A4\u15A5\u15A6\u157C\u0141\u0142",
      "x-mac-ce": "\xC4\u0100\u0101\xC9\u0104\xD6\xDC\xE1\u0105\u010C\xE4\u010D\u0106\u0107\xE9\u0179\u017A\u010E\xED\u010F\u0112\u0113\u0116\xF3\u0117\xF4\xF6\xF5\xFA\u011A\u011B\xFC\u2020\xB0\u0118\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\u0119\xA8\u2260\u0123\u012E\u012F\u012A\u2264\u2265\u012B\u0136\u2202\u2211\u0142\u013B\u013C\u013D\u013E\u0139\u013A\u0145" + "\u0146\u0143\xAC\u221A\u0144\u0147\u2206\xAB\xBB\u2026\xA0\u0148\u0150\xD5\u0151\u014C\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\u014D\u0154\u0155\u0158\u2039\u203A\u0159\u0156\u0157\u0160\u201A\u201E\u0161\u015A\u015B\xC1\u0164\u0165\xCD\u017D\u017E\u016A\xD3\xD4\u016B\u016E\xDA\u016F\u0170\u0171\u0172\u0173\xDD\xFD\u0137\u017B\u0141\u017C\u0122\u02C7",
      macintosh: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8" + "\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\u2039\u203A\uFB01\uFB02\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7",
      "x-mac-romanian": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\u0102\u0218\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\u0103\u0219" + "\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\u2039\u203A\u021A\u021B\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7",
      "x-mac-turkish": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8" + "\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u011E\u011F\u0130\u0131\u015E\u015F\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\uF8A0\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
    };
    decode.MACSTRING = function(dataView, offset, dataLength, encoding) {
      var table2 = eightBitMacEncodings[encoding];
      if (table2 === undefined) {
        return;
      }
      var result = "";
      for (var i = 0;i < dataLength; i++) {
        var c = dataView.getUint8(offset + i);
        if (c <= 127) {
          result += String.fromCharCode(c);
        } else {
          result += table2[c & 127];
        }
      }
      return result;
    };
    var macEncodingTableCache = typeof WeakMap === "function" && new WeakMap;
    var macEncodingCacheKeys;
    var getMacEncodingTable = function(encoding) {
      if (!macEncodingCacheKeys) {
        macEncodingCacheKeys = {};
        for (var e in eightBitMacEncodings) {
          macEncodingCacheKeys[e] = new String(e);
        }
      }
      var cacheKey = macEncodingCacheKeys[encoding];
      if (cacheKey === undefined) {
        return;
      }
      if (macEncodingTableCache) {
        var cachedTable = macEncodingTableCache.get(cacheKey);
        if (cachedTable !== undefined) {
          return cachedTable;
        }
      }
      var decodingTable = eightBitMacEncodings[encoding];
      if (decodingTable === undefined) {
        return;
      }
      var encodingTable = {};
      for (var i = 0;i < decodingTable.length; i++) {
        encodingTable[decodingTable.charCodeAt(i)] = i + 128;
      }
      if (macEncodingTableCache) {
        macEncodingTableCache.set(cacheKey, encodingTable);
      }
      return encodingTable;
    };
    encode.MACSTRING = function(str, encoding) {
      var table2 = getMacEncodingTable(encoding);
      if (table2 === undefined) {
        return;
      }
      var result = [];
      for (var i = 0;i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c >= 128) {
          c = table2[c];
          if (c === undefined) {
            return;
          }
        }
        result[i] = c;
      }
      return result;
    };
    sizeOf.MACSTRING = function(str, encoding) {
      var b = encode.MACSTRING(str, encoding);
      if (b !== undefined) {
        return b.length;
      } else {
        return 0;
      }
    };
    function isByteEncodable(value) {
      return value >= -128 && value <= 127;
    }
    function encodeVarDeltaRunAsZeroes(deltas, pos, result) {
      var runLength = 0;
      var numDeltas = deltas.length;
      while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {
        ++pos;
        ++runLength;
      }
      result.push(128 | runLength - 1);
      return pos;
    }
    function encodeVarDeltaRunAsBytes(deltas, offset, result) {
      var runLength = 0;
      var numDeltas = deltas.length;
      var pos = offset;
      while (pos < numDeltas && runLength < 64) {
        var value = deltas[pos];
        if (!isByteEncodable(value)) {
          break;
        }
        if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {
          break;
        }
        ++pos;
        ++runLength;
      }
      result.push(runLength - 1);
      for (var i = offset;i < pos; ++i) {
        result.push(deltas[i] + 256 & 255);
      }
      return pos;
    }
    function encodeVarDeltaRunAsWords(deltas, offset, result) {
      var runLength = 0;
      var numDeltas = deltas.length;
      var pos = offset;
      while (pos < numDeltas && runLength < 64) {
        var value = deltas[pos];
        if (value === 0) {
          break;
        }
        if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {
          break;
        }
        ++pos;
        ++runLength;
      }
      result.push(64 | runLength - 1);
      for (var i = offset;i < pos; ++i) {
        var val = deltas[i];
        result.push(val + 65536 >> 8 & 255, val + 256 & 255);
      }
      return pos;
    }
    encode.VARDELTAS = function(deltas) {
      var pos = 0;
      var result = [];
      while (pos < deltas.length) {
        var value = deltas[pos];
        if (value === 0) {
          pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);
        } else if (value >= -128 && value <= 127) {
          pos = encodeVarDeltaRunAsBytes(deltas, pos, result);
        } else {
          pos = encodeVarDeltaRunAsWords(deltas, pos, result);
        }
      }
      return result;
    };
    encode.INDEX = function(l) {
      var offset = 1;
      var offsets = [offset];
      var data = [];
      for (var i = 0;i < l.length; i += 1) {
        var v = encode.OBJECT(l[i]);
        Array.prototype.push.apply(data, v);
        offset += v.length;
        offsets.push(offset);
      }
      if (data.length === 0) {
        return [0, 0];
      }
      var encodedOffsets = [];
      var offSize = 1 + Math.floor(Math.log(offset) / Math.log(2)) / 8 | 0;
      var offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];
      for (var i$1 = 0;i$1 < offsets.length; i$1 += 1) {
        var encodedOffset = offsetEncoder(offsets[i$1]);
        Array.prototype.push.apply(encodedOffsets, encodedOffset);
      }
      return Array.prototype.concat(encode.Card16(l.length), encode.OffSize(offSize), encodedOffsets, data);
    };
    sizeOf.INDEX = function(v) {
      return encode.INDEX(v).length;
    };
    encode.DICT = function(m) {
      var d = [];
      var keys = Object.keys(m);
      var length = keys.length;
      for (var i = 0;i < length; i += 1) {
        var k = parseInt(keys[i], 0);
        var v = m[k];
        d = d.concat(encode.OPERAND(v.value, v.type));
        d = d.concat(encode.OPERATOR(k));
      }
      return d;
    };
    sizeOf.DICT = function(m) {
      return encode.DICT(m).length;
    };
    encode.OPERATOR = function(v) {
      if (v < 1200) {
        return [v];
      } else {
        return [12, v - 1200];
      }
    };
    encode.OPERAND = function(v, type) {
      var d = [];
      if (Array.isArray(type)) {
        for (var i = 0;i < type.length; i += 1) {
          check.argument(v.length === type.length, "Not enough arguments given for type" + type);
          d = d.concat(encode.OPERAND(v[i], type[i]));
        }
      } else {
        if (type === "SID") {
          d = d.concat(encode.NUMBER(v));
        } else if (type === "offset") {
          d = d.concat(encode.NUMBER32(v));
        } else if (type === "number") {
          d = d.concat(encode.NUMBER(v));
        } else if (type === "real") {
          d = d.concat(encode.REAL(v));
        } else {
          throw new Error("Unknown operand type " + type);
        }
      }
      return d;
    };
    encode.OP = encode.BYTE;
    sizeOf.OP = sizeOf.BYTE;
    var wmm = typeof WeakMap === "function" && new WeakMap;
    encode.CHARSTRING = function(ops) {
      if (wmm) {
        var cachedValue = wmm.get(ops);
        if (cachedValue !== undefined) {
          return cachedValue;
        }
      }
      var d = [];
      var length = ops.length;
      for (var i = 0;i < length; i += 1) {
        var op = ops[i];
        d = d.concat(encode[op.type](op.value));
      }
      if (wmm) {
        wmm.set(ops, d);
      }
      return d;
    };
    sizeOf.CHARSTRING = function(ops) {
      return encode.CHARSTRING(ops).length;
    };
    encode.OBJECT = function(v) {
      var encodingFunction = encode[v.type];
      check.argument(encodingFunction !== undefined, "No encoding function for type " + v.type);
      return encodingFunction(v.value);
    };
    sizeOf.OBJECT = function(v) {
      var sizeOfFunction = sizeOf[v.type];
      check.argument(sizeOfFunction !== undefined, "No sizeOf function for type " + v.type);
      return sizeOfFunction(v.value);
    };
    encode.TABLE = function(table2) {
      var d = [];
      var length = table2.fields.length;
      var subtables = [];
      var subtableOffsets = [];
      for (var i = 0;i < length; i += 1) {
        var field = table2.fields[i];
        var encodingFunction = encode[field.type];
        check.argument(encodingFunction !== undefined, "No encoding function for field type " + field.type + " (" + field.name + ")");
        var value = table2[field.name];
        if (value === undefined) {
          value = field.value;
        }
        var bytes = encodingFunction(value);
        if (field.type === "TABLE") {
          subtableOffsets.push(d.length);
          d = d.concat([0, 0]);
          subtables.push(bytes);
        } else {
          d = d.concat(bytes);
        }
      }
      for (var i$1 = 0;i$1 < subtables.length; i$1 += 1) {
        var o = subtableOffsets[i$1];
        var offset = d.length;
        check.argument(offset < 65536, "Table " + table2.tableName + " too big.");
        d[o] = offset >> 8;
        d[o + 1] = offset & 255;
        d = d.concat(subtables[i$1]);
      }
      return d;
    };
    sizeOf.TABLE = function(table2) {
      var numBytes = 0;
      var length = table2.fields.length;
      for (var i = 0;i < length; i += 1) {
        var field = table2.fields[i];
        var sizeOfFunction = sizeOf[field.type];
        check.argument(sizeOfFunction !== undefined, "No sizeOf function for field type " + field.type + " (" + field.name + ")");
        var value = table2[field.name];
        if (value === undefined) {
          value = field.value;
        }
        numBytes += sizeOfFunction(value);
        if (field.type === "TABLE") {
          numBytes += 2;
        }
      }
      return numBytes;
    };
    encode.RECORD = encode.TABLE;
    sizeOf.RECORD = sizeOf.TABLE;
    encode.LITERAL = function(v) {
      return v;
    };
    sizeOf.LITERAL = function(v) {
      return v.length;
    };
    function Table(tableName, fields, options) {
      var this$1 = this;
      for (var i = 0;i < fields.length; i += 1) {
        var field = fields[i];
        this$1[field.name] = field.value;
      }
      this.tableName = tableName;
      this.fields = fields;
      if (options) {
        var optionKeys = Object.keys(options);
        for (var i$1 = 0;i$1 < optionKeys.length; i$1 += 1) {
          var k = optionKeys[i$1];
          var v = options[k];
          if (this$1[k] !== undefined) {
            this$1[k] = v;
          }
        }
      }
    }
    Table.prototype.encode = function() {
      return encode.TABLE(this);
    };
    Table.prototype.sizeOf = function() {
      return sizeOf.TABLE(this);
    };
    function ushortList(itemName, list, count) {
      if (count === undefined) {
        count = list.length;
      }
      var fields = new Array(list.length + 1);
      fields[0] = { name: itemName + "Count", type: "USHORT", value: count };
      for (var i = 0;i < list.length; i++) {
        fields[i + 1] = { name: itemName + i, type: "USHORT", value: list[i] };
      }
      return fields;
    }
    function tableList(itemName, records, itemCallback) {
      var count = records.length;
      var fields = new Array(count + 1);
      fields[0] = { name: itemName + "Count", type: "USHORT", value: count };
      for (var i = 0;i < count; i++) {
        fields[i + 1] = { name: itemName + i, type: "TABLE", value: itemCallback(records[i], i) };
      }
      return fields;
    }
    function recordList(itemName, records, itemCallback) {
      var count = records.length;
      var fields = [];
      fields[0] = { name: itemName + "Count", type: "USHORT", value: count };
      for (var i = 0;i < count; i++) {
        fields = fields.concat(itemCallback(records[i], i));
      }
      return fields;
    }
    function Coverage(coverageTable) {
      if (coverageTable.format === 1) {
        Table.call(this, "coverageTable", [{ name: "coverageFormat", type: "USHORT", value: 1 }].concat(ushortList("glyph", coverageTable.glyphs)));
      } else {
        check.assert(false, "Can\'t create coverage table format 2 yet.");
      }
    }
    Coverage.prototype = Object.create(Table.prototype);
    Coverage.prototype.constructor = Coverage;
    function ScriptList(scriptListTable) {
      Table.call(this, "scriptListTable", recordList("scriptRecord", scriptListTable, function(scriptRecord, i) {
        var script = scriptRecord.script;
        var defaultLangSys = script.defaultLangSys;
        check.assert(!!defaultLangSys, "Unable to write GSUB: script " + scriptRecord.tag + " has no default language system.");
        return [
          { name: "scriptTag" + i, type: "TAG", value: scriptRecord.tag },
          { name: "script" + i, type: "TABLE", value: new Table("scriptTable", [
            { name: "defaultLangSys", type: "TABLE", value: new Table("defaultLangSys", [
              { name: "lookupOrder", type: "USHORT", value: 0 },
              { name: "reqFeatureIndex", type: "USHORT", value: defaultLangSys.reqFeatureIndex }
            ].concat(ushortList("featureIndex", defaultLangSys.featureIndexes))) }
          ].concat(recordList("langSys", script.langSysRecords, function(langSysRecord, i2) {
            var langSys = langSysRecord.langSys;
            return [
              { name: "langSysTag" + i2, type: "TAG", value: langSysRecord.tag },
              { name: "langSys" + i2, type: "TABLE", value: new Table("langSys", [
                { name: "lookupOrder", type: "USHORT", value: 0 },
                { name: "reqFeatureIndex", type: "USHORT", value: langSys.reqFeatureIndex }
              ].concat(ushortList("featureIndex", langSys.featureIndexes))) }
            ];
          }))) }
        ];
      }));
    }
    ScriptList.prototype = Object.create(Table.prototype);
    ScriptList.prototype.constructor = ScriptList;
    function FeatureList(featureListTable) {
      Table.call(this, "featureListTable", recordList("featureRecord", featureListTable, function(featureRecord, i) {
        var feature = featureRecord.feature;
        return [
          { name: "featureTag" + i, type: "TAG", value: featureRecord.tag },
          { name: "feature" + i, type: "TABLE", value: new Table("featureTable", [
            { name: "featureParams", type: "USHORT", value: feature.featureParams }
          ].concat(ushortList("lookupListIndex", feature.lookupListIndexes))) }
        ];
      }));
    }
    FeatureList.prototype = Object.create(Table.prototype);
    FeatureList.prototype.constructor = FeatureList;
    function LookupList(lookupListTable, subtableMakers2) {
      Table.call(this, "lookupListTable", tableList("lookup", lookupListTable, function(lookupTable) {
        var subtableCallback = subtableMakers2[lookupTable.lookupType];
        check.assert(!!subtableCallback, "Unable to write GSUB lookup type " + lookupTable.lookupType + " tables.");
        return new Table("lookupTable", [
          { name: "lookupType", type: "USHORT", value: lookupTable.lookupType },
          { name: "lookupFlag", type: "USHORT", value: lookupTable.lookupFlag }
        ].concat(tableList("subtable", lookupTable.subtables, subtableCallback)));
      }));
    }
    LookupList.prototype = Object.create(Table.prototype);
    LookupList.prototype.constructor = LookupList;
    var table = {
      Table,
      Record: Table,
      Coverage,
      ScriptList,
      FeatureList,
      LookupList,
      ushortList,
      tableList,
      recordList
    };
    function getByte(dataView, offset) {
      return dataView.getUint8(offset);
    }
    function getUShort(dataView, offset) {
      return dataView.getUint16(offset, false);
    }
    function getShort(dataView, offset) {
      return dataView.getInt16(offset, false);
    }
    function getULong(dataView, offset) {
      return dataView.getUint32(offset, false);
    }
    function getFixed(dataView, offset) {
      var decimal = dataView.getInt16(offset, false);
      var fraction = dataView.getUint16(offset + 2, false);
      return decimal + fraction / 65535;
    }
    function getTag(dataView, offset) {
      var tag = "";
      for (var i = offset;i < offset + 4; i += 1) {
        tag += String.fromCharCode(dataView.getInt8(i));
      }
      return tag;
    }
    function getOffset(dataView, offset, offSize) {
      var v = 0;
      for (var i = 0;i < offSize; i += 1) {
        v <<= 8;
        v += dataView.getUint8(offset + i);
      }
      return v;
    }
    function getBytes(dataView, startOffset, endOffset) {
      var bytes = [];
      for (var i = startOffset;i < endOffset; i += 1) {
        bytes.push(dataView.getUint8(i));
      }
      return bytes;
    }
    function bytesToString(bytes) {
      var s = "";
      for (var i = 0;i < bytes.length; i += 1) {
        s += String.fromCharCode(bytes[i]);
      }
      return s;
    }
    var typeOffsets = {
      byte: 1,
      uShort: 2,
      short: 2,
      uLong: 4,
      fixed: 4,
      longDateTime: 8,
      tag: 4
    };
    function Parser(data, offset) {
      this.data = data;
      this.offset = offset;
      this.relativeOffset = 0;
    }
    Parser.prototype.parseByte = function() {
      var v = this.data.getUint8(this.offset + this.relativeOffset);
      this.relativeOffset += 1;
      return v;
    };
    Parser.prototype.parseChar = function() {
      var v = this.data.getInt8(this.offset + this.relativeOffset);
      this.relativeOffset += 1;
      return v;
    };
    Parser.prototype.parseCard8 = Parser.prototype.parseByte;
    Parser.prototype.parseUShort = function() {
      var v = this.data.getUint16(this.offset + this.relativeOffset);
      this.relativeOffset += 2;
      return v;
    };
    Parser.prototype.parseCard16 = Parser.prototype.parseUShort;
    Parser.prototype.parseSID = Parser.prototype.parseUShort;
    Parser.prototype.parseOffset16 = Parser.prototype.parseUShort;
    Parser.prototype.parseShort = function() {
      var v = this.data.getInt16(this.offset + this.relativeOffset);
      this.relativeOffset += 2;
      return v;
    };
    Parser.prototype.parseF2Dot14 = function() {
      var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
      this.relativeOffset += 2;
      return v;
    };
    Parser.prototype.parseULong = function() {
      var v = getULong(this.data, this.offset + this.relativeOffset);
      this.relativeOffset += 4;
      return v;
    };
    Parser.prototype.parseOffset32 = Parser.prototype.parseULong;
    Parser.prototype.parseFixed = function() {
      var v = getFixed(this.data, this.offset + this.relativeOffset);
      this.relativeOffset += 4;
      return v;
    };
    Parser.prototype.parseString = function(length) {
      var dataView = this.data;
      var offset = this.offset + this.relativeOffset;
      var string = "";
      this.relativeOffset += length;
      for (var i = 0;i < length; i++) {
        string += String.fromCharCode(dataView.getUint8(offset + i));
      }
      return string;
    };
    Parser.prototype.parseTag = function() {
      return this.parseString(4);
    };
    Parser.prototype.parseLongDateTime = function() {
      var v = getULong(this.data, this.offset + this.relativeOffset + 4);
      v -= 2082844800;
      this.relativeOffset += 8;
      return v;
    };
    Parser.prototype.parseVersion = function(minorBase) {
      var major = getUShort(this.data, this.offset + this.relativeOffset);
      var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);
      this.relativeOffset += 4;
      if (minorBase === undefined) {
        minorBase = 4096;
      }
      return major + minor / minorBase / 10;
    };
    Parser.prototype.skip = function(type, amount) {
      if (amount === undefined) {
        amount = 1;
      }
      this.relativeOffset += typeOffsets[type] * amount;
    };
    Parser.prototype.parseULongList = function(count) {
      if (count === undefined) {
        count = this.parseULong();
      }
      var offsets = new Array(count);
      var dataView = this.data;
      var offset = this.offset + this.relativeOffset;
      for (var i = 0;i < count; i++) {
        offsets[i] = dataView.getUint32(offset);
        offset += 4;
      }
      this.relativeOffset += count * 4;
      return offsets;
    };
    Parser.prototype.parseOffset16List = Parser.prototype.parseUShortList = function(count) {
      if (count === undefined) {
        count = this.parseUShort();
      }
      var offsets = new Array(count);
      var dataView = this.data;
      var offset = this.offset + this.relativeOffset;
      for (var i = 0;i < count; i++) {
        offsets[i] = dataView.getUint16(offset);
        offset += 2;
      }
      this.relativeOffset += count * 2;
      return offsets;
    };
    Parser.prototype.parseShortList = function(count) {
      var list = new Array(count);
      var dataView = this.data;
      var offset = this.offset + this.relativeOffset;
      for (var i = 0;i < count; i++) {
        list[i] = dataView.getInt16(offset);
        offset += 2;
      }
      this.relativeOffset += count * 2;
      return list;
    };
    Parser.prototype.parseByteList = function(count) {
      var list = new Array(count);
      var dataView = this.data;
      var offset = this.offset + this.relativeOffset;
      for (var i = 0;i < count; i++) {
        list[i] = dataView.getUint8(offset++);
      }
      this.relativeOffset += count;
      return list;
    };
    Parser.prototype.parseList = function(count, itemCallback) {
      var this$1 = this;
      if (!itemCallback) {
        itemCallback = count;
        count = this.parseUShort();
      }
      var list = new Array(count);
      for (var i = 0;i < count; i++) {
        list[i] = itemCallback.call(this$1);
      }
      return list;
    };
    Parser.prototype.parseList32 = function(count, itemCallback) {
      var this$1 = this;
      if (!itemCallback) {
        itemCallback = count;
        count = this.parseULong();
      }
      var list = new Array(count);
      for (var i = 0;i < count; i++) {
        list[i] = itemCallback.call(this$1);
      }
      return list;
    };
    Parser.prototype.parseRecordList = function(count, recordDescription) {
      var this$1 = this;
      if (!recordDescription) {
        recordDescription = count;
        count = this.parseUShort();
      }
      var records = new Array(count);
      var fields = Object.keys(recordDescription);
      for (var i = 0;i < count; i++) {
        var rec = {};
        for (var j = 0;j < fields.length; j++) {
          var fieldName = fields[j];
          var fieldType = recordDescription[fieldName];
          rec[fieldName] = fieldType.call(this$1);
        }
        records[i] = rec;
      }
      return records;
    };
    Parser.prototype.parseRecordList32 = function(count, recordDescription) {
      var this$1 = this;
      if (!recordDescription) {
        recordDescription = count;
        count = this.parseULong();
      }
      var records = new Array(count);
      var fields = Object.keys(recordDescription);
      for (var i = 0;i < count; i++) {
        var rec = {};
        for (var j = 0;j < fields.length; j++) {
          var fieldName = fields[j];
          var fieldType = recordDescription[fieldName];
          rec[fieldName] = fieldType.call(this$1);
        }
        records[i] = rec;
      }
      return records;
    };
    Parser.prototype.parseStruct = function(description) {
      var this$1 = this;
      if (typeof description === "function") {
        return description.call(this);
      } else {
        var fields = Object.keys(description);
        var struct = {};
        for (var j = 0;j < fields.length; j++) {
          var fieldName = fields[j];
          var fieldType = description[fieldName];
          struct[fieldName] = fieldType.call(this$1);
        }
        return struct;
      }
    };
    Parser.prototype.parseValueRecord = function(valueFormat) {
      if (valueFormat === undefined) {
        valueFormat = this.parseUShort();
      }
      if (valueFormat === 0) {
        return;
      }
      var valueRecord = {};
      if (valueFormat & 1) {
        valueRecord.xPlacement = this.parseShort();
      }
      if (valueFormat & 2) {
        valueRecord.yPlacement = this.parseShort();
      }
      if (valueFormat & 4) {
        valueRecord.xAdvance = this.parseShort();
      }
      if (valueFormat & 8) {
        valueRecord.yAdvance = this.parseShort();
      }
      if (valueFormat & 16) {
        valueRecord.xPlaDevice = undefined;
        this.parseShort();
      }
      if (valueFormat & 32) {
        valueRecord.yPlaDevice = undefined;
        this.parseShort();
      }
      if (valueFormat & 64) {
        valueRecord.xAdvDevice = undefined;
        this.parseShort();
      }
      if (valueFormat & 128) {
        valueRecord.yAdvDevice = undefined;
        this.parseShort();
      }
      return valueRecord;
    };
    Parser.prototype.parseValueRecordList = function() {
      var this$1 = this;
      var valueFormat = this.parseUShort();
      var valueCount = this.parseUShort();
      var values = new Array(valueCount);
      for (var i = 0;i < valueCount; i++) {
        values[i] = this$1.parseValueRecord(valueFormat);
      }
      return values;
    };
    Parser.prototype.parsePointer = function(description) {
      var structOffset = this.parseOffset16();
      if (structOffset > 0) {
        return new Parser(this.data, this.offset + structOffset).parseStruct(description);
      }
      return;
    };
    Parser.prototype.parsePointer32 = function(description) {
      var structOffset = this.parseOffset32();
      if (structOffset > 0) {
        return new Parser(this.data, this.offset + structOffset).parseStruct(description);
      }
      return;
    };
    Parser.prototype.parseListOfLists = function(itemCallback) {
      var this$1 = this;
      var offsets = this.parseOffset16List();
      var count = offsets.length;
      var relativeOffset = this.relativeOffset;
      var list = new Array(count);
      for (var i = 0;i < count; i++) {
        var start = offsets[i];
        if (start === 0) {
          list[i] = undefined;
          continue;
        }
        this$1.relativeOffset = start;
        if (itemCallback) {
          var subOffsets = this$1.parseOffset16List();
          var subList = new Array(subOffsets.length);
          for (var j = 0;j < subOffsets.length; j++) {
            this$1.relativeOffset = start + subOffsets[j];
            subList[j] = itemCallback.call(this$1);
          }
          list[i] = subList;
        } else {
          list[i] = this$1.parseUShortList();
        }
      }
      this.relativeOffset = relativeOffset;
      return list;
    };
    Parser.prototype.parseCoverage = function() {
      var this$1 = this;
      var startOffset = this.offset + this.relativeOffset;
      var format = this.parseUShort();
      var count = this.parseUShort();
      if (format === 1) {
        return {
          format: 1,
          glyphs: this.parseUShortList(count)
        };
      } else if (format === 2) {
        var ranges = new Array(count);
        for (var i = 0;i < count; i++) {
          ranges[i] = {
            start: this$1.parseUShort(),
            end: this$1.parseUShort(),
            index: this$1.parseUShort()
          };
        }
        return {
          format: 2,
          ranges
        };
      }
      throw new Error("0x" + startOffset.toString(16) + ": Coverage format must be 1 or 2.");
    };
    Parser.prototype.parseClassDef = function() {
      var startOffset = this.offset + this.relativeOffset;
      var format = this.parseUShort();
      if (format === 1) {
        return {
          format: 1,
          startGlyph: this.parseUShort(),
          classes: this.parseUShortList()
        };
      } else if (format === 2) {
        return {
          format: 2,
          ranges: this.parseRecordList({
            start: Parser.uShort,
            end: Parser.uShort,
            classId: Parser.uShort
          })
        };
      }
      throw new Error("0x" + startOffset.toString(16) + ": ClassDef format must be 1 or 2.");
    };
    Parser.list = function(count, itemCallback) {
      return function() {
        return this.parseList(count, itemCallback);
      };
    };
    Parser.list32 = function(count, itemCallback) {
      return function() {
        return this.parseList32(count, itemCallback);
      };
    };
    Parser.recordList = function(count, recordDescription) {
      return function() {
        return this.parseRecordList(count, recordDescription);
      };
    };
    Parser.recordList32 = function(count, recordDescription) {
      return function() {
        return this.parseRecordList32(count, recordDescription);
      };
    };
    Parser.pointer = function(description) {
      return function() {
        return this.parsePointer(description);
      };
    };
    Parser.pointer32 = function(description) {
      return function() {
        return this.parsePointer32(description);
      };
    };
    Parser.tag = Parser.prototype.parseTag;
    Parser.byte = Parser.prototype.parseByte;
    Parser.uShort = Parser.offset16 = Parser.prototype.parseUShort;
    Parser.uShortList = Parser.prototype.parseUShortList;
    Parser.uLong = Parser.offset32 = Parser.prototype.parseULong;
    Parser.uLongList = Parser.prototype.parseULongList;
    Parser.struct = Parser.prototype.parseStruct;
    Parser.coverage = Parser.prototype.parseCoverage;
    Parser.classDef = Parser.prototype.parseClassDef;
    var langSysTable = {
      reserved: Parser.uShort,
      reqFeatureIndex: Parser.uShort,
      featureIndexes: Parser.uShortList
    };
    Parser.prototype.parseScriptList = function() {
      return this.parsePointer(Parser.recordList({
        tag: Parser.tag,
        script: Parser.pointer({
          defaultLangSys: Parser.pointer(langSysTable),
          langSysRecords: Parser.recordList({
            tag: Parser.tag,
            langSys: Parser.pointer(langSysTable)
          })
        })
      })) || [];
    };
    Parser.prototype.parseFeatureList = function() {
      return this.parsePointer(Parser.recordList({
        tag: Parser.tag,
        feature: Parser.pointer({
          featureParams: Parser.offset16,
          lookupListIndexes: Parser.uShortList
        })
      })) || [];
    };
    Parser.prototype.parseLookupList = function(lookupTableParsers) {
      return this.parsePointer(Parser.list(Parser.pointer(function() {
        var lookupType = this.parseUShort();
        check.argument(1 <= lookupType && lookupType <= 9, "GPOS/GSUB lookup type " + lookupType + " unknown.");
        var lookupFlag = this.parseUShort();
        var useMarkFilteringSet = lookupFlag & 16;
        return {
          lookupType,
          lookupFlag,
          subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),
          markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined
        };
      }))) || [];
    };
    Parser.prototype.parseFeatureVariationsList = function() {
      return this.parsePointer32(function() {
        var majorVersion = this.parseUShort();
        var minorVersion = this.parseUShort();
        check.argument(majorVersion === 1 && minorVersion < 1, "GPOS/GSUB feature variations table unknown.");
        var featureVariations = this.parseRecordList32({
          conditionSetOffset: Parser.offset32,
          featureTableSubstitutionOffset: Parser.offset32
        });
        return featureVariations;
      }) || [];
    };
    var parse = {
      getByte,
      getCard8: getByte,
      getUShort,
      getCard16: getUShort,
      getShort,
      getULong,
      getFixed,
      getTag,
      getOffset,
      getBytes,
      bytesToString,
      Parser
    };
    function parseCmapTableFormat12(cmap2, p) {
      p.parseUShort();
      cmap2.length = p.parseULong();
      cmap2.language = p.parseULong();
      var groupCount;
      cmap2.groupCount = groupCount = p.parseULong();
      cmap2.glyphIndexMap = {};
      for (var i = 0;i < groupCount; i += 1) {
        var startCharCode = p.parseULong();
        var endCharCode = p.parseULong();
        var startGlyphId = p.parseULong();
        for (var c = startCharCode;c <= endCharCode; c += 1) {
          cmap2.glyphIndexMap[c] = startGlyphId;
          startGlyphId++;
        }
      }
    }
    function parseCmapTableFormat4(cmap2, p, data, start, offset) {
      cmap2.length = p.parseUShort();
      cmap2.language = p.parseUShort();
      var segCount;
      cmap2.segCount = segCount = p.parseUShort() >> 1;
      p.skip("uShort", 3);
      cmap2.glyphIndexMap = {};
      var endCountParser = new parse.Parser(data, start + offset + 14);
      var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);
      var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);
      var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);
      var glyphIndexOffset = start + offset + 16 + segCount * 8;
      for (var i = 0;i < segCount - 1; i += 1) {
        var glyphIndex = undefined;
        var endCount = endCountParser.parseUShort();
        var startCount = startCountParser.parseUShort();
        var idDelta = idDeltaParser.parseShort();
        var idRangeOffset = idRangeOffsetParser.parseUShort();
        for (var c = startCount;c <= endCount; c += 1) {
          if (idRangeOffset !== 0) {
            glyphIndexOffset = idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2;
            glyphIndexOffset += idRangeOffset;
            glyphIndexOffset += (c - startCount) * 2;
            glyphIndex = parse.getUShort(data, glyphIndexOffset);
            if (glyphIndex !== 0) {
              glyphIndex = glyphIndex + idDelta & 65535;
            }
          } else {
            glyphIndex = c + idDelta & 65535;
          }
          cmap2.glyphIndexMap[c] = glyphIndex;
        }
      }
    }
    function parseCmapTable(data, start) {
      var cmap2 = {};
      cmap2.version = parse.getUShort(data, start);
      check.argument(cmap2.version === 0, "cmap table version should be 0.");
      cmap2.numTables = parse.getUShort(data, start + 2);
      var offset = -1;
      for (var i = cmap2.numTables - 1;i >= 0; i -= 1) {
        var platformId = parse.getUShort(data, start + 4 + i * 8);
        var encodingId = parse.getUShort(data, start + 4 + i * 8 + 2);
        if (platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10)) {
          offset = parse.getULong(data, start + 4 + i * 8 + 4);
          break;
        }
      }
      if (offset === -1) {
        throw new Error("No valid cmap sub-tables found.");
      }
      var p = new parse.Parser(data, start + offset);
      cmap2.format = p.parseUShort();
      if (cmap2.format === 12) {
        parseCmapTableFormat12(cmap2, p);
      } else if (cmap2.format === 4) {
        parseCmapTableFormat4(cmap2, p, data, start, offset);
      } else {
        throw new Error("Only format 4 and 12 cmap tables are supported (found format " + cmap2.format + ").");
      }
      return cmap2;
    }
    function addSegment(t, code, glyphIndex) {
      t.segments.push({
        end: code,
        start: code,
        delta: -(code - glyphIndex),
        offset: 0,
        glyphIndex
      });
    }
    function addTerminatorSegment(t) {
      t.segments.push({
        end: 65535,
        start: 65535,
        delta: 1,
        offset: 0
      });
    }
    function makeCmapTable(glyphs) {
      var isPlan0Only = true;
      var i;
      for (i = glyphs.length - 1;i > 0; i -= 1) {
        var g = glyphs.get(i);
        if (g.unicode > 65535) {
          console.log("Adding CMAP format 12 (needed!)");
          isPlan0Only = false;
          break;
        }
      }
      var cmapTable = [
        { name: "version", type: "USHORT", value: 0 },
        { name: "numTables", type: "USHORT", value: isPlan0Only ? 1 : 2 },
        { name: "platformID", type: "USHORT", value: 3 },
        { name: "encodingID", type: "USHORT", value: 1 },
        { name: "offset", type: "ULONG", value: isPlan0Only ? 12 : 12 + 8 }
      ];
      if (!isPlan0Only) {
        cmapTable = cmapTable.concat([
          { name: "cmap12PlatformID", type: "USHORT", value: 3 },
          { name: "cmap12EncodingID", type: "USHORT", value: 10 },
          { name: "cmap12Offset", type: "ULONG", value: 0 }
        ]);
      }
      cmapTable = cmapTable.concat([
        { name: "format", type: "USHORT", value: 4 },
        { name: "cmap4Length", type: "USHORT", value: 0 },
        { name: "language", type: "USHORT", value: 0 },
        { name: "segCountX2", type: "USHORT", value: 0 },
        { name: "searchRange", type: "USHORT", value: 0 },
        { name: "entrySelector", type: "USHORT", value: 0 },
        { name: "rangeShift", type: "USHORT", value: 0 }
      ]);
      var t = new table.Table("cmap", cmapTable);
      t.segments = [];
      for (i = 0;i < glyphs.length; i += 1) {
        var glyph = glyphs.get(i);
        for (var j = 0;j < glyph.unicodes.length; j += 1) {
          addSegment(t, glyph.unicodes[j], i);
        }
        t.segments = t.segments.sort(function(a, b) {
          return a.start - b.start;
        });
      }
      addTerminatorSegment(t);
      var segCount = t.segments.length;
      var segCountToRemove = 0;
      var endCounts = [];
      var startCounts = [];
      var idDeltas = [];
      var idRangeOffsets = [];
      var glyphIds = [];
      var cmap12Groups = [];
      for (i = 0;i < segCount; i += 1) {
        var segment = t.segments[i];
        if (segment.end <= 65535 && segment.start <= 65535) {
          endCounts = endCounts.concat({ name: "end_" + i, type: "USHORT", value: segment.end });
          startCounts = startCounts.concat({ name: "start_" + i, type: "USHORT", value: segment.start });
          idDeltas = idDeltas.concat({ name: "idDelta_" + i, type: "SHORT", value: segment.delta });
          idRangeOffsets = idRangeOffsets.concat({ name: "idRangeOffset_" + i, type: "USHORT", value: segment.offset });
          if (segment.glyphId !== undefined) {
            glyphIds = glyphIds.concat({ name: "glyph_" + i, type: "USHORT", value: segment.glyphId });
          }
        } else {
          segCountToRemove += 1;
        }
        if (!isPlan0Only && segment.glyphIndex !== undefined) {
          cmap12Groups = cmap12Groups.concat({ name: "cmap12Start_" + i, type: "ULONG", value: segment.start });
          cmap12Groups = cmap12Groups.concat({ name: "cmap12End_" + i, type: "ULONG", value: segment.end });
          cmap12Groups = cmap12Groups.concat({ name: "cmap12Glyph_" + i, type: "ULONG", value: segment.glyphIndex });
        }
      }
      t.segCountX2 = (segCount - segCountToRemove) * 2;
      t.searchRange = Math.pow(2, Math.floor(Math.log(segCount - segCountToRemove) / Math.log(2))) * 2;
      t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);
      t.rangeShift = t.segCountX2 - t.searchRange;
      t.fields = t.fields.concat(endCounts);
      t.fields.push({ name: "reservedPad", type: "USHORT", value: 0 });
      t.fields = t.fields.concat(startCounts);
      t.fields = t.fields.concat(idDeltas);
      t.fields = t.fields.concat(idRangeOffsets);
      t.fields = t.fields.concat(glyphIds);
      t.cmap4Length = 14 + endCounts.length * 2 + 2 + startCounts.length * 2 + idDeltas.length * 2 + idRangeOffsets.length * 2 + glyphIds.length * 2;
      if (!isPlan0Only) {
        var cmap12Length = 16 + cmap12Groups.length * 4;
        t.cmap12Offset = 12 + 2 * 2 + 4 + t.cmap4Length;
        t.fields = t.fields.concat([
          { name: "cmap12Format", type: "USHORT", value: 12 },
          { name: "cmap12Reserved", type: "USHORT", value: 0 },
          { name: "cmap12Length", type: "ULONG", value: cmap12Length },
          { name: "cmap12Language", type: "ULONG", value: 0 },
          { name: "cmap12nGroups", type: "ULONG", value: cmap12Groups.length / 3 }
        ]);
        t.fields = t.fields.concat(cmap12Groups);
      }
      return t;
    }
    var cmap = { parse: parseCmapTable, make: makeCmapTable };
    var cffStandardStrings = [
      ".notdef",
      "space",
      "exclam",
      "quotedbl",
      "numbersign",
      "dollar",
      "percent",
      "ampersand",
      "quoteright",
      "parenleft",
      "parenright",
      "asterisk",
      "plus",
      "comma",
      "hyphen",
      "period",
      "slash",
      "zero",
      "one",
      "two",
      "three",
      "four",
      "five",
      "six",
      "seven",
      "eight",
      "nine",
      "colon",
      "semicolon",
      "less",
      "equal",
      "greater",
      "question",
      "at",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      "bracketleft",
      "backslash",
      "bracketright",
      "asciicircum",
      "underscore",
      "quoteleft",
      "a",
      "b",
      "c",
      "d",
      "e",
      "f",
      "g",
      "h",
      "i",
      "j",
      "k",
      "l",
      "m",
      "n",
      "o",
      "p",
      "q",
      "r",
      "s",
      "t",
      "u",
      "v",
      "w",
      "x",
      "y",
      "z",
      "braceleft",
      "bar",
      "braceright",
      "asciitilde",
      "exclamdown",
      "cent",
      "sterling",
      "fraction",
      "yen",
      "florin",
      "section",
      "currency",
      "quotesingle",
      "quotedblleft",
      "guillemotleft",
      "guilsinglleft",
      "guilsinglright",
      "fi",
      "fl",
      "endash",
      "dagger",
      "daggerdbl",
      "periodcentered",
      "paragraph",
      "bullet",
      "quotesinglbase",
      "quotedblbase",
      "quotedblright",
      "guillemotright",
      "ellipsis",
      "perthousand",
      "questiondown",
      "grave",
      "acute",
      "circumflex",
      "tilde",
      "macron",
      "breve",
      "dotaccent",
      "dieresis",
      "ring",
      "cedilla",
      "hungarumlaut",
      "ogonek",
      "caron",
      "emdash",
      "AE",
      "ordfeminine",
      "Lslash",
      "Oslash",
      "OE",
      "ordmasculine",
      "ae",
      "dotlessi",
      "lslash",
      "oslash",
      "oe",
      "germandbls",
      "onesuperior",
      "logicalnot",
      "mu",
      "trademark",
      "Eth",
      "onehalf",
      "plusminus",
      "Thorn",
      "onequarter",
      "divide",
      "brokenbar",
      "degree",
      "thorn",
      "threequarters",
      "twosuperior",
      "registered",
      "minus",
      "eth",
      "multiply",
      "threesuperior",
      "copyright",
      "Aacute",
      "Acircumflex",
      "Adieresis",
      "Agrave",
      "Aring",
      "Atilde",
      "Ccedilla",
      "Eacute",
      "Ecircumflex",
      "Edieresis",
      "Egrave",
      "Iacute",
      "Icircumflex",
      "Idieresis",
      "Igrave",
      "Ntilde",
      "Oacute",
      "Ocircumflex",
      "Odieresis",
      "Ograve",
      "Otilde",
      "Scaron",
      "Uacute",
      "Ucircumflex",
      "Udieresis",
      "Ugrave",
      "Yacute",
      "Ydieresis",
      "Zcaron",
      "aacute",
      "acircumflex",
      "adieresis",
      "agrave",
      "aring",
      "atilde",
      "ccedilla",
      "eacute",
      "ecircumflex",
      "edieresis",
      "egrave",
      "iacute",
      "icircumflex",
      "idieresis",
      "igrave",
      "ntilde",
      "oacute",
      "ocircumflex",
      "odieresis",
      "ograve",
      "otilde",
      "scaron",
      "uacute",
      "ucircumflex",
      "udieresis",
      "ugrave",
      "yacute",
      "ydieresis",
      "zcaron",
      "exclamsmall",
      "Hungarumlautsmall",
      "dollaroldstyle",
      "dollarsuperior",
      "ampersandsmall",
      "Acutesmall",
      "parenleftsuperior",
      "parenrightsuperior",
      "266 ff",
      "onedotenleader",
      "zerooldstyle",
      "oneoldstyle",
      "twooldstyle",
      "threeoldstyle",
      "fouroldstyle",
      "fiveoldstyle",
      "sixoldstyle",
      "sevenoldstyle",
      "eightoldstyle",
      "nineoldstyle",
      "commasuperior",
      "threequartersemdash",
      "periodsuperior",
      "questionsmall",
      "asuperior",
      "bsuperior",
      "centsuperior",
      "dsuperior",
      "esuperior",
      "isuperior",
      "lsuperior",
      "msuperior",
      "nsuperior",
      "osuperior",
      "rsuperior",
      "ssuperior",
      "tsuperior",
      "ff",
      "ffi",
      "ffl",
      "parenleftinferior",
      "parenrightinferior",
      "Circumflexsmall",
      "hyphensuperior",
      "Gravesmall",
      "Asmall",
      "Bsmall",
      "Csmall",
      "Dsmall",
      "Esmall",
      "Fsmall",
      "Gsmall",
      "Hsmall",
      "Ismall",
      "Jsmall",
      "Ksmall",
      "Lsmall",
      "Msmall",
      "Nsmall",
      "Osmall",
      "Psmall",
      "Qsmall",
      "Rsmall",
      "Ssmall",
      "Tsmall",
      "Usmall",
      "Vsmall",
      "Wsmall",
      "Xsmall",
      "Ysmall",
      "Zsmall",
      "colonmonetary",
      "onefitted",
      "rupiah",
      "Tildesmall",
      "exclamdownsmall",
      "centoldstyle",
      "Lslashsmall",
      "Scaronsmall",
      "Zcaronsmall",
      "Dieresissmall",
      "Brevesmall",
      "Caronsmall",
      "Dotaccentsmall",
      "Macronsmall",
      "figuredash",
      "hypheninferior",
      "Ogoneksmall",
      "Ringsmall",
      "Cedillasmall",
      "questiondownsmall",
      "oneeighth",
      "threeeighths",
      "fiveeighths",
      "seveneighths",
      "onethird",
      "twothirds",
      "zerosuperior",
      "foursuperior",
      "fivesuperior",
      "sixsuperior",
      "sevensuperior",
      "eightsuperior",
      "ninesuperior",
      "zeroinferior",
      "oneinferior",
      "twoinferior",
      "threeinferior",
      "fourinferior",
      "fiveinferior",
      "sixinferior",
      "seveninferior",
      "eightinferior",
      "nineinferior",
      "centinferior",
      "dollarinferior",
      "periodinferior",
      "commainferior",
      "Agravesmall",
      "Aacutesmall",
      "Acircumflexsmall",
      "Atildesmall",
      "Adieresissmall",
      "Aringsmall",
      "AEsmall",
      "Ccedillasmall",
      "Egravesmall",
      "Eacutesmall",
      "Ecircumflexsmall",
      "Edieresissmall",
      "Igravesmall",
      "Iacutesmall",
      "Icircumflexsmall",
      "Idieresissmall",
      "Ethsmall",
      "Ntildesmall",
      "Ogravesmall",
      "Oacutesmall",
      "Ocircumflexsmall",
      "Otildesmall",
      "Odieresissmall",
      "OEsmall",
      "Oslashsmall",
      "Ugravesmall",
      "Uacutesmall",
      "Ucircumflexsmall",
      "Udieresissmall",
      "Yacutesmall",
      "Thornsmall",
      "Ydieresissmall",
      "001.000",
      "001.001",
      "001.002",
      "001.003",
      "Black",
      "Bold",
      "Book",
      "Light",
      "Medium",
      "Regular",
      "Roman",
      "Semibold"
    ];
    var cffStandardEncoding = [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "space",
      "exclam",
      "quotedbl",
      "numbersign",
      "dollar",
      "percent",
      "ampersand",
      "quoteright",
      "parenleft",
      "parenright",
      "asterisk",
      "plus",
      "comma",
      "hyphen",
      "period",
      "slash",
      "zero",
      "one",
      "two",
      "three",
      "four",
      "five",
      "six",
      "seven",
      "eight",
      "nine",
      "colon",
      "semicolon",
      "less",
      "equal",
      "greater",
      "question",
      "at",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      "bracketleft",
      "backslash",
      "bracketright",
      "asciicircum",
      "underscore",
      "quoteleft",
      "a",
      "b",
      "c",
      "d",
      "e",
      "f",
      "g",
      "h",
      "i",
      "j",
      "k",
      "l",
      "m",
      "n",
      "o",
      "p",
      "q",
      "r",
      "s",
      "t",
      "u",
      "v",
      "w",
      "x",
      "y",
      "z",
      "braceleft",
      "bar",
      "braceright",
      "asciitilde",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "exclamdown",
      "cent",
      "sterling",
      "fraction",
      "yen",
      "florin",
      "section",
      "currency",
      "quotesingle",
      "quotedblleft",
      "guillemotleft",
      "guilsinglleft",
      "guilsinglright",
      "fi",
      "fl",
      "",
      "endash",
      "dagger",
      "daggerdbl",
      "periodcentered",
      "",
      "paragraph",
      "bullet",
      "quotesinglbase",
      "quotedblbase",
      "quotedblright",
      "guillemotright",
      "ellipsis",
      "perthousand",
      "",
      "questiondown",
      "",
      "grave",
      "acute",
      "circumflex",
      "tilde",
      "macron",
      "breve",
      "dotaccent",
      "dieresis",
      "",
      "ring",
      "cedilla",
      "",
      "hungarumlaut",
      "ogonek",
      "caron",
      "emdash",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "AE",
      "",
      "ordfeminine",
      "",
      "",
      "",
      "",
      "Lslash",
      "Oslash",
      "OE",
      "ordmasculine",
      "",
      "",
      "",
      "",
      "",
      "ae",
      "",
      "",
      "",
      "dotlessi",
      "",
      "",
      "lslash",
      "oslash",
      "oe",
      "germandbls"
    ];
    var cffExpertEncoding = [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "space",
      "exclamsmall",
      "Hungarumlautsmall",
      "",
      "dollaroldstyle",
      "dollarsuperior",
      "ampersandsmall",
      "Acutesmall",
      "parenleftsuperior",
      "parenrightsuperior",
      "twodotenleader",
      "onedotenleader",
      "comma",
      "hyphen",
      "period",
      "fraction",
      "zerooldstyle",
      "oneoldstyle",
      "twooldstyle",
      "threeoldstyle",
      "fouroldstyle",
      "fiveoldstyle",
      "sixoldstyle",
      "sevenoldstyle",
      "eightoldstyle",
      "nineoldstyle",
      "colon",
      "semicolon",
      "commasuperior",
      "threequartersemdash",
      "periodsuperior",
      "questionsmall",
      "",
      "asuperior",
      "bsuperior",
      "centsuperior",
      "dsuperior",
      "esuperior",
      "",
      "",
      "isuperior",
      "",
      "",
      "lsuperior",
      "msuperior",
      "nsuperior",
      "osuperior",
      "",
      "",
      "rsuperior",
      "ssuperior",
      "tsuperior",
      "",
      "ff",
      "fi",
      "fl",
      "ffi",
      "ffl",
      "parenleftinferior",
      "",
      "parenrightinferior",
      "Circumflexsmall",
      "hyphensuperior",
      "Gravesmall",
      "Asmall",
      "Bsmall",
      "Csmall",
      "Dsmall",
      "Esmall",
      "Fsmall",
      "Gsmall",
      "Hsmall",
      "Ismall",
      "Jsmall",
      "Ksmall",
      "Lsmall",
      "Msmall",
      "Nsmall",
      "Osmall",
      "Psmall",
      "Qsmall",
      "Rsmall",
      "Ssmall",
      "Tsmall",
      "Usmall",
      "Vsmall",
      "Wsmall",
      "Xsmall",
      "Ysmall",
      "Zsmall",
      "colonmonetary",
      "onefitted",
      "rupiah",
      "Tildesmall",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "exclamdownsmall",
      "centoldstyle",
      "Lslashsmall",
      "",
      "",
      "Scaronsmall",
      "Zcaronsmall",
      "Dieresissmall",
      "Brevesmall",
      "Caronsmall",
      "",
      "Dotaccentsmall",
      "",
      "",
      "Macronsmall",
      "",
      "",
      "figuredash",
      "hypheninferior",
      "",
      "",
      "Ogoneksmall",
      "Ringsmall",
      "Cedillasmall",
      "",
      "",
      "",
      "onequarter",
      "onehalf",
      "threequarters",
      "questiondownsmall",
      "oneeighth",
      "threeeighths",
      "fiveeighths",
      "seveneighths",
      "onethird",
      "twothirds",
      "",
      "",
      "zerosuperior",
      "onesuperior",
      "twosuperior",
      "threesuperior",
      "foursuperior",
      "fivesuperior",
      "sixsuperior",
      "sevensuperior",
      "eightsuperior",
      "ninesuperior",
      "zeroinferior",
      "oneinferior",
      "twoinferior",
      "threeinferior",
      "fourinferior",
      "fiveinferior",
      "sixinferior",
      "seveninferior",
      "eightinferior",
      "nineinferior",
      "centinferior",
      "dollarinferior",
      "periodinferior",
      "commainferior",
      "Agravesmall",
      "Aacutesmall",
      "Acircumflexsmall",
      "Atildesmall",
      "Adieresissmall",
      "Aringsmall",
      "AEsmall",
      "Ccedillasmall",
      "Egravesmall",
      "Eacutesmall",
      "Ecircumflexsmall",
      "Edieresissmall",
      "Igravesmall",
      "Iacutesmall",
      "Icircumflexsmall",
      "Idieresissmall",
      "Ethsmall",
      "Ntildesmall",
      "Ogravesmall",
      "Oacutesmall",
      "Ocircumflexsmall",
      "Otildesmall",
      "Odieresissmall",
      "OEsmall",
      "Oslashsmall",
      "Ugravesmall",
      "Uacutesmall",
      "Ucircumflexsmall",
      "Udieresissmall",
      "Yacutesmall",
      "Thornsmall",
      "Ydieresissmall"
    ];
    var standardNames = [
      ".notdef",
      ".null",
      "nonmarkingreturn",
      "space",
      "exclam",
      "quotedbl",
      "numbersign",
      "dollar",
      "percent",
      "ampersand",
      "quotesingle",
      "parenleft",
      "parenright",
      "asterisk",
      "plus",
      "comma",
      "hyphen",
      "period",
      "slash",
      "zero",
      "one",
      "two",
      "three",
      "four",
      "five",
      "six",
      "seven",
      "eight",
      "nine",
      "colon",
      "semicolon",
      "less",
      "equal",
      "greater",
      "question",
      "at",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      "bracketleft",
      "backslash",
      "bracketright",
      "asciicircum",
      "underscore",
      "grave",
      "a",
      "b",
      "c",
      "d",
      "e",
      "f",
      "g",
      "h",
      "i",
      "j",
      "k",
      "l",
      "m",
      "n",
      "o",
      "p",
      "q",
      "r",
      "s",
      "t",
      "u",
      "v",
      "w",
      "x",
      "y",
      "z",
      "braceleft",
      "bar",
      "braceright",
      "asciitilde",
      "Adieresis",
      "Aring",
      "Ccedilla",
      "Eacute",
      "Ntilde",
      "Odieresis",
      "Udieresis",
      "aacute",
      "agrave",
      "acircumflex",
      "adieresis",
      "atilde",
      "aring",
      "ccedilla",
      "eacute",
      "egrave",
      "ecircumflex",
      "edieresis",
      "iacute",
      "igrave",
      "icircumflex",
      "idieresis",
      "ntilde",
      "oacute",
      "ograve",
      "ocircumflex",
      "odieresis",
      "otilde",
      "uacute",
      "ugrave",
      "ucircumflex",
      "udieresis",
      "dagger",
      "degree",
      "cent",
      "sterling",
      "section",
      "bullet",
      "paragraph",
      "germandbls",
      "registered",
      "copyright",
      "trademark",
      "acute",
      "dieresis",
      "notequal",
      "AE",
      "Oslash",
      "infinity",
      "plusminus",
      "lessequal",
      "greaterequal",
      "yen",
      "mu",
      "partialdiff",
      "summation",
      "product",
      "pi",
      "integral",
      "ordfeminine",
      "ordmasculine",
      "Omega",
      "ae",
      "oslash",
      "questiondown",
      "exclamdown",
      "logicalnot",
      "radical",
      "florin",
      "approxequal",
      "Delta",
      "guillemotleft",
      "guillemotright",
      "ellipsis",
      "nonbreakingspace",
      "Agrave",
      "Atilde",
      "Otilde",
      "OE",
      "oe",
      "endash",
      "emdash",
      "quotedblleft",
      "quotedblright",
      "quoteleft",
      "quoteright",
      "divide",
      "lozenge",
      "ydieresis",
      "Ydieresis",
      "fraction",
      "currency",
      "guilsinglleft",
      "guilsinglright",
      "fi",
      "fl",
      "daggerdbl",
      "periodcentered",
      "quotesinglbase",
      "quotedblbase",
      "perthousand",
      "Acircumflex",
      "Ecircumflex",
      "Aacute",
      "Edieresis",
      "Egrave",
      "Iacute",
      "Icircumflex",
      "Idieresis",
      "Igrave",
      "Oacute",
      "Ocircumflex",
      "apple",
      "Ograve",
      "Uacute",
      "Ucircumflex",
      "Ugrave",
      "dotlessi",
      "circumflex",
      "tilde",
      "macron",
      "breve",
      "dotaccent",
      "ring",
      "cedilla",
      "hungarumlaut",
      "ogonek",
      "caron",
      "Lslash",
      "lslash",
      "Scaron",
      "scaron",
      "Zcaron",
      "zcaron",
      "brokenbar",
      "Eth",
      "eth",
      "Yacute",
      "yacute",
      "Thorn",
      "thorn",
      "minus",
      "multiply",
      "onesuperior",
      "twosuperior",
      "threesuperior",
      "onehalf",
      "onequarter",
      "threequarters",
      "franc",
      "Gbreve",
      "gbreve",
      "Idotaccent",
      "Scedilla",
      "scedilla",
      "Cacute",
      "cacute",
      "Ccaron",
      "ccaron",
      "dcroat"
    ];
    function DefaultEncoding(font) {
      this.font = font;
    }
    DefaultEncoding.prototype.charToGlyphIndex = function(c) {
      var code = c.charCodeAt(0);
      var glyphs = this.font.glyphs;
      if (glyphs) {
        for (var i = 0;i < glyphs.length; i += 1) {
          var glyph = glyphs.get(i);
          for (var j = 0;j < glyph.unicodes.length; j += 1) {
            if (glyph.unicodes[j] === code) {
              return i;
            }
          }
        }
      }
      return null;
    };
    function CmapEncoding(cmap2) {
      this.cmap = cmap2;
    }
    CmapEncoding.prototype.charToGlyphIndex = function(c) {
      return this.cmap.glyphIndexMap[c.charCodeAt(0)] || 0;
    };
    function CffEncoding(encoding, charset) {
      this.encoding = encoding;
      this.charset = charset;
    }
    CffEncoding.prototype.charToGlyphIndex = function(s) {
      var code = s.charCodeAt(0);
      var charName = this.encoding[code];
      return this.charset.indexOf(charName);
    };
    function GlyphNames(post2) {
      var this$1 = this;
      switch (post2.version) {
        case 1:
          this.names = standardNames.slice();
          break;
        case 2:
          this.names = new Array(post2.numberOfGlyphs);
          for (var i = 0;i < post2.numberOfGlyphs; i++) {
            if (post2.glyphNameIndex[i] < standardNames.length) {
              this$1.names[i] = standardNames[post2.glyphNameIndex[i]];
            } else {
              this$1.names[i] = post2.names[post2.glyphNameIndex[i] - standardNames.length];
            }
          }
          break;
        case 2.5:
          this.names = new Array(post2.numberOfGlyphs);
          for (var i$1 = 0;i$1 < post2.numberOfGlyphs; i$1++) {
            this$1.names[i$1] = standardNames[i$1 + post2.glyphNameIndex[i$1]];
          }
          break;
        case 3:
          this.names = [];
          break;
        default:
          this.names = [];
          break;
      }
    }
    GlyphNames.prototype.nameToGlyphIndex = function(name) {
      return this.names.indexOf(name);
    };
    GlyphNames.prototype.glyphIndexToName = function(gid) {
      return this.names[gid];
    };
    function addGlyphNames(font) {
      var glyph;
      var glyphIndexMap = font.tables.cmap.glyphIndexMap;
      var charCodes = Object.keys(glyphIndexMap);
      for (var i = 0;i < charCodes.length; i += 1) {
        var c = charCodes[i];
        var glyphIndex = glyphIndexMap[c];
        glyph = font.glyphs.get(glyphIndex);
        glyph.addUnicode(parseInt(c));
      }
      for (var i$1 = 0;i$1 < font.glyphs.length; i$1 += 1) {
        glyph = font.glyphs.get(i$1);
        if (font.cffEncoding) {
          if (font.isCIDFont) {
            glyph.name = "gid" + i$1;
          } else {
            glyph.name = font.cffEncoding.charset[i$1];
          }
        } else if (font.glyphNames.names) {
          glyph.name = font.glyphNames.glyphIndexToName(i$1);
        }
      }
    }
    function line(ctx, x1, y1, x2, y2) {
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }
    var draw = { line };
    function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {
      var v;
      if ((flag & shortVectorBitMask) > 0) {
        v = p.parseByte();
        if ((flag & sameBitMask) === 0) {
          v = -v;
        }
        v = previousValue + v;
      } else {
        if ((flag & sameBitMask) > 0) {
          v = previousValue;
        } else {
          v = previousValue + p.parseShort();
        }
      }
      return v;
    }
    function parseGlyph(glyph, data, start) {
      var p = new parse.Parser(data, start);
      glyph.numberOfContours = p.parseShort();
      glyph._xMin = p.parseShort();
      glyph._yMin = p.parseShort();
      glyph._xMax = p.parseShort();
      glyph._yMax = p.parseShort();
      var flags;
      var flag;
      if (glyph.numberOfContours > 0) {
        var endPointIndices = glyph.endPointIndices = [];
        for (var i = 0;i < glyph.numberOfContours; i += 1) {
          endPointIndices.push(p.parseUShort());
        }
        glyph.instructionLength = p.parseUShort();
        glyph.instructions = [];
        for (var i$1 = 0;i$1 < glyph.instructionLength; i$1 += 1) {
          glyph.instructions.push(p.parseByte());
        }
        var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;
        flags = [];
        for (var i$2 = 0;i$2 < numberOfCoordinates; i$2 += 1) {
          flag = p.parseByte();
          flags.push(flag);
          if ((flag & 8) > 0) {
            var repeatCount = p.parseByte();
            for (var j = 0;j < repeatCount; j += 1) {
              flags.push(flag);
              i$2 += 1;
            }
          }
        }
        check.argument(flags.length === numberOfCoordinates, "Bad flags.");
        if (endPointIndices.length > 0) {
          var points = [];
          var point;
          if (numberOfCoordinates > 0) {
            for (var i$3 = 0;i$3 < numberOfCoordinates; i$3 += 1) {
              flag = flags[i$3];
              point = {};
              point.onCurve = !!(flag & 1);
              point.lastPointOfContour = endPointIndices.indexOf(i$3) >= 0;
              points.push(point);
            }
            var px = 0;
            for (var i$4 = 0;i$4 < numberOfCoordinates; i$4 += 1) {
              flag = flags[i$4];
              point = points[i$4];
              point.x = parseGlyphCoordinate(p, flag, px, 2, 16);
              px = point.x;
            }
            var py = 0;
            for (var i$5 = 0;i$5 < numberOfCoordinates; i$5 += 1) {
              flag = flags[i$5];
              point = points[i$5];
              point.y = parseGlyphCoordinate(p, flag, py, 4, 32);
              py = point.y;
            }
          }
          glyph.points = points;
        } else {
          glyph.points = [];
        }
      } else if (glyph.numberOfContours === 0) {
        glyph.points = [];
      } else {
        glyph.isComposite = true;
        glyph.points = [];
        glyph.components = [];
        var moreComponents = true;
        while (moreComponents) {
          flags = p.parseUShort();
          var component = {
            glyphIndex: p.parseUShort(),
            xScale: 1,
            scale01: 0,
            scale10: 0,
            yScale: 1,
            dx: 0,
            dy: 0
          };
          if ((flags & 1) > 0) {
            if ((flags & 2) > 0) {
              component.dx = p.parseShort();
              component.dy = p.parseShort();
            } else {
              component.matchedPoints = [p.parseUShort(), p.parseUShort()];
            }
          } else {
            if ((flags & 2) > 0) {
              component.dx = p.parseChar();
              component.dy = p.parseChar();
            } else {
              component.matchedPoints = [p.parseByte(), p.parseByte()];
            }
          }
          if ((flags & 8) > 0) {
            component.xScale = component.yScale = p.parseF2Dot14();
          } else if ((flags & 64) > 0) {
            component.xScale = p.parseF2Dot14();
            component.yScale = p.parseF2Dot14();
          } else if ((flags & 128) > 0) {
            component.xScale = p.parseF2Dot14();
            component.scale01 = p.parseF2Dot14();
            component.scale10 = p.parseF2Dot14();
            component.yScale = p.parseF2Dot14();
          }
          glyph.components.push(component);
          moreComponents = !!(flags & 32);
        }
        if (flags & 256) {
          glyph.instructionLength = p.parseUShort();
          glyph.instructions = [];
          for (var i$6 = 0;i$6 < glyph.instructionLength; i$6 += 1) {
            glyph.instructions.push(p.parseByte());
          }
        }
      }
    }
    function transformPoints(points, transform) {
      var newPoints = [];
      for (var i = 0;i < points.length; i += 1) {
        var pt = points[i];
        var newPt = {
          x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,
          y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,
          onCurve: pt.onCurve,
          lastPointOfContour: pt.lastPointOfContour
        };
        newPoints.push(newPt);
      }
      return newPoints;
    }
    function getContours(points) {
      var contours = [];
      var currentContour = [];
      for (var i = 0;i < points.length; i += 1) {
        var pt = points[i];
        currentContour.push(pt);
        if (pt.lastPointOfContour) {
          contours.push(currentContour);
          currentContour = [];
        }
      }
      check.argument(currentContour.length === 0, "There are still points left in the current contour.");
      return contours;
    }
    function getPath(points) {
      var p = new Path;
      if (!points) {
        return p;
      }
      var contours = getContours(points);
      for (var contourIndex = 0;contourIndex < contours.length; ++contourIndex) {
        var contour = contours[contourIndex];
        var prev = null;
        var curr = contour[contour.length - 1];
        var next = contour[0];
        if (curr.onCurve) {
          p.moveTo(curr.x, curr.y);
        } else {
          if (next.onCurve) {
            p.moveTo(next.x, next.y);
          } else {
            var start = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
            p.moveTo(start.x, start.y);
          }
        }
        for (var i = 0;i < contour.length; ++i) {
          prev = curr;
          curr = next;
          next = contour[(i + 1) % contour.length];
          if (curr.onCurve) {
            p.lineTo(curr.x, curr.y);
          } else {
            var prev2 = prev;
            var next2 = next;
            if (!prev.onCurve) {
              prev2 = { x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 };
              p.lineTo(prev2.x, prev2.y);
            }
            if (!next.onCurve) {
              next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
            }
            p.lineTo(prev2.x, prev2.y);
            p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);
          }
        }
        p.closePath();
      }
      return p;
    }
    function buildPath(glyphs, glyph) {
      if (glyph.isComposite) {
        for (var j = 0;j < glyph.components.length; j += 1) {
          var component = glyph.components[j];
          var componentGlyph = glyphs.get(component.glyphIndex);
          componentGlyph.getPath();
          if (componentGlyph.points) {
            var transformedPoints = undefined;
            if (component.matchedPoints === undefined) {
              transformedPoints = transformPoints(componentGlyph.points, component);
            } else {
              if (component.matchedPoints[0] > glyph.points.length - 1 || component.matchedPoints[1] > componentGlyph.points.length - 1) {
                throw Error("Matched points out of range in " + glyph.name);
              }
              var firstPt = glyph.points[component.matchedPoints[0]];
              var secondPt = componentGlyph.points[component.matchedPoints[1]];
              var transform = {
                xScale: component.xScale,
                scale01: component.scale01,
                scale10: component.scale10,
                yScale: component.yScale,
                dx: 0,
                dy: 0
              };
              secondPt = transformPoints([secondPt], transform)[0];
              transform.dx = firstPt.x - secondPt.x;
              transform.dy = firstPt.y - secondPt.y;
              transformedPoints = transformPoints(componentGlyph.points, transform);
            }
            glyph.points = glyph.points.concat(transformedPoints);
          }
        }
      }
      return getPath(glyph.points);
    }
    function parseGlyfTable(data, start, loca2, font) {
      var glyphs = new glyphset.GlyphSet(font);
      for (var i = 0;i < loca2.length - 1; i += 1) {
        var offset = loca2[i];
        var nextOffset = loca2[i + 1];
        if (offset !== nextOffset) {
          glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));
        } else {
          glyphs.push(i, glyphset.glyphLoader(font, i));
        }
      }
      return glyphs;
    }
    var glyf = { getPath, parse: parseGlyfTable };
    function getPathDefinition(glyph, path) {
      var _path = path || new Path;
      return {
        configurable: true,
        get: function() {
          if (typeof _path === "function") {
            _path = _path();
          }
          return _path;
        },
        set: function(p) {
          _path = p;
        }
      };
    }
    function Glyph(options) {
      this.bindConstructorValues(options);
    }
    Glyph.prototype.bindConstructorValues = function(options) {
      this.index = options.index || 0;
      this.name = options.name || null;
      this.unicode = options.unicode || undefined;
      this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];
      if (options.xMin) {
        this.xMin = options.xMin;
      }
      if (options.yMin) {
        this.yMin = options.yMin;
      }
      if (options.xMax) {
        this.xMax = options.xMax;
      }
      if (options.yMax) {
        this.yMax = options.yMax;
      }
      if (options.advanceWidth) {
        this.advanceWidth = options.advanceWidth;
      }
      Object.defineProperty(this, "path", getPathDefinition(this, options.path));
    };
    Glyph.prototype.addUnicode = function(unicode) {
      if (this.unicodes.length === 0) {
        this.unicode = unicode;
      }
      this.unicodes.push(unicode);
    };
    Glyph.prototype.getBoundingBox = function() {
      return this.path.getBoundingBox();
    };
    Glyph.prototype.getPath = function(x, y, fontSize, options, font) {
      x = x !== undefined ? x : 0;
      y = y !== undefined ? y : 0;
      fontSize = fontSize !== undefined ? fontSize : 72;
      var commands;
      var hPoints;
      if (!options) {
        options = {};
      }
      var xScale = options.xScale;
      var yScale = options.yScale;
      if (options.hinting && font && font.hinting) {
        hPoints = this.path && font.hinting.exec(this, fontSize);
      }
      if (hPoints) {
        commands = glyf.getPath(hPoints).commands;
        x = Math.round(x);
        y = Math.round(y);
        xScale = yScale = 1;
      } else {
        commands = this.path.commands;
        var scale = 1 / this.path.unitsPerEm * fontSize;
        if (xScale === undefined) {
          xScale = scale;
        }
        if (yScale === undefined) {
          yScale = scale;
        }
      }
      var p = new Path;
      for (var i = 0;i < commands.length; i += 1) {
        var cmd = commands[i];
        if (cmd.type === "M") {
          p.moveTo(x + cmd.x * xScale, y + -cmd.y * yScale);
        } else if (cmd.type === "L") {
          p.lineTo(x + cmd.x * xScale, y + -cmd.y * yScale);
        } else if (cmd.type === "Q") {
          p.quadraticCurveTo(x + cmd.x1 * xScale, y + -cmd.y1 * yScale, x + cmd.x * xScale, y + -cmd.y * yScale);
        } else if (cmd.type === "C") {
          p.curveTo(x + cmd.x1 * xScale, y + -cmd.y1 * yScale, x + cmd.x2 * xScale, y + -cmd.y2 * yScale, x + cmd.x * xScale, y + -cmd.y * yScale);
        } else if (cmd.type === "Z") {
          p.closePath();
        }
      }
      return p;
    };
    Glyph.prototype.getContours = function() {
      var this$1 = this;
      if (this.points === undefined) {
        return [];
      }
      var contours = [];
      var currentContour = [];
      for (var i = 0;i < this.points.length; i += 1) {
        var pt = this$1.points[i];
        currentContour.push(pt);
        if (pt.lastPointOfContour) {
          contours.push(currentContour);
          currentContour = [];
        }
      }
      check.argument(currentContour.length === 0, "There are still points left in the current contour.");
      return contours;
    };
    Glyph.prototype.getMetrics = function() {
      var commands = this.path.commands;
      var xCoords = [];
      var yCoords = [];
      for (var i = 0;i < commands.length; i += 1) {
        var cmd = commands[i];
        if (cmd.type !== "Z") {
          xCoords.push(cmd.x);
          yCoords.push(cmd.y);
        }
        if (cmd.type === "Q" || cmd.type === "C") {
          xCoords.push(cmd.x1);
          yCoords.push(cmd.y1);
        }
        if (cmd.type === "C") {
          xCoords.push(cmd.x2);
          yCoords.push(cmd.y2);
        }
      }
      var metrics = {
        xMin: Math.min.apply(null, xCoords),
        yMin: Math.min.apply(null, yCoords),
        xMax: Math.max.apply(null, xCoords),
        yMax: Math.max.apply(null, yCoords),
        leftSideBearing: this.leftSideBearing
      };
      if (!isFinite(metrics.xMin)) {
        metrics.xMin = 0;
      }
      if (!isFinite(metrics.xMax)) {
        metrics.xMax = this.advanceWidth;
      }
      if (!isFinite(metrics.yMin)) {
        metrics.yMin = 0;
      }
      if (!isFinite(metrics.yMax)) {
        metrics.yMax = 0;
      }
      metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);
      return metrics;
    };
    Glyph.prototype.draw = function(ctx, x, y, fontSize, options) {
      this.getPath(x, y, fontSize, options).draw(ctx);
    };
    Glyph.prototype.drawPoints = function(ctx, x, y, fontSize) {
      function drawCircles(l, x2, y2, scale2) {
        var PI_SQ = Math.PI * 2;
        ctx.beginPath();
        for (var j = 0;j < l.length; j += 1) {
          ctx.moveTo(x2 + l[j].x * scale2, y2 + l[j].y * scale2);
          ctx.arc(x2 + l[j].x * scale2, y2 + l[j].y * scale2, 2, 0, PI_SQ, false);
        }
        ctx.closePath();
        ctx.fill();
      }
      x = x !== undefined ? x : 0;
      y = y !== undefined ? y : 0;
      fontSize = fontSize !== undefined ? fontSize : 24;
      var scale = 1 / this.path.unitsPerEm * fontSize;
      var blueCircles = [];
      var redCircles = [];
      var path = this.path;
      for (var i = 0;i < path.commands.length; i += 1) {
        var cmd = path.commands[i];
        if (cmd.x !== undefined) {
          blueCircles.push({ x: cmd.x, y: -cmd.y });
        }
        if (cmd.x1 !== undefined) {
          redCircles.push({ x: cmd.x1, y: -cmd.y1 });
        }
        if (cmd.x2 !== undefined) {
          redCircles.push({ x: cmd.x2, y: -cmd.y2 });
        }
      }
      ctx.fillStyle = "blue";
      drawCircles(blueCircles, x, y, scale);
      ctx.fillStyle = "red";
      drawCircles(redCircles, x, y, scale);
    };
    Glyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {
      var scale;
      x = x !== undefined ? x : 0;
      y = y !== undefined ? y : 0;
      fontSize = fontSize !== undefined ? fontSize : 24;
      scale = 1 / this.path.unitsPerEm * fontSize;
      ctx.lineWidth = 1;
      ctx.strokeStyle = "black";
      draw.line(ctx, x, -1e4, x, 1e4);
      draw.line(ctx, -1e4, y, 1e4, y);
      var xMin = this.xMin || 0;
      var yMin = this.yMin || 0;
      var xMax = this.xMax || 0;
      var yMax = this.yMax || 0;
      var advanceWidth = this.advanceWidth || 0;
      ctx.strokeStyle = "blue";
      draw.line(ctx, x + xMin * scale, -1e4, x + xMin * scale, 1e4);
      draw.line(ctx, x + xMax * scale, -1e4, x + xMax * scale, 1e4);
      draw.line(ctx, -1e4, y + -yMin * scale, 1e4, y + -yMin * scale);
      draw.line(ctx, -1e4, y + -yMax * scale, 1e4, y + -yMax * scale);
      ctx.strokeStyle = "green";
      draw.line(ctx, x + advanceWidth * scale, -1e4, x + advanceWidth * scale, 1e4);
    };
    function defineDependentProperty(glyph, externalName, internalName) {
      Object.defineProperty(glyph, externalName, {
        get: function() {
          glyph.path;
          return glyph[internalName];
        },
        set: function(newValue) {
          glyph[internalName] = newValue;
        },
        enumerable: true,
        configurable: true
      });
    }
    function GlyphSet(font, glyphs) {
      var this$1 = this;
      this.font = font;
      this.glyphs = {};
      if (Array.isArray(glyphs)) {
        for (var i = 0;i < glyphs.length; i++) {
          this$1.glyphs[i] = glyphs[i];
        }
      }
      this.length = glyphs && glyphs.length || 0;
    }
    GlyphSet.prototype.get = function(index) {
      if (typeof this.glyphs[index] === "function") {
        this.glyphs[index] = this.glyphs[index]();
      }
      return this.glyphs[index];
    };
    GlyphSet.prototype.push = function(index, loader) {
      this.glyphs[index] = loader;
      this.length++;
    };
    function glyphLoader(font, index) {
      return new Glyph({ index, font });
    }
    function ttfGlyphLoader(font, index, parseGlyph2, data, position, buildPath2) {
      return function() {
        var glyph = new Glyph({ index, font });
        glyph.path = function() {
          parseGlyph2(glyph, data, position);
          var path = buildPath2(font.glyphs, glyph);
          path.unitsPerEm = font.unitsPerEm;
          return path;
        };
        defineDependentProperty(glyph, "xMin", "_xMin");
        defineDependentProperty(glyph, "xMax", "_xMax");
        defineDependentProperty(glyph, "yMin", "_yMin");
        defineDependentProperty(glyph, "yMax", "_yMax");
        return glyph;
      };
    }
    function cffGlyphLoader(font, index, parseCFFCharstring2, charstring) {
      return function() {
        var glyph = new Glyph({ index, font });
        glyph.path = function() {
          var path = parseCFFCharstring2(font, glyph, charstring);
          path.unitsPerEm = font.unitsPerEm;
          return path;
        };
        return glyph;
      };
    }
    var glyphset = { GlyphSet, glyphLoader, ttfGlyphLoader, cffGlyphLoader };
    function equals(a, b) {
      if (a === b) {
        return true;
      } else if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) {
          return false;
        }
        for (var i = 0;i < a.length; i += 1) {
          if (!equals(a[i], b[i])) {
            return false;
          }
        }
        return true;
      } else {
        return false;
      }
    }
    function calcCFFSubroutineBias(subrs) {
      var bias;
      if (subrs.length < 1240) {
        bias = 107;
      } else if (subrs.length < 33900) {
        bias = 1131;
      } else {
        bias = 32768;
      }
      return bias;
    }
    function parseCFFIndex(data, start, conversionFn) {
      var offsets = [];
      var objects = [];
      var count = parse.getCard16(data, start);
      var objectOffset;
      var endOffset;
      if (count !== 0) {
        var offsetSize = parse.getByte(data, start + 2);
        objectOffset = start + (count + 1) * offsetSize + 2;
        var pos = start + 3;
        for (var i = 0;i < count + 1; i += 1) {
          offsets.push(parse.getOffset(data, pos, offsetSize));
          pos += offsetSize;
        }
        endOffset = objectOffset + offsets[count];
      } else {
        endOffset = start + 2;
      }
      for (var i$1 = 0;i$1 < offsets.length - 1; i$1 += 1) {
        var value = parse.getBytes(data, objectOffset + offsets[i$1], objectOffset + offsets[i$1 + 1]);
        if (conversionFn) {
          value = conversionFn(value);
        }
        objects.push(value);
      }
      return { objects, startOffset: start, endOffset };
    }
    function parseFloatOperand(parser) {
      var s = "";
      var eof = 15;
      var lookup = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"];
      while (true) {
        var b = parser.parseByte();
        var n1 = b >> 4;
        var n2 = b & 15;
        if (n1 === eof) {
          break;
        }
        s += lookup[n1];
        if (n2 === eof) {
          break;
        }
        s += lookup[n2];
      }
      return parseFloat(s);
    }
    function parseOperand(parser, b0) {
      var b1;
      var b2;
      var b3;
      var b4;
      if (b0 === 28) {
        b1 = parser.parseByte();
        b2 = parser.parseByte();
        return b1 << 8 | b2;
      }
      if (b0 === 29) {
        b1 = parser.parseByte();
        b2 = parser.parseByte();
        b3 = parser.parseByte();
        b4 = parser.parseByte();
        return b1 << 24 | b2 << 16 | b3 << 8 | b4;
      }
      if (b0 === 30) {
        return parseFloatOperand(parser);
      }
      if (b0 >= 32 && b0 <= 246) {
        return b0 - 139;
      }
      if (b0 >= 247 && b0 <= 250) {
        b1 = parser.parseByte();
        return (b0 - 247) * 256 + b1 + 108;
      }
      if (b0 >= 251 && b0 <= 254) {
        b1 = parser.parseByte();
        return -(b0 - 251) * 256 - b1 - 108;
      }
      throw new Error("Invalid b0 " + b0);
    }
    function entriesToObject(entries) {
      var o = {};
      for (var i = 0;i < entries.length; i += 1) {
        var key = entries[i][0];
        var values = entries[i][1];
        var value = undefined;
        if (values.length === 1) {
          value = values[0];
        } else {
          value = values;
        }
        if (o.hasOwnProperty(key) && !isNaN(o[key])) {
          throw new Error("Object " + o + " already has key " + key);
        }
        o[key] = value;
      }
      return o;
    }
    function parseCFFDict(data, start, size) {
      start = start !== undefined ? start : 0;
      var parser = new parse.Parser(data, start);
      var entries = [];
      var operands = [];
      size = size !== undefined ? size : data.length;
      while (parser.relativeOffset < size) {
        var op = parser.parseByte();
        if (op <= 21) {
          if (op === 12) {
            op = 1200 + parser.parseByte();
          }
          entries.push([op, operands]);
          operands = [];
        } else {
          operands.push(parseOperand(parser, op));
        }
      }
      return entriesToObject(entries);
    }
    function getCFFString(strings, index) {
      if (index <= 390) {
        index = cffStandardStrings[index];
      } else {
        index = strings[index - 391];
      }
      return index;
    }
    function interpretDict(dict, meta2, strings) {
      var newDict = {};
      var value;
      for (var i = 0;i < meta2.length; i += 1) {
        var m = meta2[i];
        if (Array.isArray(m.type)) {
          var values = [];
          values.length = m.type.length;
          for (var j = 0;j < m.type.length; j++) {
            value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;
            if (value === undefined) {
              value = m.value !== undefined && m.value[j] !== undefined ? m.value[j] : null;
            }
            if (m.type[j] === "SID") {
              value = getCFFString(strings, value);
            }
            values[j] = value;
          }
          newDict[m.name] = values;
        } else {
          value = dict[m.op];
          if (value === undefined) {
            value = m.value !== undefined ? m.value : null;
          }
          if (m.type === "SID") {
            value = getCFFString(strings, value);
          }
          newDict[m.name] = value;
        }
      }
      return newDict;
    }
    function parseCFFHeader(data, start) {
      var header = {};
      header.formatMajor = parse.getCard8(data, start);
      header.formatMinor = parse.getCard8(data, start + 1);
      header.size = parse.getCard8(data, start + 2);
      header.offsetSize = parse.getCard8(data, start + 3);
      header.startOffset = start;
      header.endOffset = start + 4;
      return header;
    }
    var TOP_DICT_META = [
      { name: "version", op: 0, type: "SID" },
      { name: "notice", op: 1, type: "SID" },
      { name: "copyright", op: 1200, type: "SID" },
      { name: "fullName", op: 2, type: "SID" },
      { name: "familyName", op: 3, type: "SID" },
      { name: "weight", op: 4, type: "SID" },
      { name: "isFixedPitch", op: 1201, type: "number", value: 0 },
      { name: "italicAngle", op: 1202, type: "number", value: 0 },
      { name: "underlinePosition", op: 1203, type: "number", value: -100 },
      { name: "underlineThickness", op: 1204, type: "number", value: 50 },
      { name: "paintType", op: 1205, type: "number", value: 0 },
      { name: "charstringType", op: 1206, type: "number", value: 2 },
      {
        name: "fontMatrix",
        op: 1207,
        type: ["real", "real", "real", "real", "real", "real"],
        value: [0.001, 0, 0, 0.001, 0, 0]
      },
      { name: "uniqueId", op: 13, type: "number" },
      { name: "fontBBox", op: 5, type: ["number", "number", "number", "number"], value: [0, 0, 0, 0] },
      { name: "strokeWidth", op: 1208, type: "number", value: 0 },
      { name: "xuid", op: 14, type: [], value: null },
      { name: "charset", op: 15, type: "offset", value: 0 },
      { name: "encoding", op: 16, type: "offset", value: 0 },
      { name: "charStrings", op: 17, type: "offset", value: 0 },
      { name: "private", op: 18, type: ["number", "offset"], value: [0, 0] },
      { name: "ros", op: 1230, type: ["SID", "SID", "number"] },
      { name: "cidFontVersion", op: 1231, type: "number", value: 0 },
      { name: "cidFontRevision", op: 1232, type: "number", value: 0 },
      { name: "cidFontType", op: 1233, type: "number", value: 0 },
      { name: "cidCount", op: 1234, type: "number", value: 8720 },
      { name: "uidBase", op: 1235, type: "number" },
      { name: "fdArray", op: 1236, type: "offset" },
      { name: "fdSelect", op: 1237, type: "offset" },
      { name: "fontName", op: 1238, type: "SID" }
    ];
    var PRIVATE_DICT_META = [
      { name: "subrs", op: 19, type: "offset", value: 0 },
      { name: "defaultWidthX", op: 20, type: "number", value: 0 },
      { name: "nominalWidthX", op: 21, type: "number", value: 0 }
    ];
    function parseCFFTopDict(data, strings) {
      var dict = parseCFFDict(data, 0, data.byteLength);
      return interpretDict(dict, TOP_DICT_META, strings);
    }
    function parseCFFPrivateDict(data, start, size, strings) {
      var dict = parseCFFDict(data, start, size);
      return interpretDict(dict, PRIVATE_DICT_META, strings);
    }
    function gatherCFFTopDicts(data, start, cffIndex, strings) {
      var topDictArray = [];
      for (var iTopDict = 0;iTopDict < cffIndex.length; iTopDict += 1) {
        var topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);
        var topDict = parseCFFTopDict(topDictData, strings);
        topDict._subrs = [];
        topDict._subrsBias = 0;
        var privateSize = topDict.private[0];
        var privateOffset = topDict.private[1];
        if (privateSize !== 0 && privateOffset !== 0) {
          var privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);
          topDict._defaultWidthX = privateDict.defaultWidthX;
          topDict._nominalWidthX = privateDict.nominalWidthX;
          if (privateDict.subrs !== 0) {
            var subrOffset = privateOffset + privateDict.subrs;
            var subrIndex = parseCFFIndex(data, subrOffset + start);
            topDict._subrs = subrIndex.objects;
            topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);
          }
          topDict._privateDict = privateDict;
        }
        topDictArray.push(topDict);
      }
      return topDictArray;
    }
    function parseCFFCharset(data, start, nGlyphs, strings) {
      var sid;
      var count;
      var parser = new parse.Parser(data, start);
      nGlyphs -= 1;
      var charset = [".notdef"];
      var format = parser.parseCard8();
      if (format === 0) {
        for (var i = 0;i < nGlyphs; i += 1) {
          sid = parser.parseSID();
          charset.push(getCFFString(strings, sid));
        }
      } else if (format === 1) {
        while (charset.length <= nGlyphs) {
          sid = parser.parseSID();
          count = parser.parseCard8();
          for (var i$1 = 0;i$1 <= count; i$1 += 1) {
            charset.push(getCFFString(strings, sid));
            sid += 1;
          }
        }
      } else if (format === 2) {
        while (charset.length <= nGlyphs) {
          sid = parser.parseSID();
          count = parser.parseCard16();
          for (var i$2 = 0;i$2 <= count; i$2 += 1) {
            charset.push(getCFFString(strings, sid));
            sid += 1;
          }
        }
      } else {
        throw new Error("Unknown charset format " + format);
      }
      return charset;
    }
    function parseCFFEncoding(data, start, charset) {
      var code;
      var enc = {};
      var parser = new parse.Parser(data, start);
      var format = parser.parseCard8();
      if (format === 0) {
        var nCodes = parser.parseCard8();
        for (var i = 0;i < nCodes; i += 1) {
          code = parser.parseCard8();
          enc[code] = i;
        }
      } else if (format === 1) {
        var nRanges = parser.parseCard8();
        code = 1;
        for (var i$1 = 0;i$1 < nRanges; i$1 += 1) {
          var first = parser.parseCard8();
          var nLeft = parser.parseCard8();
          for (var j = first;j <= first + nLeft; j += 1) {
            enc[j] = code;
            code += 1;
          }
        }
      } else {
        throw new Error("Unknown encoding format " + format);
      }
      return new CffEncoding(enc, charset);
    }
    function parseCFFCharstring(font, glyph, code) {
      var c1x;
      var c1y;
      var c2x;
      var c2y;
      var p = new Path;
      var stack = [];
      var nStems = 0;
      var haveWidth = false;
      var open = false;
      var x = 0;
      var y = 0;
      var subrs;
      var subrsBias;
      var defaultWidthX;
      var nominalWidthX;
      if (font.isCIDFont) {
        var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];
        var fdDict = font.tables.cff.topDict._fdArray[fdIndex];
        subrs = fdDict._subrs;
        subrsBias = fdDict._subrsBias;
        defaultWidthX = fdDict._defaultWidthX;
        nominalWidthX = fdDict._nominalWidthX;
      } else {
        subrs = font.tables.cff.topDict._subrs;
        subrsBias = font.tables.cff.topDict._subrsBias;
        defaultWidthX = font.tables.cff.topDict._defaultWidthX;
        nominalWidthX = font.tables.cff.topDict._nominalWidthX;
      }
      var width = defaultWidthX;
      function newContour(x2, y2) {
        if (open) {
          p.closePath();
        }
        p.moveTo(x2, y2);
        open = true;
      }
      function parseStems() {
        var hasWidthArg;
        hasWidthArg = stack.length % 2 !== 0;
        if (hasWidthArg && !haveWidth) {
          width = stack.shift() + nominalWidthX;
        }
        nStems += stack.length >> 1;
        stack.length = 0;
        haveWidth = true;
      }
      function parse$$1(code2) {
        var b1;
        var b2;
        var b3;
        var b4;
        var codeIndex;
        var subrCode;
        var jpx;
        var jpy;
        var c3x;
        var c3y;
        var c4x;
        var c4y;
        var i = 0;
        while (i < code2.length) {
          var v = code2[i];
          i += 1;
          switch (v) {
            case 1:
              parseStems();
              break;
            case 3:
              parseStems();
              break;
            case 4:
              if (stack.length > 1 && !haveWidth) {
                width = stack.shift() + nominalWidthX;
                haveWidth = true;
              }
              y += stack.pop();
              newContour(x, y);
              break;
            case 5:
              while (stack.length > 0) {
                x += stack.shift();
                y += stack.shift();
                p.lineTo(x, y);
              }
              break;
            case 6:
              while (stack.length > 0) {
                x += stack.shift();
                p.lineTo(x, y);
                if (stack.length === 0) {
                  break;
                }
                y += stack.shift();
                p.lineTo(x, y);
              }
              break;
            case 7:
              while (stack.length > 0) {
                y += stack.shift();
                p.lineTo(x, y);
                if (stack.length === 0) {
                  break;
                }
                x += stack.shift();
                p.lineTo(x, y);
              }
              break;
            case 8:
              while (stack.length > 0) {
                c1x = x + stack.shift();
                c1y = y + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y = c2y + stack.shift();
                p.curveTo(c1x, c1y, c2x, c2y, x, y);
              }
              break;
            case 10:
              codeIndex = stack.pop() + subrsBias;
              subrCode = subrs[codeIndex];
              if (subrCode) {
                parse$$1(subrCode);
              }
              break;
            case 11:
              return;
            case 12:
              v = code2[i];
              i += 1;
              switch (v) {
                case 35:
                  c1x = x + stack.shift();
                  c1y = y + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  jpx = c2x + stack.shift();
                  jpy = c2y + stack.shift();
                  c3x = jpx + stack.shift();
                  c3y = jpy + stack.shift();
                  c4x = c3x + stack.shift();
                  c4y = c3y + stack.shift();
                  x = c4x + stack.shift();
                  y = c4y + stack.shift();
                  stack.shift();
                  p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                  p.curveTo(c3x, c3y, c4x, c4y, x, y);
                  break;
                case 34:
                  c1x = x + stack.shift();
                  c1y = y;
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  jpx = c2x + stack.shift();
                  jpy = c2y;
                  c3x = jpx + stack.shift();
                  c3y = c2y;
                  c4x = c3x + stack.shift();
                  c4y = y;
                  x = c4x + stack.shift();
                  p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                  p.curveTo(c3x, c3y, c4x, c4y, x, y);
                  break;
                case 36:
                  c1x = x + stack.shift();
                  c1y = y + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  jpx = c2x + stack.shift();
                  jpy = c2y;
                  c3x = jpx + stack.shift();
                  c3y = c2y;
                  c4x = c3x + stack.shift();
                  c4y = c3y + stack.shift();
                  x = c4x + stack.shift();
                  p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                  p.curveTo(c3x, c3y, c4x, c4y, x, y);
                  break;
                case 37:
                  c1x = x + stack.shift();
                  c1y = y + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  jpx = c2x + stack.shift();
                  jpy = c2y + stack.shift();
                  c3x = jpx + stack.shift();
                  c3y = jpy + stack.shift();
                  c4x = c3x + stack.shift();
                  c4y = c3y + stack.shift();
                  if (Math.abs(c4x - x) > Math.abs(c4y - y)) {
                    x = c4x + stack.shift();
                  } else {
                    y = c4y + stack.shift();
                  }
                  p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                  p.curveTo(c3x, c3y, c4x, c4y, x, y);
                  break;
                default:
                  console.log("Glyph " + glyph.index + ": unknown operator " + 1200 + v);
                  stack.length = 0;
              }
              break;
            case 14:
              if (stack.length > 0 && !haveWidth) {
                width = stack.shift() + nominalWidthX;
                haveWidth = true;
              }
              if (open) {
                p.closePath();
                open = false;
              }
              break;
            case 18:
              parseStems();
              break;
            case 19:
            case 20:
              parseStems();
              i += nStems + 7 >> 3;
              break;
            case 21:
              if (stack.length > 2 && !haveWidth) {
                width = stack.shift() + nominalWidthX;
                haveWidth = true;
              }
              y += stack.pop();
              x += stack.pop();
              newContour(x, y);
              break;
            case 22:
              if (stack.length > 1 && !haveWidth) {
                width = stack.shift() + nominalWidthX;
                haveWidth = true;
              }
              x += stack.pop();
              newContour(x, y);
              break;
            case 23:
              parseStems();
              break;
            case 24:
              while (stack.length > 2) {
                c1x = x + stack.shift();
                c1y = y + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y = c2y + stack.shift();
                p.curveTo(c1x, c1y, c2x, c2y, x, y);
              }
              x += stack.shift();
              y += stack.shift();
              p.lineTo(x, y);
              break;
            case 25:
              while (stack.length > 6) {
                x += stack.shift();
                y += stack.shift();
                p.lineTo(x, y);
              }
              c1x = x + stack.shift();
              c1y = y + stack.shift();
              c2x = c1x + stack.shift();
              c2y = c1y + stack.shift();
              x = c2x + stack.shift();
              y = c2y + stack.shift();
              p.curveTo(c1x, c1y, c2x, c2y, x, y);
              break;
            case 26:
              if (stack.length % 2) {
                x += stack.shift();
              }
              while (stack.length > 0) {
                c1x = x;
                c1y = y + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x;
                y = c2y + stack.shift();
                p.curveTo(c1x, c1y, c2x, c2y, x, y);
              }
              break;
            case 27:
              if (stack.length % 2) {
                y += stack.shift();
              }
              while (stack.length > 0) {
                c1x = x + stack.shift();
                c1y = y;
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y = c2y;
                p.curveTo(c1x, c1y, c2x, c2y, x, y);
              }
              break;
            case 28:
              b1 = code2[i];
              b2 = code2[i + 1];
              stack.push((b1 << 24 | b2 << 16) >> 16);
              i += 2;
              break;
            case 29:
              codeIndex = stack.pop() + font.gsubrsBias;
              subrCode = font.gsubrs[codeIndex];
              if (subrCode) {
                parse$$1(subrCode);
              }
              break;
            case 30:
              while (stack.length > 0) {
                c1x = x;
                c1y = y + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y = c2y + (stack.length === 1 ? stack.shift() : 0);
                p.curveTo(c1x, c1y, c2x, c2y, x, y);
                if (stack.length === 0) {
                  break;
                }
                c1x = x + stack.shift();
                c1y = y;
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                y = c2y + stack.shift();
                x = c2x + (stack.length === 1 ? stack.shift() : 0);
                p.curveTo(c1x, c1y, c2x, c2y, x, y);
              }
              break;
            case 31:
              while (stack.length > 0) {
                c1x = x + stack.shift();
                c1y = y;
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                y = c2y + stack.shift();
                x = c2x + (stack.length === 1 ? stack.shift() : 0);
                p.curveTo(c1x, c1y, c2x, c2y, x, y);
                if (stack.length === 0) {
                  break;
                }
                c1x = x;
                c1y = y + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y = c2y + (stack.length === 1 ? stack.shift() : 0);
                p.curveTo(c1x, c1y, c2x, c2y, x, y);
              }
              break;
            default:
              if (v < 32) {
                console.log("Glyph " + glyph.index + ": unknown operator " + v);
              } else if (v < 247) {
                stack.push(v - 139);
              } else if (v < 251) {
                b1 = code2[i];
                i += 1;
                stack.push((v - 247) * 256 + b1 + 108);
              } else if (v < 255) {
                b1 = code2[i];
                i += 1;
                stack.push(-(v - 251) * 256 - b1 - 108);
              } else {
                b1 = code2[i];
                b2 = code2[i + 1];
                b3 = code2[i + 2];
                b4 = code2[i + 3];
                i += 4;
                stack.push((b1 << 24 | b2 << 16 | b3 << 8 | b4) / 65536);
              }
          }
        }
      }
      parse$$1(code);
      glyph.advanceWidth = width;
      return p;
    }
    function parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {
      var fdSelect = [];
      var fdIndex;
      var parser = new parse.Parser(data, start);
      var format = parser.parseCard8();
      if (format === 0) {
        for (var iGid = 0;iGid < nGlyphs; iGid++) {
          fdIndex = parser.parseCard8();
          if (fdIndex >= fdArrayCount) {
            throw new Error("CFF table CID Font FDSelect has bad FD index value " + fdIndex + " (FD count " + fdArrayCount + ")");
          }
          fdSelect.push(fdIndex);
        }
      } else if (format === 3) {
        var nRanges = parser.parseCard16();
        var first = parser.parseCard16();
        if (first !== 0) {
          throw new Error("CFF Table CID Font FDSelect format 3 range has bad initial GID " + first);
        }
        var next;
        for (var iRange = 0;iRange < nRanges; iRange++) {
          fdIndex = parser.parseCard8();
          next = parser.parseCard16();
          if (fdIndex >= fdArrayCount) {
            throw new Error("CFF table CID Font FDSelect has bad FD index value " + fdIndex + " (FD count " + fdArrayCount + ")");
          }
          if (next > nGlyphs) {
            throw new Error("CFF Table CID Font FDSelect format 3 range has bad GID " + next);
          }
          for (;first < next; first++) {
            fdSelect.push(fdIndex);
          }
          first = next;
        }
        if (next !== nGlyphs) {
          throw new Error("CFF Table CID Font FDSelect format 3 range has bad final GID " + next);
        }
      } else {
        throw new Error("CFF Table CID Font FDSelect table has unsupported format " + format);
      }
      return fdSelect;
    }
    function parseCFFTable(data, start, font) {
      font.tables.cff = {};
      var header = parseCFFHeader(data, start);
      var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);
      var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);
      var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);
      var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);
      font.gsubrs = globalSubrIndex.objects;
      font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);
      var topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);
      if (topDictArray.length !== 1) {
        throw new Error("CFF table has too many fonts in \'FontSet\' - count of fonts NameIndex.length = " + topDictArray.length);
      }
      var topDict = topDictArray[0];
      font.tables.cff.topDict = topDict;
      if (topDict._privateDict) {
        font.defaultWidthX = topDict._privateDict.defaultWidthX;
        font.nominalWidthX = topDict._privateDict.nominalWidthX;
      }
      if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {
        font.isCIDFont = true;
      }
      if (font.isCIDFont) {
        var fdArrayOffset = topDict.fdArray;
        var fdSelectOffset = topDict.fdSelect;
        if (fdArrayOffset === 0 || fdSelectOffset === 0) {
          throw new Error("Font is marked as a CID font, but FDArray and/or FDSelect information is missing");
        }
        fdArrayOffset += start;
        var fdArrayIndex = parseCFFIndex(data, fdArrayOffset);
        var fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);
        topDict._fdArray = fdArray;
        fdSelectOffset += start;
        topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);
      }
      var privateDictOffset = start + topDict.private[1];
      var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);
      font.defaultWidthX = privateDict.defaultWidthX;
      font.nominalWidthX = privateDict.nominalWidthX;
      if (privateDict.subrs !== 0) {
        var subrOffset = privateDictOffset + privateDict.subrs;
        var subrIndex = parseCFFIndex(data, subrOffset);
        font.subrs = subrIndex.objects;
        font.subrsBias = calcCFFSubroutineBias(font.subrs);
      } else {
        font.subrs = [];
        font.subrsBias = 0;
      }
      var charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);
      font.nGlyphs = charStringsIndex.objects.length;
      var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);
      if (topDict.encoding === 0) {
        font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);
      } else if (topDict.encoding === 1) {
        font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);
      } else {
        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);
      }
      font.encoding = font.encoding || font.cffEncoding;
      font.glyphs = new glyphset.GlyphSet(font);
      for (var i = 0;i < font.nGlyphs; i += 1) {
        var charString = charStringsIndex.objects[i];
        font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));
      }
    }
    function encodeString(s, strings) {
      var sid;
      var i = cffStandardStrings.indexOf(s);
      if (i >= 0) {
        sid = i;
      }
      i = strings.indexOf(s);
      if (i >= 0) {
        sid = i + cffStandardStrings.length;
      } else {
        sid = cffStandardStrings.length + strings.length;
        strings.push(s);
      }
      return sid;
    }
    function makeHeader() {
      return new table.Record("Header", [
        { name: "major", type: "Card8", value: 1 },
        { name: "minor", type: "Card8", value: 0 },
        { name: "hdrSize", type: "Card8", value: 4 },
        { name: "major", type: "Card8", value: 1 }
      ]);
    }
    function makeNameIndex(fontNames) {
      var t = new table.Record("Name INDEX", [
        { name: "names", type: "INDEX", value: [] }
      ]);
      t.names = [];
      for (var i = 0;i < fontNames.length; i += 1) {
        t.names.push({ name: "name_" + i, type: "NAME", value: fontNames[i] });
      }
      return t;
    }
    function makeDict(meta2, attrs, strings) {
      var m = {};
      for (var i = 0;i < meta2.length; i += 1) {
        var entry = meta2[i];
        var value = attrs[entry.name];
        if (value !== undefined && !equals(value, entry.value)) {
          if (entry.type === "SID") {
            value = encodeString(value, strings);
          }
          m[entry.op] = { name: entry.name, type: entry.type, value };
        }
      }
      return m;
    }
    function makeTopDict(attrs, strings) {
      var t = new table.Record("Top DICT", [
        { name: "dict", type: "DICT", value: {} }
      ]);
      t.dict = makeDict(TOP_DICT_META, attrs, strings);
      return t;
    }
    function makeTopDictIndex(topDict) {
      var t = new table.Record("Top DICT INDEX", [
        { name: "topDicts", type: "INDEX", value: [] }
      ]);
      t.topDicts = [{ name: "topDict_0", type: "TABLE", value: topDict }];
      return t;
    }
    function makeStringIndex(strings) {
      var t = new table.Record("String INDEX", [
        { name: "strings", type: "INDEX", value: [] }
      ]);
      t.strings = [];
      for (var i = 0;i < strings.length; i += 1) {
        t.strings.push({ name: "string_" + i, type: "STRING", value: strings[i] });
      }
      return t;
    }
    function makeGlobalSubrIndex() {
      return new table.Record("Global Subr INDEX", [
        { name: "subrs", type: "INDEX", value: [] }
      ]);
    }
    function makeCharsets(glyphNames, strings) {
      var t = new table.Record("Charsets", [
        { name: "format", type: "Card8", value: 0 }
      ]);
      for (var i = 0;i < glyphNames.length; i += 1) {
        var glyphName = glyphNames[i];
        var glyphSID = encodeString(glyphName, strings);
        t.fields.push({ name: "glyph_" + i, type: "SID", value: glyphSID });
      }
      return t;
    }
    function glyphToOps(glyph) {
      var ops = [];
      var path = glyph.path;
      ops.push({ name: "width", type: "NUMBER", value: glyph.advanceWidth });
      var x = 0;
      var y = 0;
      for (var i = 0;i < path.commands.length; i += 1) {
        var dx = undefined;
        var dy = undefined;
        var cmd = path.commands[i];
        if (cmd.type === "Q") {
          var _13 = 1 / 3;
          var _23 = 2 / 3;
          cmd = {
            type: "C",
            x: cmd.x,
            y: cmd.y,
            x1: _13 * x + _23 * cmd.x1,
            y1: _13 * y + _23 * cmd.y1,
            x2: _13 * cmd.x + _23 * cmd.x1,
            y2: _13 * cmd.y + _23 * cmd.y1
          };
        }
        if (cmd.type === "M") {
          dx = Math.round(cmd.x - x);
          dy = Math.round(cmd.y - y);
          ops.push({ name: "dx", type: "NUMBER", value: dx });
          ops.push({ name: "dy", type: "NUMBER", value: dy });
          ops.push({ name: "rmoveto", type: "OP", value: 21 });
          x = Math.round(cmd.x);
          y = Math.round(cmd.y);
        } else if (cmd.type === "L") {
          dx = Math.round(cmd.x - x);
          dy = Math.round(cmd.y - y);
          ops.push({ name: "dx", type: "NUMBER", value: dx });
          ops.push({ name: "dy", type: "NUMBER", value: dy });
          ops.push({ name: "rlineto", type: "OP", value: 5 });
          x = Math.round(cmd.x);
          y = Math.round(cmd.y);
        } else if (cmd.type === "C") {
          var dx1 = Math.round(cmd.x1 - x);
          var dy1 = Math.round(cmd.y1 - y);
          var dx2 = Math.round(cmd.x2 - cmd.x1);
          var dy2 = Math.round(cmd.y2 - cmd.y1);
          dx = Math.round(cmd.x - cmd.x2);
          dy = Math.round(cmd.y - cmd.y2);
          ops.push({ name: "dx1", type: "NUMBER", value: dx1 });
          ops.push({ name: "dy1", type: "NUMBER", value: dy1 });
          ops.push({ name: "dx2", type: "NUMBER", value: dx2 });
          ops.push({ name: "dy2", type: "NUMBER", value: dy2 });
          ops.push({ name: "dx", type: "NUMBER", value: dx });
          ops.push({ name: "dy", type: "NUMBER", value: dy });
          ops.push({ name: "rrcurveto", type: "OP", value: 8 });
          x = Math.round(cmd.x);
          y = Math.round(cmd.y);
        }
      }
      ops.push({ name: "endchar", type: "OP", value: 14 });
      return ops;
    }
    function makeCharStringsIndex(glyphs) {
      var t = new table.Record("CharStrings INDEX", [
        { name: "charStrings", type: "INDEX", value: [] }
      ]);
      for (var i = 0;i < glyphs.length; i += 1) {
        var glyph = glyphs.get(i);
        var ops = glyphToOps(glyph);
        t.charStrings.push({ name: glyph.name, type: "CHARSTRING", value: ops });
      }
      return t;
    }
    function makePrivateDict(attrs, strings) {
      var t = new table.Record("Private DICT", [
        { name: "dict", type: "DICT", value: {} }
      ]);
      t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);
      return t;
    }
    function makeCFFTable(glyphs, options) {
      var t = new table.Table("CFF ", [
        { name: "header", type: "RECORD" },
        { name: "nameIndex", type: "RECORD" },
        { name: "topDictIndex", type: "RECORD" },
        { name: "stringIndex", type: "RECORD" },
        { name: "globalSubrIndex", type: "RECORD" },
        { name: "charsets", type: "RECORD" },
        { name: "charStringsIndex", type: "RECORD" },
        { name: "privateDict", type: "RECORD" }
      ]);
      var fontScale = 1 / options.unitsPerEm;
      var attrs = {
        version: options.version,
        fullName: options.fullName,
        familyName: options.familyName,
        weight: options.weightName,
        fontBBox: options.fontBBox || [0, 0, 0, 0],
        fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],
        charset: 999,
        encoding: 0,
        charStrings: 999,
        private: [0, 999]
      };
      var privateAttrs = {};
      var glyphNames = [];
      var glyph;
      for (var i = 1;i < glyphs.length; i += 1) {
        glyph = glyphs.get(i);
        glyphNames.push(glyph.name);
      }
      var strings = [];
      t.header = makeHeader();
      t.nameIndex = makeNameIndex([options.postScriptName]);
      var topDict = makeTopDict(attrs, strings);
      t.topDictIndex = makeTopDictIndex(topDict);
      t.globalSubrIndex = makeGlobalSubrIndex();
      t.charsets = makeCharsets(glyphNames, strings);
      t.charStringsIndex = makeCharStringsIndex(glyphs);
      t.privateDict = makePrivateDict(privateAttrs, strings);
      t.stringIndex = makeStringIndex(strings);
      var startOffset = t.header.sizeOf() + t.nameIndex.sizeOf() + t.topDictIndex.sizeOf() + t.stringIndex.sizeOf() + t.globalSubrIndex.sizeOf();
      attrs.charset = startOffset;
      attrs.encoding = 0;
      attrs.charStrings = attrs.charset + t.charsets.sizeOf();
      attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();
      topDict = makeTopDict(attrs, strings);
      t.topDictIndex = makeTopDictIndex(topDict);
      return t;
    }
    var cff = { parse: parseCFFTable, make: makeCFFTable };
    function parseHeadTable(data, start) {
      var head2 = {};
      var p = new parse.Parser(data, start);
      head2.version = p.parseVersion();
      head2.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;
      head2.checkSumAdjustment = p.parseULong();
      head2.magicNumber = p.parseULong();
      check.argument(head2.magicNumber === 1594834165, "Font header has wrong magic number.");
      head2.flags = p.parseUShort();
      head2.unitsPerEm = p.parseUShort();
      head2.created = p.parseLongDateTime();
      head2.modified = p.parseLongDateTime();
      head2.xMin = p.parseShort();
      head2.yMin = p.parseShort();
      head2.xMax = p.parseShort();
      head2.yMax = p.parseShort();
      head2.macStyle = p.parseUShort();
      head2.lowestRecPPEM = p.parseUShort();
      head2.fontDirectionHint = p.parseShort();
      head2.indexToLocFormat = p.parseShort();
      head2.glyphDataFormat = p.parseShort();
      return head2;
    }
    function makeHeadTable(options) {
      var timestamp = Math.round(new Date().getTime() / 1000) + 2082844800;
      var createdTimestamp = timestamp;
      if (options.createdTimestamp) {
        createdTimestamp = options.createdTimestamp + 2082844800;
      }
      return new table.Table("head", [
        { name: "version", type: "FIXED", value: 65536 },
        { name: "fontRevision", type: "FIXED", value: 65536 },
        { name: "checkSumAdjustment", type: "ULONG", value: 0 },
        { name: "magicNumber", type: "ULONG", value: 1594834165 },
        { name: "flags", type: "USHORT", value: 0 },
        { name: "unitsPerEm", type: "USHORT", value: 1000 },
        { name: "created", type: "LONGDATETIME", value: createdTimestamp },
        { name: "modified", type: "LONGDATETIME", value: timestamp },
        { name: "xMin", type: "SHORT", value: 0 },
        { name: "yMin", type: "SHORT", value: 0 },
        { name: "xMax", type: "SHORT", value: 0 },
        { name: "yMax", type: "SHORT", value: 0 },
        { name: "macStyle", type: "USHORT", value: 0 },
        { name: "lowestRecPPEM", type: "USHORT", value: 0 },
        { name: "fontDirectionHint", type: "SHORT", value: 2 },
        { name: "indexToLocFormat", type: "SHORT", value: 0 },
        { name: "glyphDataFormat", type: "SHORT", value: 0 }
      ], options);
    }
    var head = { parse: parseHeadTable, make: makeHeadTable };
    function parseHheaTable(data, start) {
      var hhea2 = {};
      var p = new parse.Parser(data, start);
      hhea2.version = p.parseVersion();
      hhea2.ascender = p.parseShort();
      hhea2.descender = p.parseShort();
      hhea2.lineGap = p.parseShort();
      hhea2.advanceWidthMax = p.parseUShort();
      hhea2.minLeftSideBearing = p.parseShort();
      hhea2.minRightSideBearing = p.parseShort();
      hhea2.xMaxExtent = p.parseShort();
      hhea2.caretSlopeRise = p.parseShort();
      hhea2.caretSlopeRun = p.parseShort();
      hhea2.caretOffset = p.parseShort();
      p.relativeOffset += 8;
      hhea2.metricDataFormat = p.parseShort();
      hhea2.numberOfHMetrics = p.parseUShort();
      return hhea2;
    }
    function makeHheaTable(options) {
      return new table.Table("hhea", [
        { name: "version", type: "FIXED", value: 65536 },
        { name: "ascender", type: "FWORD", value: 0 },
        { name: "descender", type: "FWORD", value: 0 },
        { name: "lineGap", type: "FWORD", value: 0 },
        { name: "advanceWidthMax", type: "UFWORD", value: 0 },
        { name: "minLeftSideBearing", type: "FWORD", value: 0 },
        { name: "minRightSideBearing", type: "FWORD", value: 0 },
        { name: "xMaxExtent", type: "FWORD", value: 0 },
        { name: "caretSlopeRise", type: "SHORT", value: 1 },
        { name: "caretSlopeRun", type: "SHORT", value: 0 },
        { name: "caretOffset", type: "SHORT", value: 0 },
        { name: "reserved1", type: "SHORT", value: 0 },
        { name: "reserved2", type: "SHORT", value: 0 },
        { name: "reserved3", type: "SHORT", value: 0 },
        { name: "reserved4", type: "SHORT", value: 0 },
        { name: "metricDataFormat", type: "SHORT", value: 0 },
        { name: "numberOfHMetrics", type: "USHORT", value: 0 }
      ], options);
    }
    var hhea = { parse: parseHheaTable, make: makeHheaTable };
    function parseHmtxTable(data, start, numMetrics, numGlyphs, glyphs) {
      var advanceWidth;
      var leftSideBearing;
      var p = new parse.Parser(data, start);
      for (var i = 0;i < numGlyphs; i += 1) {
        if (i < numMetrics) {
          advanceWidth = p.parseUShort();
          leftSideBearing = p.parseShort();
        }
        var glyph = glyphs.get(i);
        glyph.advanceWidth = advanceWidth;
        glyph.leftSideBearing = leftSideBearing;
      }
    }
    function makeHmtxTable(glyphs) {
      var t = new table.Table("hmtx", []);
      for (var i = 0;i < glyphs.length; i += 1) {
        var glyph = glyphs.get(i);
        var advanceWidth = glyph.advanceWidth || 0;
        var leftSideBearing = glyph.leftSideBearing || 0;
        t.fields.push({ name: "advanceWidth_" + i, type: "USHORT", value: advanceWidth });
        t.fields.push({ name: "leftSideBearing_" + i, type: "SHORT", value: leftSideBearing });
      }
      return t;
    }
    var hmtx = { parse: parseHmtxTable, make: makeHmtxTable };
    function makeLtagTable(tags) {
      var result = new table.Table("ltag", [
        { name: "version", type: "ULONG", value: 1 },
        { name: "flags", type: "ULONG", value: 0 },
        { name: "numTags", type: "ULONG", value: tags.length }
      ]);
      var stringPool = "";
      var stringPoolOffset = 12 + tags.length * 4;
      for (var i = 0;i < tags.length; ++i) {
        var pos = stringPool.indexOf(tags[i]);
        if (pos < 0) {
          pos = stringPool.length;
          stringPool += tags[i];
        }
        result.fields.push({ name: "offset " + i, type: "USHORT", value: stringPoolOffset + pos });
        result.fields.push({ name: "length " + i, type: "USHORT", value: tags[i].length });
      }
      result.fields.push({ name: "stringPool", type: "CHARARRAY", value: stringPool });
      return result;
    }
    function parseLtagTable(data, start) {
      var p = new parse.Parser(data, start);
      var tableVersion = p.parseULong();
      check.argument(tableVersion === 1, "Unsupported ltag table version.");
      p.skip("uLong", 1);
      var numTags = p.parseULong();
      var tags = [];
      for (var i = 0;i < numTags; i++) {
        var tag = "";
        var offset = start + p.parseUShort();
        var length = p.parseUShort();
        for (var j = offset;j < offset + length; ++j) {
          tag += String.fromCharCode(data.getInt8(j));
        }
        tags.push(tag);
      }
      return tags;
    }
    var ltag = { make: makeLtagTable, parse: parseLtagTable };
    function parseMaxpTable(data, start) {
      var maxp2 = {};
      var p = new parse.Parser(data, start);
      maxp2.version = p.parseVersion();
      maxp2.numGlyphs = p.parseUShort();
      if (maxp2.version === 1) {
        maxp2.maxPoints = p.parseUShort();
        maxp2.maxContours = p.parseUShort();
        maxp2.maxCompositePoints = p.parseUShort();
        maxp2.maxCompositeContours = p.parseUShort();
        maxp2.maxZones = p.parseUShort();
        maxp2.maxTwilightPoints = p.parseUShort();
        maxp2.maxStorage = p.parseUShort();
        maxp2.maxFunctionDefs = p.parseUShort();
        maxp2.maxInstructionDefs = p.parseUShort();
        maxp2.maxStackElements = p.parseUShort();
        maxp2.maxSizeOfInstructions = p.parseUShort();
        maxp2.maxComponentElements = p.parseUShort();
        maxp2.maxComponentDepth = p.parseUShort();
      }
      return maxp2;
    }
    function makeMaxpTable(numGlyphs) {
      return new table.Table("maxp", [
        { name: "version", type: "FIXED", value: 20480 },
        { name: "numGlyphs", type: "USHORT", value: numGlyphs }
      ]);
    }
    var maxp = { parse: parseMaxpTable, make: makeMaxpTable };
    var nameTableNames = [
      "copyright",
      "fontFamily",
      "fontSubfamily",
      "uniqueID",
      "fullName",
      "version",
      "postScriptName",
      "trademark",
      "manufacturer",
      "designer",
      "description",
      "manufacturerURL",
      "designerURL",
      "license",
      "licenseURL",
      "reserved",
      "preferredFamily",
      "preferredSubfamily",
      "compatibleFullName",
      "sampleText",
      "postScriptFindFontName",
      "wwsFamily",
      "wwsSubfamily"
    ];
    var macLanguages = {
      0: "en",
      1: "fr",
      2: "de",
      3: "it",
      4: "nl",
      5: "sv",
      6: "es",
      7: "da",
      8: "pt",
      9: "no",
      10: "he",
      11: "ja",
      12: "ar",
      13: "fi",
      14: "el",
      15: "is",
      16: "mt",
      17: "tr",
      18: "hr",
      19: "zh-Hant",
      20: "ur",
      21: "hi",
      22: "th",
      23: "ko",
      24: "lt",
      25: "pl",
      26: "hu",
      27: "es",
      28: "lv",
      29: "se",
      30: "fo",
      31: "fa",
      32: "ru",
      33: "zh",
      34: "nl-BE",
      35: "ga",
      36: "sq",
      37: "ro",
      38: "cz",
      39: "sk",
      40: "si",
      41: "yi",
      42: "sr",
      43: "mk",
      44: "bg",
      45: "uk",
      46: "be",
      47: "uz",
      48: "kk",
      49: "az-Cyrl",
      50: "az-Arab",
      51: "hy",
      52: "ka",
      53: "mo",
      54: "ky",
      55: "tg",
      56: "tk",
      57: "mn-CN",
      58: "mn",
      59: "ps",
      60: "ks",
      61: "ku",
      62: "sd",
      63: "bo",
      64: "ne",
      65: "sa",
      66: "mr",
      67: "bn",
      68: "as",
      69: "gu",
      70: "pa",
      71: "or",
      72: "ml",
      73: "kn",
      74: "ta",
      75: "te",
      76: "si",
      77: "my",
      78: "km",
      79: "lo",
      80: "vi",
      81: "id",
      82: "tl",
      83: "ms",
      84: "ms-Arab",
      85: "am",
      86: "ti",
      87: "om",
      88: "so",
      89: "sw",
      90: "rw",
      91: "rn",
      92: "ny",
      93: "mg",
      94: "eo",
      128: "cy",
      129: "eu",
      130: "ca",
      131: "la",
      132: "qu",
      133: "gn",
      134: "ay",
      135: "tt",
      136: "ug",
      137: "dz",
      138: "jv",
      139: "su",
      140: "gl",
      141: "af",
      142: "br",
      143: "iu",
      144: "gd",
      145: "gv",
      146: "ga",
      147: "to",
      148: "el-polyton",
      149: "kl",
      150: "az",
      151: "nn"
    };
    var macLanguageToScript = {
      0: 0,
      1: 0,
      2: 0,
      3: 0,
      4: 0,
      5: 0,
      6: 0,
      7: 0,
      8: 0,
      9: 0,
      10: 5,
      11: 1,
      12: 4,
      13: 0,
      14: 6,
      15: 0,
      16: 0,
      17: 0,
      18: 0,
      19: 2,
      20: 4,
      21: 9,
      22: 21,
      23: 3,
      24: 29,
      25: 29,
      26: 29,
      27: 29,
      28: 29,
      29: 0,
      30: 0,
      31: 4,
      32: 7,
      33: 25,
      34: 0,
      35: 0,
      36: 0,
      37: 0,
      38: 29,
      39: 29,
      40: 0,
      41: 5,
      42: 7,
      43: 7,
      44: 7,
      45: 7,
      46: 7,
      47: 7,
      48: 7,
      49: 7,
      50: 4,
      51: 24,
      52: 23,
      53: 7,
      54: 7,
      55: 7,
      56: 7,
      57: 27,
      58: 7,
      59: 4,
      60: 4,
      61: 4,
      62: 4,
      63: 26,
      64: 9,
      65: 9,
      66: 9,
      67: 13,
      68: 13,
      69: 11,
      70: 10,
      71: 12,
      72: 17,
      73: 16,
      74: 14,
      75: 15,
      76: 18,
      77: 19,
      78: 20,
      79: 22,
      80: 30,
      81: 0,
      82: 0,
      83: 0,
      84: 4,
      85: 28,
      86: 28,
      87: 28,
      88: 0,
      89: 0,
      90: 0,
      91: 0,
      92: 0,
      93: 0,
      94: 0,
      128: 0,
      129: 0,
      130: 0,
      131: 0,
      132: 0,
      133: 0,
      134: 0,
      135: 7,
      136: 4,
      137: 26,
      138: 0,
      139: 0,
      140: 0,
      141: 0,
      142: 0,
      143: 28,
      144: 0,
      145: 0,
      146: 0,
      147: 0,
      148: 6,
      149: 0,
      150: 0,
      151: 0
    };
    var windowsLanguages = {
      1078: "af",
      1052: "sq",
      1156: "gsw",
      1118: "am",
      5121: "ar-DZ",
      15361: "ar-BH",
      3073: "ar",
      2049: "ar-IQ",
      11265: "ar-JO",
      13313: "ar-KW",
      12289: "ar-LB",
      4097: "ar-LY",
      6145: "ary",
      8193: "ar-OM",
      16385: "ar-QA",
      1025: "ar-SA",
      10241: "ar-SY",
      7169: "aeb",
      14337: "ar-AE",
      9217: "ar-YE",
      1067: "hy",
      1101: "as",
      2092: "az-Cyrl",
      1068: "az",
      1133: "ba",
      1069: "eu",
      1059: "be",
      2117: "bn",
      1093: "bn-IN",
      8218: "bs-Cyrl",
      5146: "bs",
      1150: "br",
      1026: "bg",
      1027: "ca",
      3076: "zh-HK",
      5124: "zh-MO",
      2052: "zh",
      4100: "zh-SG",
      1028: "zh-TW",
      1155: "co",
      1050: "hr",
      4122: "hr-BA",
      1029: "cs",
      1030: "da",
      1164: "prs",
      1125: "dv",
      2067: "nl-BE",
      1043: "nl",
      3081: "en-AU",
      10249: "en-BZ",
      4105: "en-CA",
      9225: "en-029",
      16393: "en-IN",
      6153: "en-IE",
      8201: "en-JM",
      17417: "en-MY",
      5129: "en-NZ",
      13321: "en-PH",
      18441: "en-SG",
      7177: "en-ZA",
      11273: "en-TT",
      2057: "en-GB",
      1033: "en",
      12297: "en-ZW",
      1061: "et",
      1080: "fo",
      1124: "fil",
      1035: "fi",
      2060: "fr-BE",
      3084: "fr-CA",
      1036: "fr",
      5132: "fr-LU",
      6156: "fr-MC",
      4108: "fr-CH",
      1122: "fy",
      1110: "gl",
      1079: "ka",
      3079: "de-AT",
      1031: "de",
      5127: "de-LI",
      4103: "de-LU",
      2055: "de-CH",
      1032: "el",
      1135: "kl",
      1095: "gu",
      1128: "ha",
      1037: "he",
      1081: "hi",
      1038: "hu",
      1039: "is",
      1136: "ig",
      1057: "id",
      1117: "iu",
      2141: "iu-Latn",
      2108: "ga",
      1076: "xh",
      1077: "zu",
      1040: "it",
      2064: "it-CH",
      1041: "ja",
      1099: "kn",
      1087: "kk",
      1107: "km",
      1158: "quc",
      1159: "rw",
      1089: "sw",
      1111: "kok",
      1042: "ko",
      1088: "ky",
      1108: "lo",
      1062: "lv",
      1063: "lt",
      2094: "dsb",
      1134: "lb",
      1071: "mk",
      2110: "ms-BN",
      1086: "ms",
      1100: "ml",
      1082: "mt",
      1153: "mi",
      1146: "arn",
      1102: "mr",
      1148: "moh",
      1104: "mn",
      2128: "mn-CN",
      1121: "ne",
      1044: "nb",
      2068: "nn",
      1154: "oc",
      1096: "or",
      1123: "ps",
      1045: "pl",
      1046: "pt",
      2070: "pt-PT",
      1094: "pa",
      1131: "qu-BO",
      2155: "qu-EC",
      3179: "qu",
      1048: "ro",
      1047: "rm",
      1049: "ru",
      9275: "smn",
      4155: "smj-NO",
      5179: "smj",
      3131: "se-FI",
      1083: "se",
      2107: "se-SE",
      8251: "sms",
      6203: "sma-NO",
      7227: "sms",
      1103: "sa",
      7194: "sr-Cyrl-BA",
      3098: "sr",
      6170: "sr-Latn-BA",
      2074: "sr-Latn",
      1132: "nso",
      1074: "tn",
      1115: "si",
      1051: "sk",
      1060: "sl",
      11274: "es-AR",
      16394: "es-BO",
      13322: "es-CL",
      9226: "es-CO",
      5130: "es-CR",
      7178: "es-DO",
      12298: "es-EC",
      17418: "es-SV",
      4106: "es-GT",
      18442: "es-HN",
      2058: "es-MX",
      19466: "es-NI",
      6154: "es-PA",
      15370: "es-PY",
      10250: "es-PE",
      20490: "es-PR",
      3082: "es",
      1034: "es",
      21514: "es-US",
      14346: "es-UY",
      8202: "es-VE",
      2077: "sv-FI",
      1053: "sv",
      1114: "syr",
      1064: "tg",
      2143: "tzm",
      1097: "ta",
      1092: "tt",
      1098: "te",
      1054: "th",
      1105: "bo",
      1055: "tr",
      1090: "tk",
      1152: "ug",
      1058: "uk",
      1070: "hsb",
      1056: "ur",
      2115: "uz-Cyrl",
      1091: "uz",
      1066: "vi",
      1106: "cy",
      1160: "wo",
      1157: "sah",
      1144: "ii",
      1130: "yo"
    };
    function getLanguageCode(platformID, languageID, ltag2) {
      switch (platformID) {
        case 0:
          if (languageID === 65535) {
            return "und";
          } else if (ltag2) {
            return ltag2[languageID];
          }
          break;
        case 1:
          return macLanguages[languageID];
        case 3:
          return windowsLanguages[languageID];
      }
      return;
    }
    var utf16 = "utf-16";
    var macScriptEncodings = {
      0: "macintosh",
      1: "x-mac-japanese",
      2: "x-mac-chinesetrad",
      3: "x-mac-korean",
      6: "x-mac-greek",
      7: "x-mac-cyrillic",
      9: "x-mac-devanagai",
      10: "x-mac-gurmukhi",
      11: "x-mac-gujarati",
      12: "x-mac-oriya",
      13: "x-mac-bengali",
      14: "x-mac-tamil",
      15: "x-mac-telugu",
      16: "x-mac-kannada",
      17: "x-mac-malayalam",
      18: "x-mac-sinhalese",
      19: "x-mac-burmese",
      20: "x-mac-khmer",
      21: "x-mac-thai",
      22: "x-mac-lao",
      23: "x-mac-georgian",
      24: "x-mac-armenian",
      25: "x-mac-chinesesimp",
      26: "x-mac-tibetan",
      27: "x-mac-mongolian",
      28: "x-mac-ethiopic",
      29: "x-mac-ce",
      30: "x-mac-vietnamese",
      31: "x-mac-extarabic"
    };
    var macLanguageEncodings = {
      15: "x-mac-icelandic",
      17: "x-mac-turkish",
      18: "x-mac-croatian",
      24: "x-mac-ce",
      25: "x-mac-ce",
      26: "x-mac-ce",
      27: "x-mac-ce",
      28: "x-mac-ce",
      30: "x-mac-icelandic",
      37: "x-mac-romanian",
      38: "x-mac-ce",
      39: "x-mac-ce",
      40: "x-mac-ce",
      143: "x-mac-inuit",
      146: "x-mac-gaelic"
    };
    function getEncoding(platformID, encodingID, languageID) {
      switch (platformID) {
        case 0:
          return utf16;
        case 1:
          return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];
        case 3:
          if (encodingID === 1 || encodingID === 10) {
            return utf16;
          }
          break;
      }
      return;
    }
    function parseNameTable(data, start, ltag2) {
      var name = {};
      var p = new parse.Parser(data, start);
      var format = p.parseUShort();
      var count = p.parseUShort();
      var stringOffset = p.offset + p.parseUShort();
      for (var i = 0;i < count; i++) {
        var platformID = p.parseUShort();
        var encodingID = p.parseUShort();
        var languageID = p.parseUShort();
        var nameID = p.parseUShort();
        var property = nameTableNames[nameID] || nameID;
        var byteLength = p.parseUShort();
        var offset = p.parseUShort();
        var language = getLanguageCode(platformID, languageID, ltag2);
        var encoding = getEncoding(platformID, encodingID, languageID);
        if (encoding !== undefined && language !== undefined) {
          var text = undefined;
          if (encoding === utf16) {
            text = decode.UTF16(data, stringOffset + offset, byteLength);
          } else {
            text = decode.MACSTRING(data, stringOffset + offset, byteLength, encoding);
          }
          if (text) {
            var translations = name[property];
            if (translations === undefined) {
              translations = name[property] = {};
            }
            translations[language] = text;
          }
        }
      }
      var langTagCount = 0;
      if (format === 1) {
        langTagCount = p.parseUShort();
      }
      return name;
    }
    function reverseDict(dict) {
      var result = {};
      for (var key in dict) {
        result[dict[key]] = parseInt(key);
      }
      return result;
    }
    function makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {
      return new table.Record("NameRecord", [
        { name: "platformID", type: "USHORT", value: platformID },
        { name: "encodingID", type: "USHORT", value: encodingID },
        { name: "languageID", type: "USHORT", value: languageID },
        { name: "nameID", type: "USHORT", value: nameID },
        { name: "length", type: "USHORT", value: length },
        { name: "offset", type: "USHORT", value: offset }
      ]);
    }
    function findSubArray(needle, haystack) {
      var needleLength = needle.length;
      var limit = haystack.length - needleLength + 1;
      loop:
        for (var pos = 0;pos < limit; pos++) {
          for (;pos < limit; pos++) {
            for (var k = 0;k < needleLength; k++) {
              if (haystack[pos + k] !== needle[k]) {
                continue loop;
              }
            }
            return pos;
          }
        }
      return -1;
    }
    function addStringToPool(s, pool) {
      var offset = findSubArray(s, pool);
      if (offset < 0) {
        offset = pool.length;
        var i = 0;
        var len = s.length;
        for (;i < len; ++i) {
          pool.push(s[i]);
        }
      }
      return offset;
    }
    function makeNameTable(names, ltag2) {
      var nameID;
      var nameIDs = [];
      var namesWithNumericKeys = {};
      var nameTableIds = reverseDict(nameTableNames);
      for (var key in names) {
        var id = nameTableIds[key];
        if (id === undefined) {
          id = key;
        }
        nameID = parseInt(id);
        if (isNaN(nameID)) {
          throw new Error('Name table entry "' + key + '" does not exist, see nameTableNames for complete list.');
        }
        namesWithNumericKeys[nameID] = names[key];
        nameIDs.push(nameID);
      }
      var macLanguageIds = reverseDict(macLanguages);
      var windowsLanguageIds = reverseDict(windowsLanguages);
      var nameRecords = [];
      var stringPool = [];
      for (var i = 0;i < nameIDs.length; i++) {
        nameID = nameIDs[i];
        var translations = namesWithNumericKeys[nameID];
        for (var lang in translations) {
          var text = translations[lang];
          var macPlatform = 1;
          var macLanguage = macLanguageIds[lang];
          var macScript = macLanguageToScript[macLanguage];
          var macEncoding = getEncoding(macPlatform, macScript, macLanguage);
          var macName = encode.MACSTRING(text, macEncoding);
          if (macName === undefined) {
            macPlatform = 0;
            macLanguage = ltag2.indexOf(lang);
            if (macLanguage < 0) {
              macLanguage = ltag2.length;
              ltag2.push(lang);
            }
            macScript = 4;
            macName = encode.UTF16(text);
          }
          var macNameOffset = addStringToPool(macName, stringPool);
          nameRecords.push(makeNameRecord(macPlatform, macScript, macLanguage, nameID, macName.length, macNameOffset));
          var winLanguage = windowsLanguageIds[lang];
          if (winLanguage !== undefined) {
            var winName = encode.UTF16(text);
            var winNameOffset = addStringToPool(winName, stringPool);
            nameRecords.push(makeNameRecord(3, 1, winLanguage, nameID, winName.length, winNameOffset));
          }
        }
      }
      nameRecords.sort(function(a, b) {
        return a.platformID - b.platformID || a.encodingID - b.encodingID || a.languageID - b.languageID || a.nameID - b.nameID;
      });
      var t = new table.Table("name", [
        { name: "format", type: "USHORT", value: 0 },
        { name: "count", type: "USHORT", value: nameRecords.length },
        { name: "stringOffset", type: "USHORT", value: 6 + nameRecords.length * 12 }
      ]);
      for (var r = 0;r < nameRecords.length; r++) {
        t.fields.push({ name: "record_" + r, type: "RECORD", value: nameRecords[r] });
      }
      t.fields.push({ name: "strings", type: "LITERAL", value: stringPool });
      return t;
    }
    var _name = { parse: parseNameTable, make: makeNameTable };
    var unicodeRanges = [
      { begin: 0, end: 127 },
      { begin: 128, end: 255 },
      { begin: 256, end: 383 },
      { begin: 384, end: 591 },
      { begin: 592, end: 687 },
      { begin: 688, end: 767 },
      { begin: 768, end: 879 },
      { begin: 880, end: 1023 },
      { begin: 11392, end: 11519 },
      { begin: 1024, end: 1279 },
      { begin: 1328, end: 1423 },
      { begin: 1424, end: 1535 },
      { begin: 42240, end: 42559 },
      { begin: 1536, end: 1791 },
      { begin: 1984, end: 2047 },
      { begin: 2304, end: 2431 },
      { begin: 2432, end: 2559 },
      { begin: 2560, end: 2687 },
      { begin: 2688, end: 2815 },
      { begin: 2816, end: 2943 },
      { begin: 2944, end: 3071 },
      { begin: 3072, end: 3199 },
      { begin: 3200, end: 3327 },
      { begin: 3328, end: 3455 },
      { begin: 3584, end: 3711 },
      { begin: 3712, end: 3839 },
      { begin: 4256, end: 4351 },
      { begin: 6912, end: 7039 },
      { begin: 4352, end: 4607 },
      { begin: 7680, end: 7935 },
      { begin: 7936, end: 8191 },
      { begin: 8192, end: 8303 },
      { begin: 8304, end: 8351 },
      { begin: 8352, end: 8399 },
      { begin: 8400, end: 8447 },
      { begin: 8448, end: 8527 },
      { begin: 8528, end: 8591 },
      { begin: 8592, end: 8703 },
      { begin: 8704, end: 8959 },
      { begin: 8960, end: 9215 },
      { begin: 9216, end: 9279 },
      { begin: 9280, end: 9311 },
      { begin: 9312, end: 9471 },
      { begin: 9472, end: 9599 },
      { begin: 9600, end: 9631 },
      { begin: 9632, end: 9727 },
      { begin: 9728, end: 9983 },
      { begin: 9984, end: 10175 },
      { begin: 12288, end: 12351 },
      { begin: 12352, end: 12447 },
      { begin: 12448, end: 12543 },
      { begin: 12544, end: 12591 },
      { begin: 12592, end: 12687 },
      { begin: 43072, end: 43135 },
      { begin: 12800, end: 13055 },
      { begin: 13056, end: 13311 },
      { begin: 44032, end: 55215 },
      { begin: 55296, end: 57343 },
      { begin: 67840, end: 67871 },
      { begin: 19968, end: 40959 },
      { begin: 57344, end: 63743 },
      { begin: 12736, end: 12783 },
      { begin: 64256, end: 64335 },
      { begin: 64336, end: 65023 },
      { begin: 65056, end: 65071 },
      { begin: 65040, end: 65055 },
      { begin: 65104, end: 65135 },
      { begin: 65136, end: 65279 },
      { begin: 65280, end: 65519 },
      { begin: 65520, end: 65535 },
      { begin: 3840, end: 4095 },
      { begin: 1792, end: 1871 },
      { begin: 1920, end: 1983 },
      { begin: 3456, end: 3583 },
      { begin: 4096, end: 4255 },
      { begin: 4608, end: 4991 },
      { begin: 5024, end: 5119 },
      { begin: 5120, end: 5759 },
      { begin: 5760, end: 5791 },
      { begin: 5792, end: 5887 },
      { begin: 6016, end: 6143 },
      { begin: 6144, end: 6319 },
      { begin: 10240, end: 10495 },
      { begin: 40960, end: 42127 },
      { begin: 5888, end: 5919 },
      { begin: 66304, end: 66351 },
      { begin: 66352, end: 66383 },
      { begin: 66560, end: 66639 },
      { begin: 118784, end: 119039 },
      { begin: 119808, end: 120831 },
      { begin: 1044480, end: 1048573 },
      { begin: 65024, end: 65039 },
      { begin: 917504, end: 917631 },
      { begin: 6400, end: 6479 },
      { begin: 6480, end: 6527 },
      { begin: 6528, end: 6623 },
      { begin: 6656, end: 6687 },
      { begin: 11264, end: 11359 },
      { begin: 11568, end: 11647 },
      { begin: 19904, end: 19967 },
      { begin: 43008, end: 43055 },
      { begin: 65536, end: 65663 },
      { begin: 65856, end: 65935 },
      { begin: 66432, end: 66463 },
      { begin: 66464, end: 66527 },
      { begin: 66640, end: 66687 },
      { begin: 66688, end: 66735 },
      { begin: 67584, end: 67647 },
      { begin: 68096, end: 68191 },
      { begin: 119552, end: 119647 },
      { begin: 73728, end: 74751 },
      { begin: 119648, end: 119679 },
      { begin: 7040, end: 7103 },
      { begin: 7168, end: 7247 },
      { begin: 7248, end: 7295 },
      { begin: 43136, end: 43231 },
      { begin: 43264, end: 43311 },
      { begin: 43312, end: 43359 },
      { begin: 43520, end: 43615 },
      { begin: 65936, end: 65999 },
      { begin: 66000, end: 66047 },
      { begin: 66208, end: 66271 },
      { begin: 127024, end: 127135 }
    ];
    function getUnicodeRange(unicode) {
      for (var i = 0;i < unicodeRanges.length; i += 1) {
        var range = unicodeRanges[i];
        if (unicode >= range.begin && unicode < range.end) {
          return i;
        }
      }
      return -1;
    }
    function parseOS2Table(data, start) {
      var os22 = {};
      var p = new parse.Parser(data, start);
      os22.version = p.parseUShort();
      os22.xAvgCharWidth = p.parseShort();
      os22.usWeightClass = p.parseUShort();
      os22.usWidthClass = p.parseUShort();
      os22.fsType = p.parseUShort();
      os22.ySubscriptXSize = p.parseShort();
      os22.ySubscriptYSize = p.parseShort();
      os22.ySubscriptXOffset = p.parseShort();
      os22.ySubscriptYOffset = p.parseShort();
      os22.ySuperscriptXSize = p.parseShort();
      os22.ySuperscriptYSize = p.parseShort();
      os22.ySuperscriptXOffset = p.parseShort();
      os22.ySuperscriptYOffset = p.parseShort();
      os22.yStrikeoutSize = p.parseShort();
      os22.yStrikeoutPosition = p.parseShort();
      os22.sFamilyClass = p.parseShort();
      os22.panose = [];
      for (var i = 0;i < 10; i++) {
        os22.panose[i] = p.parseByte();
      }
      os22.ulUnicodeRange1 = p.parseULong();
      os22.ulUnicodeRange2 = p.parseULong();
      os22.ulUnicodeRange3 = p.parseULong();
      os22.ulUnicodeRange4 = p.parseULong();
      os22.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());
      os22.fsSelection = p.parseUShort();
      os22.usFirstCharIndex = p.parseUShort();
      os22.usLastCharIndex = p.parseUShort();
      os22.sTypoAscender = p.parseShort();
      os22.sTypoDescender = p.parseShort();
      os22.sTypoLineGap = p.parseShort();
      os22.usWinAscent = p.parseUShort();
      os22.usWinDescent = p.parseUShort();
      if (os22.version >= 1) {
        os22.ulCodePageRange1 = p.parseULong();
        os22.ulCodePageRange2 = p.parseULong();
      }
      if (os22.version >= 2) {
        os22.sxHeight = p.parseShort();
        os22.sCapHeight = p.parseShort();
        os22.usDefaultChar = p.parseUShort();
        os22.usBreakChar = p.parseUShort();
        os22.usMaxContent = p.parseUShort();
      }
      return os22;
    }
    function makeOS2Table(options) {
      return new table.Table("OS/2", [
        { name: "version", type: "USHORT", value: 3 },
        { name: "xAvgCharWidth", type: "SHORT", value: 0 },
        { name: "usWeightClass", type: "USHORT", value: 0 },
        { name: "usWidthClass", type: "USHORT", value: 0 },
        { name: "fsType", type: "USHORT", value: 0 },
        { name: "ySubscriptXSize", type: "SHORT", value: 650 },
        { name: "ySubscriptYSize", type: "SHORT", value: 699 },
        { name: "ySubscriptXOffset", type: "SHORT", value: 0 },
        { name: "ySubscriptYOffset", type: "SHORT", value: 140 },
        { name: "ySuperscriptXSize", type: "SHORT", value: 650 },
        { name: "ySuperscriptYSize", type: "SHORT", value: 699 },
        { name: "ySuperscriptXOffset", type: "SHORT", value: 0 },
        { name: "ySuperscriptYOffset", type: "SHORT", value: 479 },
        { name: "yStrikeoutSize", type: "SHORT", value: 49 },
        { name: "yStrikeoutPosition", type: "SHORT", value: 258 },
        { name: "sFamilyClass", type: "SHORT", value: 0 },
        { name: "bFamilyType", type: "BYTE", value: 0 },
        { name: "bSerifStyle", type: "BYTE", value: 0 },
        { name: "bWeight", type: "BYTE", value: 0 },
        { name: "bProportion", type: "BYTE", value: 0 },
        { name: "bContrast", type: "BYTE", value: 0 },
        { name: "bStrokeVariation", type: "BYTE", value: 0 },
        { name: "bArmStyle", type: "BYTE", value: 0 },
        { name: "bLetterform", type: "BYTE", value: 0 },
        { name: "bMidline", type: "BYTE", value: 0 },
        { name: "bXHeight", type: "BYTE", value: 0 },
        { name: "ulUnicodeRange1", type: "ULONG", value: 0 },
        { name: "ulUnicodeRange2", type: "ULONG", value: 0 },
        { name: "ulUnicodeRange3", type: "ULONG", value: 0 },
        { name: "ulUnicodeRange4", type: "ULONG", value: 0 },
        { name: "achVendID", type: "CHARARRAY", value: "XXXX" },
        { name: "fsSelection", type: "USHORT", value: 0 },
        { name: "usFirstCharIndex", type: "USHORT", value: 0 },
        { name: "usLastCharIndex", type: "USHORT", value: 0 },
        { name: "sTypoAscender", type: "SHORT", value: 0 },
        { name: "sTypoDescender", type: "SHORT", value: 0 },
        { name: "sTypoLineGap", type: "SHORT", value: 0 },
        { name: "usWinAscent", type: "USHORT", value: 0 },
        { name: "usWinDescent", type: "USHORT", value: 0 },
        { name: "ulCodePageRange1", type: "ULONG", value: 0 },
        { name: "ulCodePageRange2", type: "ULONG", value: 0 },
        { name: "sxHeight", type: "SHORT", value: 0 },
        { name: "sCapHeight", type: "SHORT", value: 0 },
        { name: "usDefaultChar", type: "USHORT", value: 0 },
        { name: "usBreakChar", type: "USHORT", value: 0 },
        { name: "usMaxContext", type: "USHORT", value: 0 }
      ], options);
    }
    var os2 = { parse: parseOS2Table, make: makeOS2Table, unicodeRanges, getUnicodeRange };
    function parsePostTable(data, start) {
      var post2 = {};
      var p = new parse.Parser(data, start);
      post2.version = p.parseVersion();
      post2.italicAngle = p.parseFixed();
      post2.underlinePosition = p.parseShort();
      post2.underlineThickness = p.parseShort();
      post2.isFixedPitch = p.parseULong();
      post2.minMemType42 = p.parseULong();
      post2.maxMemType42 = p.parseULong();
      post2.minMemType1 = p.parseULong();
      post2.maxMemType1 = p.parseULong();
      switch (post2.version) {
        case 1:
          post2.names = standardNames.slice();
          break;
        case 2:
          post2.numberOfGlyphs = p.parseUShort();
          post2.glyphNameIndex = new Array(post2.numberOfGlyphs);
          for (var i = 0;i < post2.numberOfGlyphs; i++) {
            post2.glyphNameIndex[i] = p.parseUShort();
          }
          post2.names = [];
          for (var i$1 = 0;i$1 < post2.numberOfGlyphs; i$1++) {
            if (post2.glyphNameIndex[i$1] >= standardNames.length) {
              var nameLength = p.parseChar();
              post2.names.push(p.parseString(nameLength));
            }
          }
          break;
        case 2.5:
          post2.numberOfGlyphs = p.parseUShort();
          post2.offset = new Array(post2.numberOfGlyphs);
          for (var i$2 = 0;i$2 < post2.numberOfGlyphs; i$2++) {
            post2.offset[i$2] = p.parseChar();
          }
          break;
      }
      return post2;
    }
    function makePostTable() {
      return new table.Table("post", [
        { name: "version", type: "FIXED", value: 196608 },
        { name: "italicAngle", type: "FIXED", value: 0 },
        { name: "underlinePosition", type: "FWORD", value: 0 },
        { name: "underlineThickness", type: "FWORD", value: 0 },
        { name: "isFixedPitch", type: "ULONG", value: 0 },
        { name: "minMemType42", type: "ULONG", value: 0 },
        { name: "maxMemType42", type: "ULONG", value: 0 },
        { name: "minMemType1", type: "ULONG", value: 0 },
        { name: "maxMemType1", type: "ULONG", value: 0 }
      ]);
    }
    var post = { parse: parsePostTable, make: makePostTable };
    var subtableParsers = new Array(9);
    subtableParsers[1] = function parseLookup1() {
      var start = this.offset + this.relativeOffset;
      var substFormat = this.parseUShort();
      if (substFormat === 1) {
        return {
          substFormat: 1,
          coverage: this.parsePointer(Parser.coverage),
          deltaGlyphId: this.parseUShort()
        };
      } else if (substFormat === 2) {
        return {
          substFormat: 2,
          coverage: this.parsePointer(Parser.coverage),
          substitute: this.parseOffset16List()
        };
      }
      check.assert(false, "0x" + start.toString(16) + ": lookup type 1 format must be 1 or 2.");
    };
    subtableParsers[2] = function parseLookup2() {
      var substFormat = this.parseUShort();
      check.argument(substFormat === 1, "GSUB Multiple Substitution Subtable identifier-format must be 1");
      return {
        substFormat,
        coverage: this.parsePointer(Parser.coverage),
        sequences: this.parseListOfLists()
      };
    };
    subtableParsers[3] = function parseLookup3() {
      var substFormat = this.parseUShort();
      check.argument(substFormat === 1, "GSUB Alternate Substitution Subtable identifier-format must be 1");
      return {
        substFormat,
        coverage: this.parsePointer(Parser.coverage),
        alternateSets: this.parseListOfLists()
      };
    };
    subtableParsers[4] = function parseLookup4() {
      var substFormat = this.parseUShort();
      check.argument(substFormat === 1, "GSUB ligature table identifier-format must be 1");
      return {
        substFormat,
        coverage: this.parsePointer(Parser.coverage),
        ligatureSets: this.parseListOfLists(function() {
          return {
            ligGlyph: this.parseUShort(),
            components: this.parseUShortList(this.parseUShort() - 1)
          };
        })
      };
    };
    var lookupRecordDesc = {
      sequenceIndex: Parser.uShort,
      lookupListIndex: Parser.uShort
    };
    subtableParsers[5] = function parseLookup5() {
      var start = this.offset + this.relativeOffset;
      var substFormat = this.parseUShort();
      if (substFormat === 1) {
        return {
          substFormat,
          coverage: this.parsePointer(Parser.coverage),
          ruleSets: this.parseListOfLists(function() {
            var glyphCount2 = this.parseUShort();
            var substCount2 = this.parseUShort();
            return {
              input: this.parseUShortList(glyphCount2 - 1),
              lookupRecords: this.parseRecordList(substCount2, lookupRecordDesc)
            };
          })
        };
      } else if (substFormat === 2) {
        return {
          substFormat,
          coverage: this.parsePointer(Parser.coverage),
          classDef: this.parsePointer(Parser.classDef),
          classSets: this.parseListOfLists(function() {
            var glyphCount2 = this.parseUShort();
            var substCount2 = this.parseUShort();
            return {
              classes: this.parseUShortList(glyphCount2 - 1),
              lookupRecords: this.parseRecordList(substCount2, lookupRecordDesc)
            };
          })
        };
      } else if (substFormat === 3) {
        var glyphCount = this.parseUShort();
        var substCount = this.parseUShort();
        return {
          substFormat,
          coverages: this.parseList(glyphCount, Parser.pointer(Parser.coverage)),
          lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
        };
      }
      check.assert(false, "0x" + start.toString(16) + ": lookup type 5 format must be 1, 2 or 3.");
    };
    subtableParsers[6] = function parseLookup6() {
      var start = this.offset + this.relativeOffset;
      var substFormat = this.parseUShort();
      if (substFormat === 1) {
        return {
          substFormat: 1,
          coverage: this.parsePointer(Parser.coverage),
          chainRuleSets: this.parseListOfLists(function() {
            return {
              backtrack: this.parseUShortList(),
              input: this.parseUShortList(this.parseShort() - 1),
              lookahead: this.parseUShortList(),
              lookupRecords: this.parseRecordList(lookupRecordDesc)
            };
          })
        };
      } else if (substFormat === 2) {
        return {
          substFormat: 2,
          coverage: this.parsePointer(Parser.coverage),
          backtrackClassDef: this.parsePointer(Parser.classDef),
          inputClassDef: this.parsePointer(Parser.classDef),
          lookaheadClassDef: this.parsePointer(Parser.classDef),
          chainClassSet: this.parseListOfLists(function() {
            return {
              backtrack: this.parseUShortList(),
              input: this.parseUShortList(this.parseShort() - 1),
              lookahead: this.parseUShortList(),
              lookupRecords: this.parseRecordList(lookupRecordDesc)
            };
          })
        };
      } else if (substFormat === 3) {
        return {
          substFormat: 3,
          backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
          inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),
          lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
          lookupRecords: this.parseRecordList(lookupRecordDesc)
        };
      }
      check.assert(false, "0x" + start.toString(16) + ": lookup type 6 format must be 1, 2 or 3.");
    };
    subtableParsers[7] = function parseLookup7() {
      var substFormat = this.parseUShort();
      check.argument(substFormat === 1, "GSUB Extension Substitution subtable identifier-format must be 1");
      var extensionLookupType = this.parseUShort();
      var extensionParser = new Parser(this.data, this.offset + this.parseULong());
      return {
        substFormat: 1,
        lookupType: extensionLookupType,
        extension: subtableParsers[extensionLookupType].call(extensionParser)
      };
    };
    subtableParsers[8] = function parseLookup8() {
      var substFormat = this.parseUShort();
      check.argument(substFormat === 1, "GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1");
      return {
        substFormat,
        coverage: this.parsePointer(Parser.coverage),
        backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
        lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
        substitutes: this.parseUShortList()
      };
    };
    function parseGsubTable(data, start) {
      start = start || 0;
      var p = new Parser(data, start);
      var tableVersion = p.parseVersion(1);
      check.argument(tableVersion === 1 || tableVersion === 1.1, "Unsupported GSUB table version.");
      if (tableVersion === 1) {
        return {
          version: tableVersion,
          scripts: p.parseScriptList(),
          features: p.parseFeatureList(),
          lookups: p.parseLookupList(subtableParsers)
        };
      } else {
        return {
          version: tableVersion,
          scripts: p.parseScriptList(),
          features: p.parseFeatureList(),
          lookups: p.parseLookupList(subtableParsers),
          variations: p.parseFeatureVariationsList()
        };
      }
    }
    var subtableMakers = new Array(9);
    subtableMakers[1] = function makeLookup1(subtable) {
      if (subtable.substFormat === 1) {
        return new table.Table("substitutionTable", [
          { name: "substFormat", type: "USHORT", value: 1 },
          { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) },
          { name: "deltaGlyphID", type: "USHORT", value: subtable.deltaGlyphId }
        ]);
      } else {
        return new table.Table("substitutionTable", [
          { name: "substFormat", type: "USHORT", value: 2 },
          { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) }
        ].concat(table.ushortList("substitute", subtable.substitute)));
      }
      check.fail("Lookup type 1 substFormat must be 1 or 2.");
    };
    subtableMakers[3] = function makeLookup3(subtable) {
      check.assert(subtable.substFormat === 1, "Lookup type 3 substFormat must be 1.");
      return new table.Table("substitutionTable", [
        { name: "substFormat", type: "USHORT", value: 1 },
        { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) }
      ].concat(table.tableList("altSet", subtable.alternateSets, function(alternateSet) {
        return new table.Table("alternateSetTable", table.ushortList("alternate", alternateSet));
      })));
    };
    subtableMakers[4] = function makeLookup4(subtable) {
      check.assert(subtable.substFormat === 1, "Lookup type 4 substFormat must be 1.");
      return new table.Table("substitutionTable", [
        { name: "substFormat", type: "USHORT", value: 1 },
        { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) }
      ].concat(table.tableList("ligSet", subtable.ligatureSets, function(ligatureSet) {
        return new table.Table("ligatureSetTable", table.tableList("ligature", ligatureSet, function(ligature) {
          return new table.Table("ligatureTable", [{ name: "ligGlyph", type: "USHORT", value: ligature.ligGlyph }].concat(table.ushortList("component", ligature.components, ligature.components.length + 1)));
        }));
      })));
    };
    function makeGsubTable(gsub2) {
      return new table.Table("GSUB", [
        { name: "version", type: "ULONG", value: 65536 },
        { name: "scripts", type: "TABLE", value: new table.ScriptList(gsub2.scripts) },
        { name: "features", type: "TABLE", value: new table.FeatureList(gsub2.features) },
        { name: "lookups", type: "TABLE", value: new table.LookupList(gsub2.lookups, subtableMakers) }
      ]);
    }
    var gsub = { parse: parseGsubTable, make: makeGsubTable };
    function parseMetaTable(data, start) {
      var p = new parse.Parser(data, start);
      var tableVersion = p.parseULong();
      check.argument(tableVersion === 1, "Unsupported META table version.");
      p.parseULong();
      p.parseULong();
      var numDataMaps = p.parseULong();
      var tags = {};
      for (var i = 0;i < numDataMaps; i++) {
        var tag = p.parseTag();
        var dataOffset = p.parseULong();
        var dataLength = p.parseULong();
        var text = decode.UTF8(data, start + dataOffset, dataLength);
        tags[tag] = text;
      }
      return tags;
    }
    function makeMetaTable(tags) {
      var numTags = Object.keys(tags).length;
      var stringPool = "";
      var stringPoolOffset = 16 + numTags * 12;
      var result = new table.Table("meta", [
        { name: "version", type: "ULONG", value: 1 },
        { name: "flags", type: "ULONG", value: 0 },
        { name: "offset", type: "ULONG", value: stringPoolOffset },
        { name: "numTags", type: "ULONG", value: numTags }
      ]);
      for (var tag in tags) {
        var pos = stringPool.length;
        stringPool += tags[tag];
        result.fields.push({ name: "tag " + tag, type: "TAG", value: tag });
        result.fields.push({ name: "offset " + tag, type: "ULONG", value: stringPoolOffset + pos });
        result.fields.push({ name: "length " + tag, type: "ULONG", value: tags[tag].length });
      }
      result.fields.push({ name: "stringPool", type: "CHARARRAY", value: stringPool });
      return result;
    }
    var meta = { parse: parseMetaTable, make: makeMetaTable };
    function log2(v) {
      return Math.log(v) / Math.log(2) | 0;
    }
    function computeCheckSum(bytes) {
      while (bytes.length % 4 !== 0) {
        bytes.push(0);
      }
      var sum = 0;
      for (var i = 0;i < bytes.length; i += 4) {
        sum += (bytes[i] << 24) + (bytes[i + 1] << 16) + (bytes[i + 2] << 8) + bytes[i + 3];
      }
      sum %= Math.pow(2, 32);
      return sum;
    }
    function makeTableRecord(tag, checkSum, offset, length) {
      return new table.Record("Table Record", [
        { name: "tag", type: "TAG", value: tag !== undefined ? tag : "" },
        { name: "checkSum", type: "ULONG", value: checkSum !== undefined ? checkSum : 0 },
        { name: "offset", type: "ULONG", value: offset !== undefined ? offset : 0 },
        { name: "length", type: "ULONG", value: length !== undefined ? length : 0 }
      ]);
    }
    function makeSfntTable(tables) {
      var sfnt2 = new table.Table("sfnt", [
        { name: "version", type: "TAG", value: "OTTO" },
        { name: "numTables", type: "USHORT", value: 0 },
        { name: "searchRange", type: "USHORT", value: 0 },
        { name: "entrySelector", type: "USHORT", value: 0 },
        { name: "rangeShift", type: "USHORT", value: 0 }
      ]);
      sfnt2.tables = tables;
      sfnt2.numTables = tables.length;
      var highestPowerOf2 = Math.pow(2, log2(sfnt2.numTables));
      sfnt2.searchRange = 16 * highestPowerOf2;
      sfnt2.entrySelector = log2(highestPowerOf2);
      sfnt2.rangeShift = sfnt2.numTables * 16 - sfnt2.searchRange;
      var recordFields = [];
      var tableFields = [];
      var offset = sfnt2.sizeOf() + makeTableRecord().sizeOf() * sfnt2.numTables;
      while (offset % 4 !== 0) {
        offset += 1;
        tableFields.push({ name: "padding", type: "BYTE", value: 0 });
      }
      for (var i = 0;i < tables.length; i += 1) {
        var t = tables[i];
        check.argument(t.tableName.length === 4, "Table name" + t.tableName + " is invalid.");
        var tableLength = t.sizeOf();
        var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);
        recordFields.push({ name: tableRecord.tag + " Table Record", type: "RECORD", value: tableRecord });
        tableFields.push({ name: t.tableName + " table", type: "RECORD", value: t });
        offset += tableLength;
        check.argument(!isNaN(offset), "Something went wrong calculating the offset.");
        while (offset % 4 !== 0) {
          offset += 1;
          tableFields.push({ name: "padding", type: "BYTE", value: 0 });
        }
      }
      recordFields.sort(function(r1, r2) {
        if (r1.value.tag > r2.value.tag) {
          return 1;
        } else {
          return -1;
        }
      });
      sfnt2.fields = sfnt2.fields.concat(recordFields);
      sfnt2.fields = sfnt2.fields.concat(tableFields);
      return sfnt2;
    }
    function metricsForChar(font, chars, notFoundMetrics) {
      for (var i = 0;i < chars.length; i += 1) {
        var glyphIndex = font.charToGlyphIndex(chars[i]);
        if (glyphIndex > 0) {
          var glyph = font.glyphs.get(glyphIndex);
          return glyph.getMetrics();
        }
      }
      return notFoundMetrics;
    }
    function average(vs) {
      var sum = 0;
      for (var i = 0;i < vs.length; i += 1) {
        sum += vs[i];
      }
      return sum / vs.length;
    }
    function fontToSfntTable(font) {
      var xMins = [];
      var yMins = [];
      var xMaxs = [];
      var yMaxs = [];
      var advanceWidths = [];
      var leftSideBearings = [];
      var rightSideBearings = [];
      var firstCharIndex;
      var lastCharIndex = 0;
      var ulUnicodeRange1 = 0;
      var ulUnicodeRange2 = 0;
      var ulUnicodeRange3 = 0;
      var ulUnicodeRange4 = 0;
      for (var i = 0;i < font.glyphs.length; i += 1) {
        var glyph = font.glyphs.get(i);
        var unicode = glyph.unicode | 0;
        if (isNaN(glyph.advanceWidth)) {
          throw new Error("Glyph " + glyph.name + " (" + i + "): advanceWidth is not a number.");
        }
        if (firstCharIndex > unicode || firstCharIndex === undefined) {
          if (unicode > 0) {
            firstCharIndex = unicode;
          }
        }
        if (lastCharIndex < unicode) {
          lastCharIndex = unicode;
        }
        var position = os2.getUnicodeRange(unicode);
        if (position < 32) {
          ulUnicodeRange1 |= 1 << position;
        } else if (position < 64) {
          ulUnicodeRange2 |= 1 << position - 32;
        } else if (position < 96) {
          ulUnicodeRange3 |= 1 << position - 64;
        } else if (position < 123) {
          ulUnicodeRange4 |= 1 << position - 96;
        } else {
          throw new Error("Unicode ranges bits > 123 are reserved for internal usage");
        }
        if (glyph.name === ".notdef") {
          continue;
        }
        var metrics = glyph.getMetrics();
        xMins.push(metrics.xMin);
        yMins.push(metrics.yMin);
        xMaxs.push(metrics.xMax);
        yMaxs.push(metrics.yMax);
        leftSideBearings.push(metrics.leftSideBearing);
        rightSideBearings.push(metrics.rightSideBearing);
        advanceWidths.push(glyph.advanceWidth);
      }
      var globals = {
        xMin: Math.min.apply(null, xMins),
        yMin: Math.min.apply(null, yMins),
        xMax: Math.max.apply(null, xMaxs),
        yMax: Math.max.apply(null, yMaxs),
        advanceWidthMax: Math.max.apply(null, advanceWidths),
        advanceWidthAvg: average(advanceWidths),
        minLeftSideBearing: Math.min.apply(null, leftSideBearings),
        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),
        minRightSideBearing: Math.min.apply(null, rightSideBearings)
      };
      globals.ascender = font.ascender;
      globals.descender = font.descender;
      var headTable = head.make({
        flags: 3,
        unitsPerEm: font.unitsPerEm,
        xMin: globals.xMin,
        yMin: globals.yMin,
        xMax: globals.xMax,
        yMax: globals.yMax,
        lowestRecPPEM: 3,
        createdTimestamp: font.createdTimestamp
      });
      var hheaTable = hhea.make({
        ascender: globals.ascender,
        descender: globals.descender,
        advanceWidthMax: globals.advanceWidthMax,
        minLeftSideBearing: globals.minLeftSideBearing,
        minRightSideBearing: globals.minRightSideBearing,
        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),
        numberOfHMetrics: font.glyphs.length
      });
      var maxpTable = maxp.make(font.glyphs.length);
      var os2Table = os2.make({
        xAvgCharWidth: Math.round(globals.advanceWidthAvg),
        usWeightClass: font.tables.os2.usWeightClass,
        usWidthClass: font.tables.os2.usWidthClass,
        usFirstCharIndex: firstCharIndex,
        usLastCharIndex: lastCharIndex,
        ulUnicodeRange1,
        ulUnicodeRange2,
        ulUnicodeRange3,
        ulUnicodeRange4,
        fsSelection: font.tables.os2.fsSelection,
        sTypoAscender: globals.ascender,
        sTypoDescender: globals.descender,
        sTypoLineGap: 0,
        usWinAscent: globals.yMax,
        usWinDescent: Math.abs(globals.yMin),
        ulCodePageRange1: 1,
        sxHeight: metricsForChar(font, "xyvw", { yMax: Math.round(globals.ascender / 2) }).yMax,
        sCapHeight: metricsForChar(font, "HIKLEFJMNTZBDPRAGOQSUVWXY", globals).yMax,
        usDefaultChar: font.hasChar(" ") ? 32 : 0,
        usBreakChar: font.hasChar(" ") ? 32 : 0
      });
      var hmtxTable = hmtx.make(font.glyphs);
      var cmapTable = cmap.make(font.glyphs);
      var englishFamilyName = font.getEnglishName("fontFamily");
      var englishStyleName = font.getEnglishName("fontSubfamily");
      var englishFullName = englishFamilyName + " " + englishStyleName;
      var postScriptName = font.getEnglishName("postScriptName");
      if (!postScriptName) {
        postScriptName = englishFamilyName.replace(/\s/g, "") + "-" + englishStyleName;
      }
      var names = {};
      for (var n in font.names) {
        names[n] = font.names[n];
      }
      if (!names.uniqueID) {
        names.uniqueID = { en: font.getEnglishName("manufacturer") + ":" + englishFullName };
      }
      if (!names.postScriptName) {
        names.postScriptName = { en: postScriptName };
      }
      if (!names.preferredFamily) {
        names.preferredFamily = font.names.fontFamily;
      }
      if (!names.preferredSubfamily) {
        names.preferredSubfamily = font.names.fontSubfamily;
      }
      var languageTags = [];
      var nameTable = _name.make(names, languageTags);
      var ltagTable = languageTags.length > 0 ? ltag.make(languageTags) : undefined;
      var postTable = post.make();
      var cffTable = cff.make(font.glyphs, {
        version: font.getEnglishName("version"),
        fullName: englishFullName,
        familyName: englishFamilyName,
        weightName: englishStyleName,
        postScriptName,
        unitsPerEm: font.unitsPerEm,
        fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax]
      });
      var metaTable = font.metas && Object.keys(font.metas).length > 0 ? meta.make(font.metas) : undefined;
      var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];
      if (ltagTable) {
        tables.push(ltagTable);
      }
      if (font.tables.gsub) {
        tables.push(gsub.make(font.tables.gsub));
      }
      if (metaTable) {
        tables.push(metaTable);
      }
      var sfntTable = makeSfntTable(tables);
      var bytes = sfntTable.encode();
      var checkSum = computeCheckSum(bytes);
      var tableFields = sfntTable.fields;
      var checkSumAdjusted = false;
      for (var i$1 = 0;i$1 < tableFields.length; i$1 += 1) {
        if (tableFields[i$1].name === "head table") {
          tableFields[i$1].value.checkSumAdjustment = 2981146554 - checkSum;
          checkSumAdjusted = true;
          break;
        }
      }
      if (!checkSumAdjusted) {
        throw new Error("Could not find head table with checkSum to adjust.");
      }
      return sfntTable;
    }
    var sfnt = { make: makeSfntTable, fontToTable: fontToSfntTable, computeCheckSum };
    function searchTag(arr, tag) {
      var imin = 0;
      var imax = arr.length - 1;
      while (imin <= imax) {
        var imid = imin + imax >>> 1;
        var val = arr[imid].tag;
        if (val === tag) {
          return imid;
        } else if (val < tag) {
          imin = imid + 1;
        } else {
          imax = imid - 1;
        }
      }
      return -imin - 1;
    }
    function binSearch(arr, value) {
      var imin = 0;
      var imax = arr.length - 1;
      while (imin <= imax) {
        var imid = imin + imax >>> 1;
        var val = arr[imid];
        if (val === value) {
          return imid;
        } else if (val < value) {
          imin = imid + 1;
        } else {
          imax = imid - 1;
        }
      }
      return -imin - 1;
    }
    function searchRange(ranges, value) {
      var range;
      var imin = 0;
      var imax = ranges.length - 1;
      while (imin <= imax) {
        var imid = imin + imax >>> 1;
        range = ranges[imid];
        var start = range.start;
        if (start === value) {
          return range;
        } else if (start < value) {
          imin = imid + 1;
        } else {
          imax = imid - 1;
        }
      }
      if (imin > 0) {
        range = ranges[imin - 1];
        if (value > range.end) {
          return 0;
        }
        return range;
      }
    }
    function Layout(font, tableName) {
      this.font = font;
      this.tableName = tableName;
    }
    Layout.prototype = {
      searchTag,
      binSearch,
      getTable: function(create) {
        var layout = this.font.tables[this.tableName];
        if (!layout && create) {
          layout = this.font.tables[this.tableName] = this.createDefaultTable();
        }
        return layout;
      },
      getScriptNames: function() {
        var layout = this.getTable();
        if (!layout) {
          return [];
        }
        return layout.scripts.map(function(script) {
          return script.tag;
        });
      },
      getDefaultScriptName: function() {
        var layout = this.getTable();
        if (!layout) {
          return;
        }
        var hasLatn = false;
        for (var i = 0;i < layout.scripts.length; i++) {
          var name = layout.scripts[i].tag;
          if (name === "DFLT") {
            return name;
          }
          if (name === "latn") {
            hasLatn = true;
          }
        }
        if (hasLatn) {
          return "latn";
        }
      },
      getScriptTable: function(script, create) {
        var layout = this.getTable(create);
        if (layout) {
          script = script || "DFLT";
          var scripts = layout.scripts;
          var pos = searchTag(layout.scripts, script);
          if (pos >= 0) {
            return scripts[pos].script;
          } else if (create) {
            var scr = {
              tag: script,
              script: {
                defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] },
                langSysRecords: []
              }
            };
            scripts.splice(-1 - pos, 0, scr);
            return scr.script;
          }
        }
      },
      getLangSysTable: function(script, language, create) {
        var scriptTable = this.getScriptTable(script, create);
        if (scriptTable) {
          if (!language || language === "dflt" || language === "DFLT") {
            return scriptTable.defaultLangSys;
          }
          var pos = searchTag(scriptTable.langSysRecords, language);
          if (pos >= 0) {
            return scriptTable.langSysRecords[pos].langSys;
          } else if (create) {
            var langSysRecord = {
              tag: language,
              langSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] }
            };
            scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);
            return langSysRecord.langSys;
          }
        }
      },
      getFeatureTable: function(script, language, feature, create) {
        var langSysTable2 = this.getLangSysTable(script, language, create);
        if (langSysTable2) {
          var featureRecord;
          var featIndexes = langSysTable2.featureIndexes;
          var allFeatures = this.font.tables[this.tableName].features;
          for (var i = 0;i < featIndexes.length; i++) {
            featureRecord = allFeatures[featIndexes[i]];
            if (featureRecord.tag === feature) {
              return featureRecord.feature;
            }
          }
          if (create) {
            var index = allFeatures.length;
            check.assert(index === 0 || feature >= allFeatures[index - 1].tag, "Features must be added in alphabetical order.");
            featureRecord = {
              tag: feature,
              feature: { params: 0, lookupListIndexes: [] }
            };
            allFeatures.push(featureRecord);
            featIndexes.push(index);
            return featureRecord.feature;
          }
        }
      },
      getLookupTables: function(script, language, feature, lookupType, create) {
        var featureTable = this.getFeatureTable(script, language, feature, create);
        var tables = [];
        if (featureTable) {
          var lookupTable;
          var lookupListIndexes = featureTable.lookupListIndexes;
          var allLookups = this.font.tables[this.tableName].lookups;
          for (var i = 0;i < lookupListIndexes.length; i++) {
            lookupTable = allLookups[lookupListIndexes[i]];
            if (lookupTable.lookupType === lookupType) {
              tables.push(lookupTable);
            }
          }
          if (tables.length === 0 && create) {
            lookupTable = {
              lookupType,
              lookupFlag: 0,
              subtables: [],
              markFilteringSet: undefined
            };
            var index = allLookups.length;
            allLookups.push(lookupTable);
            lookupListIndexes.push(index);
            return [lookupTable];
          }
        }
        return tables;
      },
      getGlyphClass: function(classDefTable, glyphIndex) {
        switch (classDefTable.format) {
          case 1:
            if (classDefTable.startGlyph <= glyphIndex && glyphIndex < classDefTable.startGlyph + classDefTable.classes.length) {
              return classDefTable.classes[glyphIndex - classDefTable.startGlyph];
            }
            return 0;
          case 2:
            var range = searchRange(classDefTable.ranges, glyphIndex);
            return range ? range.classId : 0;
        }
      },
      getCoverageIndex: function(coverageTable, glyphIndex) {
        switch (coverageTable.format) {
          case 1:
            var index = binSearch(coverageTable.glyphs, glyphIndex);
            return index >= 0 ? index : -1;
          case 2:
            var range = searchRange(coverageTable.ranges, glyphIndex);
            return range ? range.index + glyphIndex - range.start : -1;
        }
      },
      expandCoverage: function(coverageTable) {
        if (coverageTable.format === 1) {
          return coverageTable.glyphs;
        } else {
          var glyphs = [];
          var ranges = coverageTable.ranges;
          for (var i = 0;i < ranges.length; i++) {
            var range = ranges[i];
            var start = range.start;
            var end = range.end;
            for (var j = start;j <= end; j++) {
              glyphs.push(j);
            }
          }
          return glyphs;
        }
      }
    };
    function Position(font) {
      Layout.call(this, font, "gpos");
    }
    Position.prototype = Layout.prototype;
    Position.prototype.getKerningValue = function(kerningLookups, leftIndex, rightIndex) {
      var this$1 = this;
      for (var i = 0;i < kerningLookups.length; i++) {
        var subtables = kerningLookups[i].subtables;
        for (var j = 0;j < subtables.length; j++) {
          var subtable = subtables[j];
          var covIndex = this$1.getCoverageIndex(subtable.coverage, leftIndex);
          if (covIndex < 0) {
            continue;
          }
          switch (subtable.posFormat) {
            case 1:
              var pairSet = subtable.pairSets[covIndex];
              for (var k = 0;k < pairSet.length; k++) {
                var pair = pairSet[k];
                if (pair.secondGlyph === rightIndex) {
                  return pair.value1 && pair.value1.xAdvance || 0;
                }
              }
              break;
            case 2:
              var class1 = this$1.getGlyphClass(subtable.classDef1, leftIndex);
              var class2 = this$1.getGlyphClass(subtable.classDef2, rightIndex);
              var pair$1 = subtable.classRecords[class1][class2];
              return pair$1.value1 && pair$1.value1.xAdvance || 0;
          }
        }
      }
      return 0;
    };
    Position.prototype.getKerningTables = function(script, language) {
      if (this.font.tables.gpos) {
        return this.getLookupTables(script, language, "kern", 2);
      }
    };
    function Substitution(font) {
      Layout.call(this, font, "gsub");
    }
    function arraysEqual(ar1, ar2) {
      var n = ar1.length;
      if (n !== ar2.length) {
        return false;
      }
      for (var i = 0;i < n; i++) {
        if (ar1[i] !== ar2[i]) {
          return false;
        }
      }
      return true;
    }
    function getSubstFormat(lookupTable, format, defaultSubtable) {
      var subtables = lookupTable.subtables;
      for (var i = 0;i < subtables.length; i++) {
        var subtable = subtables[i];
        if (subtable.substFormat === format) {
          return subtable;
        }
      }
      if (defaultSubtable) {
        subtables.push(defaultSubtable);
        return defaultSubtable;
      }
      return;
    }
    Substitution.prototype = Layout.prototype;
    Substitution.prototype.createDefaultTable = function() {
      return {
        version: 1,
        scripts: [{
          tag: "DFLT",
          script: {
            defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] },
            langSysRecords: []
          }
        }],
        features: [],
        lookups: []
      };
    };
    Substitution.prototype.getSingle = function(feature, script, language) {
      var this$1 = this;
      var substitutions = [];
      var lookupTables = this.getLookupTables(script, language, feature, 1);
      for (var idx = 0;idx < lookupTables.length; idx++) {
        var subtables = lookupTables[idx].subtables;
        for (var i = 0;i < subtables.length; i++) {
          var subtable = subtables[i];
          var glyphs = this$1.expandCoverage(subtable.coverage);
          var j = undefined;
          if (subtable.substFormat === 1) {
            var delta = subtable.deltaGlyphId;
            for (j = 0;j < glyphs.length; j++) {
              var glyph = glyphs[j];
              substitutions.push({ sub: glyph, by: glyph + delta });
            }
          } else {
            var substitute = subtable.substitute;
            for (j = 0;j < glyphs.length; j++) {
              substitutions.push({ sub: glyphs[j], by: substitute[j] });
            }
          }
        }
      }
      return substitutions;
    };
    Substitution.prototype.getAlternates = function(feature, script, language) {
      var this$1 = this;
      var alternates = [];
      var lookupTables = this.getLookupTables(script, language, feature, 3);
      for (var idx = 0;idx < lookupTables.length; idx++) {
        var subtables = lookupTables[idx].subtables;
        for (var i = 0;i < subtables.length; i++) {
          var subtable = subtables[i];
          var glyphs = this$1.expandCoverage(subtable.coverage);
          var alternateSets = subtable.alternateSets;
          for (var j = 0;j < glyphs.length; j++) {
            alternates.push({ sub: glyphs[j], by: alternateSets[j] });
          }
        }
      }
      return alternates;
    };
    Substitution.prototype.getLigatures = function(feature, script, language) {
      var this$1 = this;
      var ligatures = [];
      var lookupTables = this.getLookupTables(script, language, feature, 4);
      for (var idx = 0;idx < lookupTables.length; idx++) {
        var subtables = lookupTables[idx].subtables;
        for (var i = 0;i < subtables.length; i++) {
          var subtable = subtables[i];
          var glyphs = this$1.expandCoverage(subtable.coverage);
          var ligatureSets = subtable.ligatureSets;
          for (var j = 0;j < glyphs.length; j++) {
            var startGlyph = glyphs[j];
            var ligSet = ligatureSets[j];
            for (var k = 0;k < ligSet.length; k++) {
              var lig = ligSet[k];
              ligatures.push({
                sub: [startGlyph].concat(lig.components),
                by: lig.ligGlyph
              });
            }
          }
        }
      }
      return ligatures;
    };
    Substitution.prototype.addSingle = function(feature, substitution, script, language) {
      var lookupTable = this.getLookupTables(script, language, feature, 1, true)[0];
      var subtable = getSubstFormat(lookupTable, 2, {
        substFormat: 2,
        coverage: { format: 1, glyphs: [] },
        substitute: []
      });
      check.assert(subtable.coverage.format === 1, "Ligature: unable to modify coverage table format " + subtable.coverage.format);
      var coverageGlyph = substitution.sub;
      var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
      if (pos < 0) {
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.substitute.splice(pos, 0, 0);
      }
      subtable.substitute[pos] = substitution.by;
    };
    Substitution.prototype.addAlternate = function(feature, substitution, script, language) {
      var lookupTable = this.getLookupTables(script, language, feature, 3, true)[0];
      var subtable = getSubstFormat(lookupTable, 1, {
        substFormat: 1,
        coverage: { format: 1, glyphs: [] },
        alternateSets: []
      });
      check.assert(subtable.coverage.format === 1, "Ligature: unable to modify coverage table format " + subtable.coverage.format);
      var coverageGlyph = substitution.sub;
      var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
      if (pos < 0) {
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.alternateSets.splice(pos, 0, 0);
      }
      subtable.alternateSets[pos] = substitution.by;
    };
    Substitution.prototype.addLigature = function(feature, ligature, script, language) {
      var lookupTable = this.getLookupTables(script, language, feature, 4, true)[0];
      var subtable = lookupTable.subtables[0];
      if (!subtable) {
        subtable = {
          substFormat: 1,
          coverage: { format: 1, glyphs: [] },
          ligatureSets: []
        };
        lookupTable.subtables[0] = subtable;
      }
      check.assert(subtable.coverage.format === 1, "Ligature: unable to modify coverage table format " + subtable.coverage.format);
      var coverageGlyph = ligature.sub[0];
      var ligComponents = ligature.sub.slice(1);
      var ligatureTable = {
        ligGlyph: ligature.by,
        components: ligComponents
      };
      var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
      if (pos >= 0) {
        var ligatureSet = subtable.ligatureSets[pos];
        for (var i = 0;i < ligatureSet.length; i++) {
          if (arraysEqual(ligatureSet[i].components, ligComponents)) {
            return;
          }
        }
        ligatureSet.push(ligatureTable);
      } else {
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.ligatureSets.splice(pos, 0, [ligatureTable]);
      }
    };
    Substitution.prototype.getFeature = function(feature, script, language) {
      if (/ss\d\d/.test(feature)) {
        return this.getSingle(feature, script, language);
      }
      switch (feature) {
        case "aalt":
        case "salt":
          return this.getSingle(feature, script, language).concat(this.getAlternates(feature, script, language));
        case "dlig":
        case "liga":
        case "rlig":
          return this.getLigatures(feature, script, language);
      }
      return;
    };
    Substitution.prototype.add = function(feature, sub, script, language) {
      if (/ss\d\d/.test(feature)) {
        return this.addSingle(feature, sub, script, language);
      }
      switch (feature) {
        case "aalt":
        case "salt":
          if (typeof sub.by === "number") {
            return this.addSingle(feature, sub, script, language);
          }
          return this.addAlternate(feature, sub, script, language);
        case "dlig":
        case "liga":
        case "rlig":
          return this.addLigature(feature, sub, script, language);
      }
      return;
    };
    function isBrowser() {
      return typeof window !== "undefined";
    }
    function nodeBufferToArrayBuffer(buffer) {
      var ab = new ArrayBuffer(buffer.length);
      var view = new Uint8Array(ab);
      for (var i = 0;i < buffer.length; ++i) {
        view[i] = buffer[i];
      }
      return ab;
    }
    function arrayBufferToNodeBuffer(ab) {
      var buffer = new Buffer(ab.byteLength);
      var view = new Uint8Array(ab);
      for (var i = 0;i < buffer.length; ++i) {
        buffer[i] = view[i];
      }
      return buffer;
    }
    function checkArgument(expression, message) {
      if (!expression) {
        throw message;
      }
    }
    var instructionTable;
    var exec;
    var execGlyph;
    var execComponent;
    function Hinting(font) {
      this.font = font;
      this._fpgmState = this._prepState = undefined;
      this._errorState = 0;
    }
    function roundOff(v) {
      return v;
    }
    function roundToGrid(v) {
      return Math.sign(v) * Math.round(Math.abs(v));
    }
    function roundToDoubleGrid(v) {
      return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;
    }
    function roundToHalfGrid(v) {
      return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);
    }
    function roundUpToGrid(v) {
      return Math.sign(v) * Math.ceil(Math.abs(v));
    }
    function roundDownToGrid(v) {
      return Math.sign(v) * Math.floor(Math.abs(v));
    }
    var roundSuper = function(v) {
      var period = this.srPeriod;
      var phase = this.srPhase;
      var threshold = this.srThreshold;
      var sign = 1;
      if (v < 0) {
        v = -v;
        sign = -1;
      }
      v += threshold - phase;
      v = Math.trunc(v / period) * period;
      v += phase;
      if (v < 0) {
        return phase * sign;
      }
      return v * sign;
    };
    var xUnitVector = {
      x: 1,
      y: 0,
      axis: "x",
      distance: function(p1, p2, o1, o2) {
        return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);
      },
      interpolate: function(p, rp1, rp2, pv) {
        var do1;
        var do2;
        var doa1;
        var doa2;
        var dm1;
        var dm2;
        var dt;
        if (!pv || pv === this) {
          do1 = p.xo - rp1.xo;
          do2 = p.xo - rp2.xo;
          dm1 = rp1.x - rp1.xo;
          dm2 = rp2.x - rp2.xo;
          doa1 = Math.abs(do1);
          doa2 = Math.abs(do2);
          dt = doa1 + doa2;
          if (dt === 0) {
            p.x = p.xo + (dm1 + dm2) / 2;
            return;
          }
          p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;
          return;
        }
        do1 = pv.distance(p, rp1, true, true);
        do2 = pv.distance(p, rp2, true, true);
        dm1 = pv.distance(rp1, rp1, false, true);
        dm2 = pv.distance(rp2, rp2, false, true);
        doa1 = Math.abs(do1);
        doa2 = Math.abs(do2);
        dt = doa1 + doa2;
        if (dt === 0) {
          xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
          return;
        }
        xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
      },
      normalSlope: Number.NEGATIVE_INFINITY,
      setRelative: function(p, rp, d, pv, org) {
        if (!pv || pv === this) {
          p.x = (org ? rp.xo : rp.x) + d;
          return;
        }
        var rpx = org ? rp.xo : rp.x;
        var rpy = org ? rp.yo : rp.y;
        var rpdx = rpx + d * pv.x;
        var rpdy = rpy + d * pv.y;
        p.x = rpdx + (p.y - rpdy) / pv.normalSlope;
      },
      slope: 0,
      touch: function(p) {
        p.xTouched = true;
      },
      touched: function(p) {
        return p.xTouched;
      },
      untouch: function(p) {
        p.xTouched = false;
      }
    };
    var yUnitVector = {
      x: 0,
      y: 1,
      axis: "y",
      distance: function(p1, p2, o1, o2) {
        return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);
      },
      interpolate: function(p, rp1, rp2, pv) {
        var do1;
        var do2;
        var doa1;
        var doa2;
        var dm1;
        var dm2;
        var dt;
        if (!pv || pv === this) {
          do1 = p.yo - rp1.yo;
          do2 = p.yo - rp2.yo;
          dm1 = rp1.y - rp1.yo;
          dm2 = rp2.y - rp2.yo;
          doa1 = Math.abs(do1);
          doa2 = Math.abs(do2);
          dt = doa1 + doa2;
          if (dt === 0) {
            p.y = p.yo + (dm1 + dm2) / 2;
            return;
          }
          p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;
          return;
        }
        do1 = pv.distance(p, rp1, true, true);
        do2 = pv.distance(p, rp2, true, true);
        dm1 = pv.distance(rp1, rp1, false, true);
        dm2 = pv.distance(rp2, rp2, false, true);
        doa1 = Math.abs(do1);
        doa2 = Math.abs(do2);
        dt = doa1 + doa2;
        if (dt === 0) {
          yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
          return;
        }
        yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
      },
      normalSlope: 0,
      setRelative: function(p, rp, d, pv, org) {
        if (!pv || pv === this) {
          p.y = (org ? rp.yo : rp.y) + d;
          return;
        }
        var rpx = org ? rp.xo : rp.x;
        var rpy = org ? rp.yo : rp.y;
        var rpdx = rpx + d * pv.x;
        var rpdy = rpy + d * pv.y;
        p.y = rpdy + pv.normalSlope * (p.x - rpdx);
      },
      slope: Number.POSITIVE_INFINITY,
      touch: function(p) {
        p.yTouched = true;
      },
      touched: function(p) {
        return p.yTouched;
      },
      untouch: function(p) {
        p.yTouched = false;
      }
    };
    Object.freeze(xUnitVector);
    Object.freeze(yUnitVector);
    function UnitVector(x, y) {
      this.x = x;
      this.y = y;
      this.axis = undefined;
      this.slope = y / x;
      this.normalSlope = -x / y;
      Object.freeze(this);
    }
    UnitVector.prototype.distance = function(p1, p2, o1, o2) {
      return this.x * xUnitVector.distance(p1, p2, o1, o2) + this.y * yUnitVector.distance(p1, p2, o1, o2);
    };
    UnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {
      var dm1;
      var dm2;
      var do1;
      var do2;
      var doa1;
      var doa2;
      var dt;
      do1 = pv.distance(p, rp1, true, true);
      do2 = pv.distance(p, rp2, true, true);
      dm1 = pv.distance(rp1, rp1, false, true);
      dm2 = pv.distance(rp2, rp2, false, true);
      doa1 = Math.abs(do1);
      doa2 = Math.abs(do2);
      dt = doa1 + doa2;
      if (dt === 0) {
        this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
        return;
      }
      this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
    };
    UnitVector.prototype.setRelative = function(p, rp, d, pv, org) {
      pv = pv || this;
      var rpx = org ? rp.xo : rp.x;
      var rpy = org ? rp.yo : rp.y;
      var rpdx = rpx + d * pv.x;
      var rpdy = rpy + d * pv.y;
      var pvns = pv.normalSlope;
      var fvs = this.slope;
      var px = p.x;
      var py = p.y;
      p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);
      p.y = fvs * (p.x - px) + py;
    };
    UnitVector.prototype.touch = function(p) {
      p.xTouched = true;
      p.yTouched = true;
    };
    function getUnitVector(x, y) {
      var d = Math.sqrt(x * x + y * y);
      x /= d;
      y /= d;
      if (x === 1 && y === 0) {
        return xUnitVector;
      } else if (x === 0 && y === 1) {
        return yUnitVector;
      } else {
        return new UnitVector(x, y);
      }
    }
    function HPoint(x, y, lastPointOfContour, onCurve) {
      this.x = this.xo = Math.round(x * 64) / 64;
      this.y = this.yo = Math.round(y * 64) / 64;
      this.lastPointOfContour = lastPointOfContour;
      this.onCurve = onCurve;
      this.prevPointOnContour = undefined;
      this.nextPointOnContour = undefined;
      this.xTouched = false;
      this.yTouched = false;
      Object.preventExtensions(this);
    }
    HPoint.prototype.nextTouched = function(v) {
      var p = this.nextPointOnContour;
      while (!v.touched(p) && p !== this) {
        p = p.nextPointOnContour;
      }
      return p;
    };
    HPoint.prototype.prevTouched = function(v) {
      var p = this.prevPointOnContour;
      while (!v.touched(p) && p !== this) {
        p = p.prevPointOnContour;
      }
      return p;
    };
    var HPZero = Object.freeze(new HPoint(0, 0));
    var defaultState = {
      cvCutIn: 17 / 16,
      deltaBase: 9,
      deltaShift: 0.125,
      loop: 1,
      minDis: 1,
      autoFlip: true
    };
    function State(env, prog) {
      this.env = env;
      this.stack = [];
      this.prog = prog;
      switch (env) {
        case "glyf":
          this.zp0 = this.zp1 = this.zp2 = 1;
          this.rp0 = this.rp1 = this.rp2 = 0;
        case "prep":
          this.fv = this.pv = this.dpv = xUnitVector;
          this.round = roundToGrid;
      }
    }
    Hinting.prototype.exec = function(glyph, ppem) {
      if (typeof ppem !== "number") {
        throw new Error("Point size is not a number!");
      }
      if (this._errorState > 2) {
        return;
      }
      var font = this.font;
      var prepState = this._prepState;
      if (!prepState || prepState.ppem !== ppem) {
        var fpgmState = this._fpgmState;
        if (!fpgmState) {
          State.prototype = defaultState;
          fpgmState = this._fpgmState = new State("fpgm", font.tables.fpgm);
          fpgmState.funcs = [];
          fpgmState.font = font;
          if (exports2.DEBUG) {
            console.log("---EXEC FPGM---");
            fpgmState.step = -1;
          }
          try {
            exec(fpgmState);
          } catch (e) {
            console.log("Hinting error in FPGM:" + e);
            this._errorState = 3;
            return;
          }
        }
        State.prototype = fpgmState;
        prepState = this._prepState = new State("prep", font.tables.prep);
        prepState.ppem = ppem;
        var oCvt = font.tables.cvt;
        if (oCvt) {
          var cvt = prepState.cvt = new Array(oCvt.length);
          var scale = ppem / font.unitsPerEm;
          for (var c = 0;c < oCvt.length; c++) {
            cvt[c] = oCvt[c] * scale;
          }
        } else {
          prepState.cvt = [];
        }
        if (exports2.DEBUG) {
          console.log("---EXEC PREP---");
          prepState.step = -1;
        }
        try {
          exec(prepState);
        } catch (e) {
          if (this._errorState < 2) {
            console.log("Hinting error in PREP:" + e);
          }
          this._errorState = 2;
        }
      }
      if (this._errorState > 1) {
        return;
      }
      try {
        return execGlyph(glyph, prepState);
      } catch (e) {
        if (this._errorState < 1) {
          console.log("Hinting error:" + e);
          console.log("Note: further hinting errors are silenced");
        }
        this._errorState = 1;
        return;
      }
    };
    execGlyph = function(glyph, prepState) {
      var xScale = prepState.ppem / prepState.font.unitsPerEm;
      var yScale = xScale;
      var components = glyph.components;
      var contours;
      var gZone;
      var state;
      State.prototype = prepState;
      if (!components) {
        state = new State("glyf", glyph.instructions);
        if (exports2.DEBUG) {
          console.log("---EXEC GLYPH---");
          state.step = -1;
        }
        execComponent(glyph, state, xScale, yScale);
        gZone = state.gZone;
      } else {
        var font = prepState.font;
        gZone = [];
        contours = [];
        for (var i = 0;i < components.length; i++) {
          var c = components[i];
          var cg = font.glyphs.get(c.glyphIndex);
          state = new State("glyf", cg.instructions);
          if (exports2.DEBUG) {
            console.log("---EXEC COMP " + i + "---");
            state.step = -1;
          }
          execComponent(cg, state, xScale, yScale);
          var dx = Math.round(c.dx * xScale);
          var dy = Math.round(c.dy * yScale);
          var gz = state.gZone;
          var cc = state.contours;
          for (var pi = 0;pi < gz.length; pi++) {
            var p = gz[pi];
            p.xTouched = p.yTouched = false;
            p.xo = p.x = p.x + dx;
            p.yo = p.y = p.y + dy;
          }
          var gLen = gZone.length;
          gZone.push.apply(gZone, gz);
          for (var j = 0;j < cc.length; j++) {
            contours.push(cc[j] + gLen);
          }
        }
        if (glyph.instructions && !state.inhibitGridFit) {
          state = new State("glyf", glyph.instructions);
          state.gZone = state.z0 = state.z1 = state.z2 = gZone;
          state.contours = contours;
          gZone.push(new HPoint(0, 0), new HPoint(Math.round(glyph.advanceWidth * xScale), 0));
          if (exports2.DEBUG) {
            console.log("---EXEC COMPOSITE---");
            state.step = -1;
          }
          exec(state);
          gZone.length -= 2;
        }
      }
      return gZone;
    };
    execComponent = function(glyph, state, xScale, yScale) {
      var points = glyph.points || [];
      var pLen = points.length;
      var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];
      var contours = state.contours = [];
      var cp;
      for (var i = 0;i < pLen; i++) {
        cp = points[i];
        gZone[i] = new HPoint(cp.x * xScale, cp.y * yScale, cp.lastPointOfContour, cp.onCurve);
      }
      var sp;
      var np;
      for (var i$1 = 0;i$1 < pLen; i$1++) {
        cp = gZone[i$1];
        if (!sp) {
          sp = cp;
          contours.push(i$1);
        }
        if (cp.lastPointOfContour) {
          cp.nextPointOnContour = sp;
          sp.prevPointOnContour = cp;
          sp = undefined;
        } else {
          np = gZone[i$1 + 1];
          cp.nextPointOnContour = np;
          np.prevPointOnContour = cp;
        }
      }
      if (state.inhibitGridFit) {
        return;
      }
      if (exports2.DEBUG) {
        console.log("PROCESSING GLYPH", state.stack);
        for (var i$2 = 0;i$2 < pLen; i$2++) {
          console.log(i$2, gZone[i$2].x, gZone[i$2].y);
        }
      }
      gZone.push(new HPoint(0, 0), new HPoint(Math.round(glyph.advanceWidth * xScale), 0));
      exec(state);
      gZone.length -= 2;
      if (exports2.DEBUG) {
        console.log("FINISHED GLYPH", state.stack);
        for (var i$3 = 0;i$3 < pLen; i$3++) {
          console.log(i$3, gZone[i$3].x, gZone[i$3].y);
        }
      }
    };
    exec = function(state) {
      var prog = state.prog;
      if (!prog) {
        return;
      }
      var pLen = prog.length;
      var ins;
      for (state.ip = 0;state.ip < pLen; state.ip++) {
        if (exports2.DEBUG) {
          state.step++;
        }
        ins = instructionTable[prog[state.ip]];
        if (!ins) {
          throw new Error("unknown instruction: 0x" + Number(prog[state.ip]).toString(16));
        }
        ins(state);
      }
    };
    function initTZone(state) {
      var tZone = state.tZone = new Array(state.gZone.length);
      for (var i = 0;i < tZone.length; i++) {
        tZone[i] = new HPoint(0, 0);
      }
    }
    function skip(state, handleElse) {
      var prog = state.prog;
      var ip = state.ip;
      var nesting = 1;
      var ins;
      do {
        ins = prog[++ip];
        if (ins === 88) {
          nesting++;
        } else if (ins === 89) {
          nesting--;
        } else if (ins === 64) {
          ip += prog[ip + 1] + 1;
        } else if (ins === 65) {
          ip += 2 * prog[ip + 1] + 1;
        } else if (ins >= 176 && ins <= 183) {
          ip += ins - 176 + 1;
        } else if (ins >= 184 && ins <= 191) {
          ip += (ins - 184 + 1) * 2;
        } else if (handleElse && nesting === 1 && ins === 27) {
          break;
        }
      } while (nesting > 0);
      state.ip = ip;
    }
    function SVTCA(v, state) {
      if (exports2.DEBUG) {
        console.log(state.step, "SVTCA[" + v.axis + "]");
      }
      state.fv = state.pv = state.dpv = v;
    }
    function SPVTCA(v, state) {
      if (exports2.DEBUG) {
        console.log(state.step, "SPVTCA[" + v.axis + "]");
      }
      state.pv = state.dpv = v;
    }
    function SFVTCA(v, state) {
      if (exports2.DEBUG) {
        console.log(state.step, "SFVTCA[" + v.axis + "]");
      }
      state.fv = v;
    }
    function SPVTL(a, state) {
      var stack = state.stack;
      var p2i = stack.pop();
      var p1i = stack.pop();
      var p2 = state.z2[p2i];
      var p1 = state.z1[p1i];
      if (exports2.DEBUG) {
        console.log("SPVTL[" + a + "]", p2i, p1i);
      }
      var dx;
      var dy;
      if (!a) {
        dx = p1.x - p2.x;
        dy = p1.y - p2.y;
      } else {
        dx = p2.y - p1.y;
        dy = p1.x - p2.x;
      }
      state.pv = state.dpv = getUnitVector(dx, dy);
    }
    function SFVTL(a, state) {
      var stack = state.stack;
      var p2i = stack.pop();
      var p1i = stack.pop();
      var p2 = state.z2[p2i];
      var p1 = state.z1[p1i];
      if (exports2.DEBUG) {
        console.log("SFVTL[" + a + "]", p2i, p1i);
      }
      var dx;
      var dy;
      if (!a) {
        dx = p1.x - p2.x;
        dy = p1.y - p2.y;
      } else {
        dx = p2.y - p1.y;
        dy = p1.x - p2.x;
      }
      state.fv = getUnitVector(dx, dy);
    }
    function SPVFS(state) {
      var stack = state.stack;
      var y = stack.pop();
      var x = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "SPVFS[]", y, x);
      }
      state.pv = state.dpv = getUnitVector(x, y);
    }
    function SFVFS(state) {
      var stack = state.stack;
      var y = stack.pop();
      var x = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "SPVFS[]", y, x);
      }
      state.fv = getUnitVector(x, y);
    }
    function GPV(state) {
      var stack = state.stack;
      var pv = state.pv;
      if (exports2.DEBUG) {
        console.log(state.step, "GPV[]");
      }
      stack.push(pv.x * 16384);
      stack.push(pv.y * 16384);
    }
    function GFV(state) {
      var stack = state.stack;
      var fv = state.fv;
      if (exports2.DEBUG) {
        console.log(state.step, "GFV[]");
      }
      stack.push(fv.x * 16384);
      stack.push(fv.y * 16384);
    }
    function SFVTPV(state) {
      state.fv = state.pv;
      if (exports2.DEBUG) {
        console.log(state.step, "SFVTPV[]");
      }
    }
    function ISECT(state) {
      var stack = state.stack;
      var pa0i = stack.pop();
      var pa1i = stack.pop();
      var pb0i = stack.pop();
      var pb1i = stack.pop();
      var pi = stack.pop();
      var z0 = state.z0;
      var z1 = state.z1;
      var pa0 = z0[pa0i];
      var pa1 = z0[pa1i];
      var pb0 = z1[pb0i];
      var pb1 = z1[pb1i];
      var p = state.z2[pi];
      if (exports2.DEBUG) {
        console.log("ISECT[], ", pa0i, pa1i, pb0i, pb1i, pi);
      }
      var x1 = pa0.x;
      var y1 = pa0.y;
      var x2 = pa1.x;
      var y2 = pa1.y;
      var x3 = pb0.x;
      var y3 = pb0.y;
      var x4 = pb1.x;
      var y4 = pb1.y;
      var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
      var f1 = x1 * y2 - y1 * x2;
      var f2 = x3 * y4 - y3 * x4;
      p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;
      p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;
    }
    function SRP0(state) {
      state.rp0 = state.stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "SRP0[]", state.rp0);
      }
    }
    function SRP1(state) {
      state.rp1 = state.stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "SRP1[]", state.rp1);
      }
    }
    function SRP2(state) {
      state.rp2 = state.stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "SRP2[]", state.rp2);
      }
    }
    function SZP0(state) {
      var n = state.stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "SZP0[]", n);
      }
      state.zp0 = n;
      switch (n) {
        case 0:
          if (!state.tZone) {
            initTZone(state);
          }
          state.z0 = state.tZone;
          break;
        case 1:
          state.z0 = state.gZone;
          break;
        default:
          throw new Error("Invalid zone pointer");
      }
    }
    function SZP1(state) {
      var n = state.stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "SZP1[]", n);
      }
      state.zp1 = n;
      switch (n) {
        case 0:
          if (!state.tZone) {
            initTZone(state);
          }
          state.z1 = state.tZone;
          break;
        case 1:
          state.z1 = state.gZone;
          break;
        default:
          throw new Error("Invalid zone pointer");
      }
    }
    function SZP2(state) {
      var n = state.stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "SZP2[]", n);
      }
      state.zp2 = n;
      switch (n) {
        case 0:
          if (!state.tZone) {
            initTZone(state);
          }
          state.z2 = state.tZone;
          break;
        case 1:
          state.z2 = state.gZone;
          break;
        default:
          throw new Error("Invalid zone pointer");
      }
    }
    function SZPS(state) {
      var n = state.stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "SZPS[]", n);
      }
      state.zp0 = state.zp1 = state.zp2 = n;
      switch (n) {
        case 0:
          if (!state.tZone) {
            initTZone(state);
          }
          state.z0 = state.z1 = state.z2 = state.tZone;
          break;
        case 1:
          state.z0 = state.z1 = state.z2 = state.gZone;
          break;
        default:
          throw new Error("Invalid zone pointer");
      }
    }
    function SLOOP(state) {
      state.loop = state.stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "SLOOP[]", state.loop);
      }
    }
    function RTG(state) {
      if (exports2.DEBUG) {
        console.log(state.step, "RTG[]");
      }
      state.round = roundToGrid;
    }
    function RTHG(state) {
      if (exports2.DEBUG) {
        console.log(state.step, "RTHG[]");
      }
      state.round = roundToHalfGrid;
    }
    function SMD(state) {
      var d = state.stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "SMD[]", d);
      }
      state.minDis = d / 64;
    }
    function ELSE(state) {
      if (exports2.DEBUG) {
        console.log(state.step, "ELSE[]");
      }
      skip(state, false);
    }
    function JMPR(state) {
      var o = state.stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "JMPR[]", o);
      }
      state.ip += o - 1;
    }
    function SCVTCI(state) {
      var n = state.stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "SCVTCI[]", n);
      }
      state.cvCutIn = n / 64;
    }
    function DUP(state) {
      var stack = state.stack;
      if (exports2.DEBUG) {
        console.log(state.step, "DUP[]");
      }
      stack.push(stack[stack.length - 1]);
    }
    function POP(state) {
      if (exports2.DEBUG) {
        console.log(state.step, "POP[]");
      }
      state.stack.pop();
    }
    function CLEAR(state) {
      if (exports2.DEBUG) {
        console.log(state.step, "CLEAR[]");
      }
      state.stack.length = 0;
    }
    function SWAP(state) {
      var stack = state.stack;
      var a = stack.pop();
      var b = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "SWAP[]");
      }
      stack.push(a);
      stack.push(b);
    }
    function DEPTH(state) {
      var stack = state.stack;
      if (exports2.DEBUG) {
        console.log(state.step, "DEPTH[]");
      }
      stack.push(stack.length);
    }
    function LOOPCALL(state) {
      var stack = state.stack;
      var fn = stack.pop();
      var c = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "LOOPCALL[]", fn, c);
      }
      var cip = state.ip;
      var cprog = state.prog;
      state.prog = state.funcs[fn];
      for (var i = 0;i < c; i++) {
        exec(state);
        if (exports2.DEBUG) {
          console.log(++state.step, i + 1 < c ? "next loopcall" : "done loopcall", i);
        }
      }
      state.ip = cip;
      state.prog = cprog;
    }
    function CALL(state) {
      var fn = state.stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "CALL[]", fn);
      }
      var cip = state.ip;
      var cprog = state.prog;
      state.prog = state.funcs[fn];
      exec(state);
      state.ip = cip;
      state.prog = cprog;
      if (exports2.DEBUG) {
        console.log(++state.step, "returning from", fn);
      }
    }
    function CINDEX(state) {
      var stack = state.stack;
      var k = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "CINDEX[]", k);
      }
      stack.push(stack[stack.length - k]);
    }
    function MINDEX(state) {
      var stack = state.stack;
      var k = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "MINDEX[]", k);
      }
      stack.push(stack.splice(stack.length - k, 1)[0]);
    }
    function FDEF(state) {
      if (state.env !== "fpgm") {
        throw new Error("FDEF not allowed here");
      }
      var stack = state.stack;
      var prog = state.prog;
      var ip = state.ip;
      var fn = stack.pop();
      var ipBegin = ip;
      if (exports2.DEBUG) {
        console.log(state.step, "FDEF[]", fn);
      }
      while (prog[++ip] !== 45) {
      }
      state.ip = ip;
      state.funcs[fn] = prog.slice(ipBegin + 1, ip);
    }
    function MDAP(round, state) {
      var pi = state.stack.pop();
      var p = state.z0[pi];
      var fv = state.fv;
      var pv = state.pv;
      if (exports2.DEBUG) {
        console.log(state.step, "MDAP[" + round + "]", pi);
      }
      var d = pv.distance(p, HPZero);
      if (round) {
        d = state.round(d);
      }
      fv.setRelative(p, HPZero, d, pv);
      fv.touch(p);
      state.rp0 = state.rp1 = pi;
    }
    function IUP(v, state) {
      var z2 = state.z2;
      var pLen = z2.length - 2;
      var cp;
      var pp;
      var np;
      if (exports2.DEBUG) {
        console.log(state.step, "IUP[" + v.axis + "]");
      }
      for (var i = 0;i < pLen; i++) {
        cp = z2[i];
        if (v.touched(cp)) {
          continue;
        }
        pp = cp.prevTouched(v);
        if (pp === cp) {
          continue;
        }
        np = cp.nextTouched(v);
        if (pp === np) {
          v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);
        }
        v.interpolate(cp, pp, np, v);
      }
    }
    function SHP(a, state) {
      var stack = state.stack;
      var rpi = a ? state.rp1 : state.rp2;
      var rp = (a ? state.z0 : state.z1)[rpi];
      var fv = state.fv;
      var pv = state.pv;
      var loop = state.loop;
      var z2 = state.z2;
      while (loop--) {
        var pi = stack.pop();
        var p = z2[pi];
        var d = pv.distance(rp, rp, false, true);
        fv.setRelative(p, p, d, pv);
        fv.touch(p);
        if (exports2.DEBUG) {
          console.log(state.step, (state.loop > 1 ? "loop " + (state.loop - loop) + ": " : "") + "SHP[" + (a ? "rp1" : "rp2") + "]", pi);
        }
      }
      state.loop = 1;
    }
    function SHC(a, state) {
      var stack = state.stack;
      var rpi = a ? state.rp1 : state.rp2;
      var rp = (a ? state.z0 : state.z1)[rpi];
      var fv = state.fv;
      var pv = state.pv;
      var ci = stack.pop();
      var sp = state.z2[state.contours[ci]];
      var p = sp;
      if (exports2.DEBUG) {
        console.log(state.step, "SHC[" + a + "]", ci);
      }
      var d = pv.distance(rp, rp, false, true);
      do {
        if (p !== rp) {
          fv.setRelative(p, p, d, pv);
        }
        p = p.nextPointOnContour;
      } while (p !== sp);
    }
    function SHZ(a, state) {
      var stack = state.stack;
      var rpi = a ? state.rp1 : state.rp2;
      var rp = (a ? state.z0 : state.z1)[rpi];
      var fv = state.fv;
      var pv = state.pv;
      var e = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "SHZ[" + a + "]", e);
      }
      var z;
      switch (e) {
        case 0:
          z = state.tZone;
          break;
        case 1:
          z = state.gZone;
          break;
        default:
          throw new Error("Invalid zone");
      }
      var p;
      var d = pv.distance(rp, rp, false, true);
      var pLen = z.length - 2;
      for (var i = 0;i < pLen; i++) {
        p = z[i];
        fv.setRelative(p, p, d, pv);
      }
    }
    function SHPIX(state) {
      var stack = state.stack;
      var loop = state.loop;
      var fv = state.fv;
      var d = stack.pop() / 64;
      var z2 = state.z2;
      while (loop--) {
        var pi = stack.pop();
        var p = z2[pi];
        if (exports2.DEBUG) {
          console.log(state.step, (state.loop > 1 ? "loop " + (state.loop - loop) + ": " : "") + "SHPIX[]", pi, d);
        }
        fv.setRelative(p, p, d);
        fv.touch(p);
      }
      state.loop = 1;
    }
    function IP(state) {
      var stack = state.stack;
      var rp1i = state.rp1;
      var rp2i = state.rp2;
      var loop = state.loop;
      var rp1 = state.z0[rp1i];
      var rp2 = state.z1[rp2i];
      var fv = state.fv;
      var pv = state.dpv;
      var z2 = state.z2;
      while (loop--) {
        var pi = stack.pop();
        var p = z2[pi];
        if (exports2.DEBUG) {
          console.log(state.step, (state.loop > 1 ? "loop " + (state.loop - loop) + ": " : "") + "IP[]", pi, rp1i, "<->", rp2i);
        }
        fv.interpolate(p, rp1, rp2, pv);
        fv.touch(p);
      }
      state.loop = 1;
    }
    function MSIRP(a, state) {
      var stack = state.stack;
      var d = stack.pop() / 64;
      var pi = stack.pop();
      var p = state.z1[pi];
      var rp0 = state.z0[state.rp0];
      var fv = state.fv;
      var pv = state.pv;
      fv.setRelative(p, rp0, d, pv);
      fv.touch(p);
      if (exports2.DEBUG) {
        console.log(state.step, "MSIRP[" + a + "]", d, pi);
      }
      state.rp1 = state.rp0;
      state.rp2 = pi;
      if (a) {
        state.rp0 = pi;
      }
    }
    function ALIGNRP(state) {
      var stack = state.stack;
      var rp0i = state.rp0;
      var rp0 = state.z0[rp0i];
      var loop = state.loop;
      var fv = state.fv;
      var pv = state.pv;
      var z1 = state.z1;
      while (loop--) {
        var pi = stack.pop();
        var p = z1[pi];
        if (exports2.DEBUG) {
          console.log(state.step, (state.loop > 1 ? "loop " + (state.loop - loop) + ": " : "") + "ALIGNRP[]", pi);
        }
        fv.setRelative(p, rp0, 0, pv);
        fv.touch(p);
      }
      state.loop = 1;
    }
    function RTDG(state) {
      if (exports2.DEBUG) {
        console.log(state.step, "RTDG[]");
      }
      state.round = roundToDoubleGrid;
    }
    function MIAP(round, state) {
      var stack = state.stack;
      var n = stack.pop();
      var pi = stack.pop();
      var p = state.z0[pi];
      var fv = state.fv;
      var pv = state.pv;
      var cv = state.cvt[n];
      if (exports2.DEBUG) {
        console.log(state.step, "MIAP[" + round + "]", n, "(", cv, ")", pi);
      }
      var d = pv.distance(p, HPZero);
      if (round) {
        if (Math.abs(d - cv) < state.cvCutIn) {
          d = cv;
        }
        d = state.round(d);
      }
      fv.setRelative(p, HPZero, d, pv);
      if (state.zp0 === 0) {
        p.xo = p.x;
        p.yo = p.y;
      }
      fv.touch(p);
      state.rp0 = state.rp1 = pi;
    }
    function NPUSHB(state) {
      var prog = state.prog;
      var ip = state.ip;
      var stack = state.stack;
      var n = prog[++ip];
      if (exports2.DEBUG) {
        console.log(state.step, "NPUSHB[]", n);
      }
      for (var i = 0;i < n; i++) {
        stack.push(prog[++ip]);
      }
      state.ip = ip;
    }
    function NPUSHW(state) {
      var ip = state.ip;
      var prog = state.prog;
      var stack = state.stack;
      var n = prog[++ip];
      if (exports2.DEBUG) {
        console.log(state.step, "NPUSHW[]", n);
      }
      for (var i = 0;i < n; i++) {
        var w = prog[++ip] << 8 | prog[++ip];
        if (w & 32768) {
          w = -((w ^ 65535) + 1);
        }
        stack.push(w);
      }
      state.ip = ip;
    }
    function WS(state) {
      var stack = state.stack;
      var store = state.store;
      if (!store) {
        store = state.store = [];
      }
      var v = stack.pop();
      var l = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "WS", v, l);
      }
      store[l] = v;
    }
    function RS(state) {
      var stack = state.stack;
      var store = state.store;
      var l = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "RS", l);
      }
      var v = store && store[l] || 0;
      stack.push(v);
    }
    function WCVTP(state) {
      var stack = state.stack;
      var v = stack.pop();
      var l = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "WCVTP", v, l);
      }
      state.cvt[l] = v / 64;
    }
    function RCVT(state) {
      var stack = state.stack;
      var cvte = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "RCVT", cvte);
      }
      stack.push(state.cvt[cvte] * 64);
    }
    function GC(a, state) {
      var stack = state.stack;
      var pi = stack.pop();
      var p = state.z2[pi];
      if (exports2.DEBUG) {
        console.log(state.step, "GC[" + a + "]", pi);
      }
      stack.push(state.dpv.distance(p, HPZero, a, false) * 64);
    }
    function MD(a, state) {
      var stack = state.stack;
      var pi2 = stack.pop();
      var pi1 = stack.pop();
      var p2 = state.z1[pi2];
      var p1 = state.z0[pi1];
      var d = state.dpv.distance(p1, p2, a, a);
      if (exports2.DEBUG) {
        console.log(state.step, "MD[" + a + "]", pi2, pi1, "->", d);
      }
      state.stack.push(Math.round(d * 64));
    }
    function MPPEM(state) {
      if (exports2.DEBUG) {
        console.log(state.step, "MPPEM[]");
      }
      state.stack.push(state.ppem);
    }
    function FLIPON(state) {
      if (exports2.DEBUG) {
        console.log(state.step, "FLIPON[]");
      }
      state.autoFlip = true;
    }
    function LT(state) {
      var stack = state.stack;
      var e2 = stack.pop();
      var e1 = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "LT[]", e2, e1);
      }
      stack.push(e1 < e2 ? 1 : 0);
    }
    function LTEQ(state) {
      var stack = state.stack;
      var e2 = stack.pop();
      var e1 = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "LTEQ[]", e2, e1);
      }
      stack.push(e1 <= e2 ? 1 : 0);
    }
    function GT(state) {
      var stack = state.stack;
      var e2 = stack.pop();
      var e1 = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "GT[]", e2, e1);
      }
      stack.push(e1 > e2 ? 1 : 0);
    }
    function GTEQ(state) {
      var stack = state.stack;
      var e2 = stack.pop();
      var e1 = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "GTEQ[]", e2, e1);
      }
      stack.push(e1 >= e2 ? 1 : 0);
    }
    function EQ(state) {
      var stack = state.stack;
      var e2 = stack.pop();
      var e1 = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "EQ[]", e2, e1);
      }
      stack.push(e2 === e1 ? 1 : 0);
    }
    function NEQ(state) {
      var stack = state.stack;
      var e2 = stack.pop();
      var e1 = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "NEQ[]", e2, e1);
      }
      stack.push(e2 !== e1 ? 1 : 0);
    }
    function ODD(state) {
      var stack = state.stack;
      var n = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "ODD[]", n);
      }
      stack.push(Math.trunc(n) % 2 ? 1 : 0);
    }
    function EVEN(state) {
      var stack = state.stack;
      var n = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "EVEN[]", n);
      }
      stack.push(Math.trunc(n) % 2 ? 0 : 1);
    }
    function IF(state) {
      var test = state.stack.pop();
      var ins;
      if (exports2.DEBUG) {
        console.log(state.step, "IF[]", test);
      }
      if (!test) {
        skip(state, true);
        if (exports2.DEBUG) {
          console.log(state.step, ins === 27 ? "ELSE[]" : "EIF[]");
        }
      }
    }
    function EIF(state) {
      if (exports2.DEBUG) {
        console.log(state.step, "EIF[]");
      }
    }
    function AND(state) {
      var stack = state.stack;
      var e2 = stack.pop();
      var e1 = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "AND[]", e2, e1);
      }
      stack.push(e2 && e1 ? 1 : 0);
    }
    function OR(state) {
      var stack = state.stack;
      var e2 = stack.pop();
      var e1 = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "OR[]", e2, e1);
      }
      stack.push(e2 || e1 ? 1 : 0);
    }
    function NOT(state) {
      var stack = state.stack;
      var e = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "NOT[]", e);
      }
      stack.push(e ? 0 : 1);
    }
    function DELTAP123(b, state) {
      var stack = state.stack;
      var n = stack.pop();
      var fv = state.fv;
      var pv = state.pv;
      var ppem = state.ppem;
      var base = state.deltaBase + (b - 1) * 16;
      var ds = state.deltaShift;
      var z0 = state.z0;
      if (exports2.DEBUG) {
        console.log(state.step, "DELTAP[" + b + "]", n, stack);
      }
      for (var i = 0;i < n; i++) {
        var pi = stack.pop();
        var arg = stack.pop();
        var appem = base + ((arg & 240) >> 4);
        if (appem !== ppem) {
          continue;
        }
        var mag = (arg & 15) - 8;
        if (mag >= 0) {
          mag++;
        }
        if (exports2.DEBUG) {
          console.log(state.step, "DELTAPFIX", pi, "by", mag * ds);
        }
        var p = z0[pi];
        fv.setRelative(p, p, mag * ds, pv);
      }
    }
    function SDB(state) {
      var stack = state.stack;
      var n = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "SDB[]", n);
      }
      state.deltaBase = n;
    }
    function SDS(state) {
      var stack = state.stack;
      var n = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "SDS[]", n);
      }
      state.deltaShift = Math.pow(0.5, n);
    }
    function ADD(state) {
      var stack = state.stack;
      var n2 = stack.pop();
      var n1 = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "ADD[]", n2, n1);
      }
      stack.push(n1 + n2);
    }
    function SUB(state) {
      var stack = state.stack;
      var n2 = stack.pop();
      var n1 = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "SUB[]", n2, n1);
      }
      stack.push(n1 - n2);
    }
    function DIV(state) {
      var stack = state.stack;
      var n2 = stack.pop();
      var n1 = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "DIV[]", n2, n1);
      }
      stack.push(n1 * 64 / n2);
    }
    function MUL(state) {
      var stack = state.stack;
      var n2 = stack.pop();
      var n1 = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "MUL[]", n2, n1);
      }
      stack.push(n1 * n2 / 64);
    }
    function ABS(state) {
      var stack = state.stack;
      var n = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "ABS[]", n);
      }
      stack.push(Math.abs(n));
    }
    function NEG(state) {
      var stack = state.stack;
      var n = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "NEG[]", n);
      }
      stack.push(-n);
    }
    function FLOOR(state) {
      var stack = state.stack;
      var n = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "FLOOR[]", n);
      }
      stack.push(Math.floor(n / 64) * 64);
    }
    function CEILING(state) {
      var stack = state.stack;
      var n = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "CEILING[]", n);
      }
      stack.push(Math.ceil(n / 64) * 64);
    }
    function ROUND(dt, state) {
      var stack = state.stack;
      var n = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "ROUND[]");
      }
      stack.push(state.round(n / 64) * 64);
    }
    function WCVTF(state) {
      var stack = state.stack;
      var v = stack.pop();
      var l = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "WCVTF[]", v, l);
      }
      state.cvt[l] = v * state.ppem / state.font.unitsPerEm;
    }
    function DELTAC123(b, state) {
      var stack = state.stack;
      var n = stack.pop();
      var ppem = state.ppem;
      var base = state.deltaBase + (b - 1) * 16;
      var ds = state.deltaShift;
      if (exports2.DEBUG) {
        console.log(state.step, "DELTAC[" + b + "]", n, stack);
      }
      for (var i = 0;i < n; i++) {
        var c = stack.pop();
        var arg = stack.pop();
        var appem = base + ((arg & 240) >> 4);
        if (appem !== ppem) {
          continue;
        }
        var mag = (arg & 15) - 8;
        if (mag >= 0) {
          mag++;
        }
        var delta = mag * ds;
        if (exports2.DEBUG) {
          console.log(state.step, "DELTACFIX", c, "by", delta);
        }
        state.cvt[c] += delta;
      }
    }
    function SROUND(state) {
      var n = state.stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "SROUND[]", n);
      }
      state.round = roundSuper;
      var period;
      switch (n & 192) {
        case 0:
          period = 0.5;
          break;
        case 64:
          period = 1;
          break;
        case 128:
          period = 2;
          break;
        default:
          throw new Error("invalid SROUND value");
      }
      state.srPeriod = period;
      switch (n & 48) {
        case 0:
          state.srPhase = 0;
          break;
        case 16:
          state.srPhase = 0.25 * period;
          break;
        case 32:
          state.srPhase = 0.5 * period;
          break;
        case 48:
          state.srPhase = 0.75 * period;
          break;
        default:
          throw new Error("invalid SROUND value");
      }
      n &= 15;
      if (n === 0) {
        state.srThreshold = 0;
      } else {
        state.srThreshold = (n / 8 - 0.5) * period;
      }
    }
    function S45ROUND(state) {
      var n = state.stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "S45ROUND[]", n);
      }
      state.round = roundSuper;
      var period;
      switch (n & 192) {
        case 0:
          period = Math.sqrt(2) / 2;
          break;
        case 64:
          period = Math.sqrt(2);
          break;
        case 128:
          period = 2 * Math.sqrt(2);
          break;
        default:
          throw new Error("invalid S45ROUND value");
      }
      state.srPeriod = period;
      switch (n & 48) {
        case 0:
          state.srPhase = 0;
          break;
        case 16:
          state.srPhase = 0.25 * period;
          break;
        case 32:
          state.srPhase = 0.5 * period;
          break;
        case 48:
          state.srPhase = 0.75 * period;
          break;
        default:
          throw new Error("invalid S45ROUND value");
      }
      n &= 15;
      if (n === 0) {
        state.srThreshold = 0;
      } else {
        state.srThreshold = (n / 8 - 0.5) * period;
      }
    }
    function ROFF(state) {
      if (exports2.DEBUG) {
        console.log(state.step, "ROFF[]");
      }
      state.round = roundOff;
    }
    function RUTG(state) {
      if (exports2.DEBUG) {
        console.log(state.step, "RUTG[]");
      }
      state.round = roundUpToGrid;
    }
    function RDTG(state) {
      if (exports2.DEBUG) {
        console.log(state.step, "RDTG[]");
      }
      state.round = roundDownToGrid;
    }
    function SCANCTRL(state) {
      var n = state.stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "SCANCTRL[]", n);
      }
    }
    function SDPVTL(a, state) {
      var stack = state.stack;
      var p2i = stack.pop();
      var p1i = stack.pop();
      var p2 = state.z2[p2i];
      var p1 = state.z1[p1i];
      if (exports2.DEBUG) {
        console.log(state.step, "SDPVTL[" + a + "]", p2i, p1i);
      }
      var dx;
      var dy;
      if (!a) {
        dx = p1.x - p2.x;
        dy = p1.y - p2.y;
      } else {
        dx = p2.y - p1.y;
        dy = p1.x - p2.x;
      }
      state.dpv = getUnitVector(dx, dy);
    }
    function GETINFO(state) {
      var stack = state.stack;
      var sel = stack.pop();
      var r = 0;
      if (exports2.DEBUG) {
        console.log(state.step, "GETINFO[]", sel);
      }
      if (sel & 1) {
        r = 35;
      }
      if (sel & 32) {
        r |= 4096;
      }
      stack.push(r);
    }
    function ROLL(state) {
      var stack = state.stack;
      var a = stack.pop();
      var b = stack.pop();
      var c = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "ROLL[]");
      }
      stack.push(b);
      stack.push(a);
      stack.push(c);
    }
    function MAX(state) {
      var stack = state.stack;
      var e2 = stack.pop();
      var e1 = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "MAX[]", e2, e1);
      }
      stack.push(Math.max(e1, e2));
    }
    function MIN(state) {
      var stack = state.stack;
      var e2 = stack.pop();
      var e1 = stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "MIN[]", e2, e1);
      }
      stack.push(Math.min(e1, e2));
    }
    function SCANTYPE(state) {
      var n = state.stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "SCANTYPE[]", n);
      }
    }
    function INSTCTRL(state) {
      var s = state.stack.pop();
      var v = state.stack.pop();
      if (exports2.DEBUG) {
        console.log(state.step, "INSTCTRL[]", s, v);
      }
      switch (s) {
        case 1:
          state.inhibitGridFit = !!v;
          return;
        case 2:
          state.ignoreCvt = !!v;
          return;
        default:
          throw new Error("invalid INSTCTRL[] selector");
      }
    }
    function PUSHB(n, state) {
      var stack = state.stack;
      var prog = state.prog;
      var ip = state.ip;
      if (exports2.DEBUG) {
        console.log(state.step, "PUSHB[" + n + "]");
      }
      for (var i = 0;i < n; i++) {
        stack.push(prog[++ip]);
      }
      state.ip = ip;
    }
    function PUSHW(n, state) {
      var ip = state.ip;
      var prog = state.prog;
      var stack = state.stack;
      if (exports2.DEBUG) {
        console.log(state.ip, "PUSHW[" + n + "]");
      }
      for (var i = 0;i < n; i++) {
        var w = prog[++ip] << 8 | prog[++ip];
        if (w & 32768) {
          w = -((w ^ 65535) + 1);
        }
        stack.push(w);
      }
      state.ip = ip;
    }
    function MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {
      var stack = state.stack;
      var cvte = indirect && stack.pop();
      var pi = stack.pop();
      var rp0i = state.rp0;
      var rp = state.z0[rp0i];
      var p = state.z1[pi];
      var md = state.minDis;
      var fv = state.fv;
      var pv = state.dpv;
      var od;
      var d;
      var sign;
      var cv;
      d = od = pv.distance(p, rp, true, true);
      sign = d >= 0 ? 1 : -1;
      d = Math.abs(d);
      if (indirect) {
        cv = state.cvt[cvte];
        if (ro && Math.abs(d - cv) < state.cvCutIn) {
          d = cv;
        }
      }
      if (keepD && d < md) {
        d = md;
      }
      if (ro) {
        d = state.round(d);
      }
      fv.setRelative(p, rp, sign * d, pv);
      fv.touch(p);
      if (exports2.DEBUG) {
        console.log(state.step, (indirect ? "MIRP[" : "MDRP[") + (setRp0 ? "M" : "m") + (keepD ? ">" : "_") + (ro ? "R" : "_") + (dt === 0 ? "Gr" : dt === 1 ? "Bl" : dt === 2 ? "Wh" : "") + "]", indirect ? cvte + "(" + state.cvt[cvte] + "," + cv + ")" : "", pi, "(d =", od, "->", sign * d, ")");
      }
      state.rp1 = state.rp0;
      state.rp2 = pi;
      if (setRp0) {
        state.rp0 = pi;
      }
    }
    instructionTable = [
      SVTCA.bind(undefined, yUnitVector),
      SVTCA.bind(undefined, xUnitVector),
      SPVTCA.bind(undefined, yUnitVector),
      SPVTCA.bind(undefined, xUnitVector),
      SFVTCA.bind(undefined, yUnitVector),
      SFVTCA.bind(undefined, xUnitVector),
      SPVTL.bind(undefined, 0),
      SPVTL.bind(undefined, 1),
      SFVTL.bind(undefined, 0),
      SFVTL.bind(undefined, 1),
      SPVFS,
      SFVFS,
      GPV,
      GFV,
      SFVTPV,
      ISECT,
      SRP0,
      SRP1,
      SRP2,
      SZP0,
      SZP1,
      SZP2,
      SZPS,
      SLOOP,
      RTG,
      RTHG,
      SMD,
      ELSE,
      JMPR,
      SCVTCI,
      undefined,
      undefined,
      DUP,
      POP,
      CLEAR,
      SWAP,
      DEPTH,
      CINDEX,
      MINDEX,
      undefined,
      undefined,
      undefined,
      LOOPCALL,
      CALL,
      FDEF,
      undefined,
      MDAP.bind(undefined, 0),
      MDAP.bind(undefined, 1),
      IUP.bind(undefined, yUnitVector),
      IUP.bind(undefined, xUnitVector),
      SHP.bind(undefined, 0),
      SHP.bind(undefined, 1),
      SHC.bind(undefined, 0),
      SHC.bind(undefined, 1),
      SHZ.bind(undefined, 0),
      SHZ.bind(undefined, 1),
      SHPIX,
      IP,
      MSIRP.bind(undefined, 0),
      MSIRP.bind(undefined, 1),
      ALIGNRP,
      RTDG,
      MIAP.bind(undefined, 0),
      MIAP.bind(undefined, 1),
      NPUSHB,
      NPUSHW,
      WS,
      RS,
      WCVTP,
      RCVT,
      GC.bind(undefined, 0),
      GC.bind(undefined, 1),
      undefined,
      MD.bind(undefined, 0),
      MD.bind(undefined, 1),
      MPPEM,
      undefined,
      FLIPON,
      undefined,
      undefined,
      LT,
      LTEQ,
      GT,
      GTEQ,
      EQ,
      NEQ,
      ODD,
      EVEN,
      IF,
      EIF,
      AND,
      OR,
      NOT,
      DELTAP123.bind(undefined, 1),
      SDB,
      SDS,
      ADD,
      SUB,
      DIV,
      MUL,
      ABS,
      NEG,
      FLOOR,
      CEILING,
      ROUND.bind(undefined, 0),
      ROUND.bind(undefined, 1),
      ROUND.bind(undefined, 2),
      ROUND.bind(undefined, 3),
      undefined,
      undefined,
      undefined,
      undefined,
      WCVTF,
      DELTAP123.bind(undefined, 2),
      DELTAP123.bind(undefined, 3),
      DELTAC123.bind(undefined, 1),
      DELTAC123.bind(undefined, 2),
      DELTAC123.bind(undefined, 3),
      SROUND,
      S45ROUND,
      undefined,
      undefined,
      ROFF,
      undefined,
      RUTG,
      RDTG,
      POP,
      POP,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      SCANCTRL,
      SDPVTL.bind(undefined, 0),
      SDPVTL.bind(undefined, 1),
      GETINFO,
      undefined,
      ROLL,
      MAX,
      MIN,
      SCANTYPE,
      INSTCTRL,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      PUSHB.bind(undefined, 1),
      PUSHB.bind(undefined, 2),
      PUSHB.bind(undefined, 3),
      PUSHB.bind(undefined, 4),
      PUSHB.bind(undefined, 5),
      PUSHB.bind(undefined, 6),
      PUSHB.bind(undefined, 7),
      PUSHB.bind(undefined, 8),
      PUSHW.bind(undefined, 1),
      PUSHW.bind(undefined, 2),
      PUSHW.bind(undefined, 3),
      PUSHW.bind(undefined, 4),
      PUSHW.bind(undefined, 5),
      PUSHW.bind(undefined, 6),
      PUSHW.bind(undefined, 7),
      PUSHW.bind(undefined, 8),
      MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),
      MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),
      MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),
      MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),
      MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),
      MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),
      MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),
      MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),
      MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),
      MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),
      MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),
      MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),
      MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),
      MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),
      MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),
      MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),
      MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),
      MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),
      MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),
      MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),
      MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),
      MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),
      MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),
      MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),
      MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),
      MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),
      MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),
      MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),
      MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),
      MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),
      MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),
      MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),
      MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),
      MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),
      MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),
      MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),
      MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),
      MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),
      MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),
      MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),
      MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),
      MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),
      MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),
      MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),
      MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),
      MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),
      MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),
      MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),
      MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),
      MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),
      MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),
      MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),
      MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),
      MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),
      MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),
      MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),
      MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),
      MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),
      MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),
      MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),
      MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),
      MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),
      MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),
      MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)
    ];
    function Font(options) {
      options = options || {};
      if (!options.empty) {
        checkArgument(options.familyName, "When creating a new Font object, familyName is required.");
        checkArgument(options.styleName, "When creating a new Font object, styleName is required.");
        checkArgument(options.unitsPerEm, "When creating a new Font object, unitsPerEm is required.");
        checkArgument(options.ascender, "When creating a new Font object, ascender is required.");
        checkArgument(options.descender, "When creating a new Font object, descender is required.");
        checkArgument(options.descender < 0, "Descender should be negative (e.g. -512).");
        this.names = {
          fontFamily: { en: options.familyName || " " },
          fontSubfamily: { en: options.styleName || " " },
          fullName: { en: options.fullName || options.familyName + " " + options.styleName },
          postScriptName: { en: options.postScriptName || options.familyName + options.styleName },
          designer: { en: options.designer || " " },
          designerURL: { en: options.designerURL || " " },
          manufacturer: { en: options.manufacturer || " " },
          manufacturerURL: { en: options.manufacturerURL || " " },
          license: { en: options.license || " " },
          licenseURL: { en: options.licenseURL || " " },
          version: { en: options.version || "Version 0.1" },
          description: { en: options.description || " " },
          copyright: { en: options.copyright || " " },
          trademark: { en: options.trademark || " " }
        };
        this.unitsPerEm = options.unitsPerEm || 1000;
        this.ascender = options.ascender;
        this.descender = options.descender;
        this.createdTimestamp = options.createdTimestamp;
        this.tables = { os2: {
          usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,
          usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,
          fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR
        } };
      }
      this.supported = true;
      this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);
      this.encoding = new DefaultEncoding(this);
      this.position = new Position(this);
      this.substitution = new Substitution(this);
      this.tables = this.tables || {};
      Object.defineProperty(this, "hinting", {
        get: function() {
          if (this._hinting) {
            return this._hinting;
          }
          if (this.outlinesFormat === "truetype") {
            return this._hinting = new Hinting(this);
          }
        }
      });
    }
    Font.prototype.hasChar = function(c) {
      return this.encoding.charToGlyphIndex(c) !== null;
    };
    Font.prototype.charToGlyphIndex = function(s) {
      return this.encoding.charToGlyphIndex(s);
    };
    Font.prototype.charToGlyph = function(c) {
      var glyphIndex = this.charToGlyphIndex(c);
      var glyph = this.glyphs.get(glyphIndex);
      if (!glyph) {
        glyph = this.glyphs.get(0);
      }
      return glyph;
    };
    Font.prototype.stringToGlyphs = function(s, options) {
      var this$1 = this;
      options = options || this.defaultRenderOptions;
      var indexes = [];
      for (var i = 0;i < s.length; i += 1) {
        var c = s[i];
        indexes.push(this$1.charToGlyphIndex(c));
      }
      var length = indexes.length;
      if (options.features) {
        var script = options.script || this.substitution.getDefaultScriptName();
        var manyToOne = [];
        if (options.features.liga) {
          manyToOne = manyToOne.concat(this.substitution.getFeature("liga", script, options.language));
        }
        if (options.features.rlig) {
          manyToOne = manyToOne.concat(this.substitution.getFeature("rlig", script, options.language));
        }
        for (var i$1 = 0;i$1 < length; i$1 += 1) {
          for (var j = 0;j < manyToOne.length; j++) {
            var ligature = manyToOne[j];
            var components = ligature.sub;
            var compCount = components.length;
            var k = 0;
            while (k < compCount && components[k] === indexes[i$1 + k]) {
              k++;
            }
            if (k === compCount) {
              indexes.splice(i$1, compCount, ligature.by);
              length = length - compCount + 1;
            }
          }
        }
      }
      var glyphs = new Array(length);
      var notdef = this.glyphs.get(0);
      for (var i$2 = 0;i$2 < length; i$2 += 1) {
        glyphs[i$2] = this$1.glyphs.get(indexes[i$2]) || notdef;
      }
      return glyphs;
    };
    Font.prototype.nameToGlyphIndex = function(name) {
      return this.glyphNames.nameToGlyphIndex(name);
    };
    Font.prototype.nameToGlyph = function(name) {
      var glyphIndex = this.nameToGlyphIndex(name);
      var glyph = this.glyphs.get(glyphIndex);
      if (!glyph) {
        glyph = this.glyphs.get(0);
      }
      return glyph;
    };
    Font.prototype.glyphIndexToName = function(gid) {
      if (!this.glyphNames.glyphIndexToName) {
        return "";
      }
      return this.glyphNames.glyphIndexToName(gid);
    };
    Font.prototype.getKerningValue = function(leftGlyph, rightGlyph) {
      leftGlyph = leftGlyph.index || leftGlyph;
      rightGlyph = rightGlyph.index || rightGlyph;
      return this.kerningPairs[leftGlyph + "," + rightGlyph] || 0;
    };
    Font.prototype.defaultRenderOptions = {
      kerning: true,
      features: {
        liga: true,
        rlig: true
      }
    };
    Font.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {
      var this$1 = this;
      x = x !== undefined ? x : 0;
      y = y !== undefined ? y : 0;
      fontSize = fontSize !== undefined ? fontSize : 72;
      options = options || this.defaultRenderOptions;
      var fontScale = 1 / this.unitsPerEm * fontSize;
      var glyphs = this.stringToGlyphs(text, options);
      var kerningLookups;
      if (options.kerning) {
        var script = options.script || this.position.getDefaultScriptName();
        kerningLookups = this.position.getKerningTables(script, options.language);
      }
      for (var i = 0;i < glyphs.length; i += 1) {
        var glyph = glyphs[i];
        callback.call(this$1, glyph, x, y, fontSize, options);
        if (glyph.advanceWidth) {
          x += glyph.advanceWidth * fontScale;
        }
        if (options.kerning && i < glyphs.length - 1) {
          var kerningValue = kerningLookups ? this$1.position.getKerningValue(kerningLookups, glyph.index, glyphs[i + 1].index) : this$1.getKerningValue(glyph, glyphs[i + 1]);
          x += kerningValue * fontScale;
        }
        if (options.letterSpacing) {
          x += options.letterSpacing * fontSize;
        } else if (options.tracking) {
          x += options.tracking / 1000 * fontSize;
        }
      }
      return x;
    };
    Font.prototype.getPath = function(text, x, y, fontSize, options) {
      var fullPath = new Path;
      this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
        fullPath.extend(glyphPath);
      });
      return fullPath;
    };
    Font.prototype.getPaths = function(text, x, y, fontSize, options) {
      var glyphPaths = [];
      this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
        glyphPaths.push(glyphPath);
      });
      return glyphPaths;
    };
    Font.prototype.getAdvanceWidth = function(text, fontSize, options) {
      return this.forEachGlyph(text, 0, 0, fontSize, options, function() {
      });
    };
    Font.prototype.draw = function(ctx, text, x, y, fontSize, options) {
      this.getPath(text, x, y, fontSize, options).draw(ctx);
    };
    Font.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {
      this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        glyph.drawPoints(ctx, gX, gY, gFontSize);
      });
    };
    Font.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {
      this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        glyph.drawMetrics(ctx, gX, gY, gFontSize);
      });
    };
    Font.prototype.getEnglishName = function(name) {
      var translations = this.names[name];
      if (translations) {
        return translations.en;
      }
    };
    Font.prototype.validate = function() {
      var warnings = [];
      var _this = this;
      function assert(predicate, message) {
        if (!predicate) {
          warnings.push(message);
        }
      }
      function assertNamePresent(name) {
        var englishName = _this.getEnglishName(name);
        assert(englishName && englishName.trim().length > 0, "No English " + name + " specified.");
      }
      assertNamePresent("fontFamily");
      assertNamePresent("weightName");
      assertNamePresent("manufacturer");
      assertNamePresent("copyright");
      assertNamePresent("version");
      assert(this.unitsPerEm > 0, "No unitsPerEm specified.");
    };
    Font.prototype.toTables = function() {
      return sfnt.fontToTable(this);
    };
    Font.prototype.toBuffer = function() {
      console.warn("Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.");
      return this.toArrayBuffer();
    };
    Font.prototype.toArrayBuffer = function() {
      var sfntTable = this.toTables();
      var bytes = sfntTable.encode();
      var buffer = new ArrayBuffer(bytes.length);
      var intArray = new Uint8Array(buffer);
      for (var i = 0;i < bytes.length; i++) {
        intArray[i] = bytes[i];
      }
      return buffer;
    };
    Font.prototype.download = function(fileName) {
      var familyName = this.getEnglishName("fontFamily");
      var styleName = this.getEnglishName("fontSubfamily");
      fileName = fileName || familyName.replace(/\s/g, "") + "-" + styleName + ".otf";
      var arrayBuffer = this.toArrayBuffer();
      if (isBrowser()) {
        window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
        window.requestFileSystem(window.TEMPORARY, arrayBuffer.byteLength, function(fs2) {
          fs2.root.getFile(fileName, { create: true }, function(fileEntry) {
            fileEntry.createWriter(function(writer) {
              var dataView = new DataView(arrayBuffer);
              var blob = new Blob([dataView], { type: "font/opentype" });
              writer.write(blob);
              writer.addEventListener("writeend", function() {
                location.href = fileEntry.toURL();
              }, false);
            });
          });
        }, function(err) {
          throw new Error(err.name + ": " + err.message);
        });
      } else {
        var fs = (()=>({}));
        var buffer = arrayBufferToNodeBuffer(arrayBuffer);
        fs.writeFileSync(fileName, buffer);
      }
    };
    Font.prototype.fsSelectionValues = {
      ITALIC: 1,
      UNDERSCORE: 2,
      NEGATIVE: 4,
      OUTLINED: 8,
      STRIKEOUT: 16,
      BOLD: 32,
      REGULAR: 64,
      USER_TYPO_METRICS: 128,
      WWS: 256,
      OBLIQUE: 512
    };
    Font.prototype.usWidthClasses = {
      ULTRA_CONDENSED: 1,
      EXTRA_CONDENSED: 2,
      CONDENSED: 3,
      SEMI_CONDENSED: 4,
      MEDIUM: 5,
      SEMI_EXPANDED: 6,
      EXPANDED: 7,
      EXTRA_EXPANDED: 8,
      ULTRA_EXPANDED: 9
    };
    Font.prototype.usWeightClasses = {
      THIN: 100,
      EXTRA_LIGHT: 200,
      LIGHT: 300,
      NORMAL: 400,
      MEDIUM: 500,
      SEMI_BOLD: 600,
      BOLD: 700,
      EXTRA_BOLD: 800,
      BLACK: 900
    };
    function addName(name, names) {
      var nameString = JSON.stringify(name);
      var nameID = 256;
      for (var nameKey in names) {
        var n = parseInt(nameKey);
        if (!n || n < 256) {
          continue;
        }
        if (JSON.stringify(names[nameKey]) === nameString) {
          return n;
        }
        if (nameID <= n) {
          nameID = n + 1;
        }
      }
      names[nameID] = name;
      return nameID;
    }
    function makeFvarAxis(n, axis, names) {
      var nameID = addName(axis.name, names);
      return [
        { name: "tag_" + n, type: "TAG", value: axis.tag },
        { name: "minValue_" + n, type: "FIXED", value: axis.minValue << 16 },
        { name: "defaultValue_" + n, type: "FIXED", value: axis.defaultValue << 16 },
        { name: "maxValue_" + n, type: "FIXED", value: axis.maxValue << 16 },
        { name: "flags_" + n, type: "USHORT", value: 0 },
        { name: "nameID_" + n, type: "USHORT", value: nameID }
      ];
    }
    function parseFvarAxis(data, start, names) {
      var axis = {};
      var p = new parse.Parser(data, start);
      axis.tag = p.parseTag();
      axis.minValue = p.parseFixed();
      axis.defaultValue = p.parseFixed();
      axis.maxValue = p.parseFixed();
      p.skip("uShort", 1);
      axis.name = names[p.parseUShort()] || {};
      return axis;
    }
    function makeFvarInstance(n, inst, axes, names) {
      var nameID = addName(inst.name, names);
      var fields = [
        { name: "nameID_" + n, type: "USHORT", value: nameID },
        { name: "flags_" + n, type: "USHORT", value: 0 }
      ];
      for (var i = 0;i < axes.length; ++i) {
        var axisTag = axes[i].tag;
        fields.push({
          name: "axis_" + n + " " + axisTag,
          type: "FIXED",
          value: inst.coordinates[axisTag] << 16
        });
      }
      return fields;
    }
    function parseFvarInstance(data, start, axes, names) {
      var inst = {};
      var p = new parse.Parser(data, start);
      inst.name = names[p.parseUShort()] || {};
      p.skip("uShort", 1);
      inst.coordinates = {};
      for (var i = 0;i < axes.length; ++i) {
        inst.coordinates[axes[i].tag] = p.parseFixed();
      }
      return inst;
    }
    function makeFvarTable(fvar2, names) {
      var result = new table.Table("fvar", [
        { name: "version", type: "ULONG", value: 65536 },
        { name: "offsetToData", type: "USHORT", value: 0 },
        { name: "countSizePairs", type: "USHORT", value: 2 },
        { name: "axisCount", type: "USHORT", value: fvar2.axes.length },
        { name: "axisSize", type: "USHORT", value: 20 },
        { name: "instanceCount", type: "USHORT", value: fvar2.instances.length },
        { name: "instanceSize", type: "USHORT", value: 4 + fvar2.axes.length * 4 }
      ]);
      result.offsetToData = result.sizeOf();
      for (var i = 0;i < fvar2.axes.length; i++) {
        result.fields = result.fields.concat(makeFvarAxis(i, fvar2.axes[i], names));
      }
      for (var j = 0;j < fvar2.instances.length; j++) {
        result.fields = result.fields.concat(makeFvarInstance(j, fvar2.instances[j], fvar2.axes, names));
      }
      return result;
    }
    function parseFvarTable(data, start, names) {
      var p = new parse.Parser(data, start);
      var tableVersion = p.parseULong();
      check.argument(tableVersion === 65536, "Unsupported fvar table version.");
      var offsetToData = p.parseOffset16();
      p.skip("uShort", 1);
      var axisCount = p.parseUShort();
      var axisSize = p.parseUShort();
      var instanceCount = p.parseUShort();
      var instanceSize = p.parseUShort();
      var axes = [];
      for (var i = 0;i < axisCount; i++) {
        axes.push(parseFvarAxis(data, start + offsetToData + i * axisSize, names));
      }
      var instances = [];
      var instanceStart = start + offsetToData + axisCount * axisSize;
      for (var j = 0;j < instanceCount; j++) {
        instances.push(parseFvarInstance(data, instanceStart + j * instanceSize, axes, names));
      }
      return { axes, instances };
    }
    var fvar = { make: makeFvarTable, parse: parseFvarTable };
    var subtableParsers$1 = new Array(10);
    subtableParsers$1[1] = function parseLookup1() {
      var start = this.offset + this.relativeOffset;
      var posformat = this.parseUShort();
      if (posformat === 1) {
        return {
          posFormat: 1,
          coverage: this.parsePointer(Parser.coverage),
          value: this.parseValueRecord()
        };
      } else if (posformat === 2) {
        return {
          posFormat: 2,
          coverage: this.parsePointer(Parser.coverage),
          values: this.parseValueRecordList()
        };
      }
      check.assert(false, "0x" + start.toString(16) + ": GPOS lookup type 1 format must be 1 or 2.");
    };
    subtableParsers$1[2] = function parseLookup2() {
      var start = this.offset + this.relativeOffset;
      var posFormat = this.parseUShort();
      var coverage = this.parsePointer(Parser.coverage);
      var valueFormat1 = this.parseUShort();
      var valueFormat2 = this.parseUShort();
      if (posFormat === 1) {
        return {
          posFormat,
          coverage,
          valueFormat1,
          valueFormat2,
          pairSets: this.parseList(Parser.pointer(Parser.list(function() {
            return {
              secondGlyph: this.parseUShort(),
              value1: this.parseValueRecord(valueFormat1),
              value2: this.parseValueRecord(valueFormat2)
            };
          })))
        };
      } else if (posFormat === 2) {
        var classDef1 = this.parsePointer(Parser.classDef);
        var classDef2 = this.parsePointer(Parser.classDef);
        var class1Count = this.parseUShort();
        var class2Count = this.parseUShort();
        return {
          posFormat,
          coverage,
          valueFormat1,
          valueFormat2,
          classDef1,
          classDef2,
          class1Count,
          class2Count,
          classRecords: this.parseList(class1Count, Parser.list(class2Count, function() {
            return {
              value1: this.parseValueRecord(valueFormat1),
              value2: this.parseValueRecord(valueFormat2)
            };
          }))
        };
      }
      check.assert(false, "0x" + start.toString(16) + ": GPOS lookup type 2 format must be 1 or 2.");
    };
    subtableParsers$1[3] = function parseLookup3() {
      return { error: "GPOS Lookup 3 not supported" };
    };
    subtableParsers$1[4] = function parseLookup4() {
      return { error: "GPOS Lookup 4 not supported" };
    };
    subtableParsers$1[5] = function parseLookup5() {
      return { error: "GPOS Lookup 5 not supported" };
    };
    subtableParsers$1[6] = function parseLookup6() {
      return { error: "GPOS Lookup 6 not supported" };
    };
    subtableParsers$1[7] = function parseLookup7() {
      return { error: "GPOS Lookup 7 not supported" };
    };
    subtableParsers$1[8] = function parseLookup8() {
      return { error: "GPOS Lookup 8 not supported" };
    };
    subtableParsers$1[9] = function parseLookup9() {
      return { error: "GPOS Lookup 9 not supported" };
    };
    function parseGposTable(data, start) {
      start = start || 0;
      var p = new Parser(data, start);
      var tableVersion = p.parseVersion(1);
      check.argument(tableVersion === 1 || tableVersion === 1.1, "Unsupported GPOS table version " + tableVersion);
      if (tableVersion === 1) {
        return {
          version: tableVersion,
          scripts: p.parseScriptList(),
          features: p.parseFeatureList(),
          lookups: p.parseLookupList(subtableParsers$1)
        };
      } else {
        return {
          version: tableVersion,
          scripts: p.parseScriptList(),
          features: p.parseFeatureList(),
          lookups: p.parseLookupList(subtableParsers$1),
          variations: p.parseFeatureVariationsList()
        };
      }
    }
    var subtableMakers$1 = new Array(10);
    function makeGposTable(gpos2) {
      return new table.Table("GPOS", [
        { name: "version", type: "ULONG", value: 65536 },
        { name: "scripts", type: "TABLE", value: new table.ScriptList(gpos2.scripts) },
        { name: "features", type: "TABLE", value: new table.FeatureList(gpos2.features) },
        { name: "lookups", type: "TABLE", value: new table.LookupList(gpos2.lookups, subtableMakers$1) }
      ]);
    }
    var gpos = { parse: parseGposTable, make: makeGposTable };
    function parseWindowsKernTable(p) {
      var pairs = {};
      p.skip("uShort");
      var subtableVersion = p.parseUShort();
      check.argument(subtableVersion === 0, "Unsupported kern sub-table version.");
      p.skip("uShort", 2);
      var nPairs = p.parseUShort();
      p.skip("uShort", 3);
      for (var i = 0;i < nPairs; i += 1) {
        var leftIndex = p.parseUShort();
        var rightIndex = p.parseUShort();
        var value = p.parseShort();
        pairs[leftIndex + "," + rightIndex] = value;
      }
      return pairs;
    }
    function parseMacKernTable(p) {
      var pairs = {};
      p.skip("uShort");
      var nTables = p.parseULong();
      if (nTables > 1) {
        console.warn("Only the first kern subtable is supported.");
      }
      p.skip("uLong");
      var coverage = p.parseUShort();
      var subtableVersion = coverage & 255;
      p.skip("uShort");
      if (subtableVersion === 0) {
        var nPairs = p.parseUShort();
        p.skip("uShort", 3);
        for (var i = 0;i < nPairs; i += 1) {
          var leftIndex = p.parseUShort();
          var rightIndex = p.parseUShort();
          var value = p.parseShort();
          pairs[leftIndex + "," + rightIndex] = value;
        }
      }
      return pairs;
    }
    function parseKernTable(data, start) {
      var p = new parse.Parser(data, start);
      var tableVersion = p.parseUShort();
      if (tableVersion === 0) {
        return parseWindowsKernTable(p);
      } else if (tableVersion === 1) {
        return parseMacKernTable(p);
      } else {
        throw new Error("Unsupported kern table version (" + tableVersion + ").");
      }
    }
    var kern = { parse: parseKernTable };
    function parseLocaTable(data, start, numGlyphs, shortVersion) {
      var p = new parse.Parser(data, start);
      var parseFn = shortVersion ? p.parseUShort : p.parseULong;
      var glyphOffsets = [];
      for (var i = 0;i < numGlyphs + 1; i += 1) {
        var glyphOffset = parseFn.call(p);
        if (shortVersion) {
          glyphOffset *= 2;
        }
        glyphOffsets.push(glyphOffset);
      }
      return glyphOffsets;
    }
    var loca = { parse: parseLocaTable };
    function loadFromFile(path, callback) {
      var fs = (()=>({}));
      fs.readFile(path, function(err, buffer) {
        if (err) {
          return callback(err.message);
        }
        callback(null, nodeBufferToArrayBuffer(buffer));
      });
    }
    function loadFromUrl(url, callback) {
      var request = new XMLHttpRequest;
      request.open("get", url, true);
      request.responseType = "arraybuffer";
      request.onload = function() {
        if (request.response) {
          return callback(null, request.response);
        } else {
          return callback("Font could not be loaded: " + request.statusText);
        }
      };
      request.onerror = function() {
        callback("Font could not be loaded");
      };
      request.send();
    }
    function parseOpenTypeTableEntries(data, numTables) {
      var tableEntries = [];
      var p = 12;
      for (var i = 0;i < numTables; i += 1) {
        var tag = parse.getTag(data, p);
        var checksum = parse.getULong(data, p + 4);
        var offset = parse.getULong(data, p + 8);
        var length = parse.getULong(data, p + 12);
        tableEntries.push({ tag, checksum, offset, length, compression: false });
        p += 16;
      }
      return tableEntries;
    }
    function parseWOFFTableEntries(data, numTables) {
      var tableEntries = [];
      var p = 44;
      for (var i = 0;i < numTables; i += 1) {
        var tag = parse.getTag(data, p);
        var offset = parse.getULong(data, p + 4);
        var compLength = parse.getULong(data, p + 8);
        var origLength = parse.getULong(data, p + 12);
        var compression = undefined;
        if (compLength < origLength) {
          compression = "WOFF";
        } else {
          compression = false;
        }
        tableEntries.push({
          tag,
          offset,
          compression,
          compressedLength: compLength,
          length: origLength
        });
        p += 20;
      }
      return tableEntries;
    }
    function uncompressTable(data, tableEntry) {
      if (tableEntry.compression === "WOFF") {
        var inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);
        var outBuffer = new Uint8Array(tableEntry.length);
        tinyInflate(inBuffer, outBuffer);
        if (outBuffer.byteLength !== tableEntry.length) {
          throw new Error("Decompression error: " + tableEntry.tag + " decompressed length doesn\'t match recorded length");
        }
        var view = new DataView(outBuffer.buffer, 0);
        return { data: view, offset: 0 };
      } else {
        return { data, offset: tableEntry.offset };
      }
    }
    function parseBuffer(buffer) {
      var indexToLocFormat;
      var ltagTable;
      var font = new Font({ empty: true });
      var data = new DataView(buffer, 0);
      var numTables;
      var tableEntries = [];
      var signature = parse.getTag(data, 0);
      if (signature === String.fromCharCode(0, 1, 0, 0) || signature === "true" || signature === "typ1") {
        font.outlinesFormat = "truetype";
        numTables = parse.getUShort(data, 4);
        tableEntries = parseOpenTypeTableEntries(data, numTables);
      } else if (signature === "OTTO") {
        font.outlinesFormat = "cff";
        numTables = parse.getUShort(data, 4);
        tableEntries = parseOpenTypeTableEntries(data, numTables);
      } else if (signature === "wOFF") {
        var flavor = parse.getTag(data, 4);
        if (flavor === String.fromCharCode(0, 1, 0, 0)) {
          font.outlinesFormat = "truetype";
        } else if (flavor === "OTTO") {
          font.outlinesFormat = "cff";
        } else {
          throw new Error("Unsupported OpenType flavor " + signature);
        }
        numTables = parse.getUShort(data, 12);
        tableEntries = parseWOFFTableEntries(data, numTables);
      } else {
        throw new Error("Unsupported OpenType signature " + signature);
      }
      var cffTableEntry;
      var fvarTableEntry;
      var glyfTableEntry;
      var gposTableEntry;
      var gsubTableEntry;
      var hmtxTableEntry;
      var kernTableEntry;
      var locaTableEntry;
      var nameTableEntry;
      var metaTableEntry;
      var p;
      for (var i = 0;i < numTables; i += 1) {
        var tableEntry = tableEntries[i];
        var table2 = undefined;
        switch (tableEntry.tag) {
          case "cmap":
            table2 = uncompressTable(data, tableEntry);
            font.tables.cmap = cmap.parse(table2.data, table2.offset);
            font.encoding = new CmapEncoding(font.tables.cmap);
            break;
          case "cvt ":
            table2 = uncompressTable(data, tableEntry);
            p = new parse.Parser(table2.data, table2.offset);
            font.tables.cvt = p.parseShortList(tableEntry.length / 2);
            break;
          case "fvar":
            fvarTableEntry = tableEntry;
            break;
          case "fpgm":
            table2 = uncompressTable(data, tableEntry);
            p = new parse.Parser(table2.data, table2.offset);
            font.tables.fpgm = p.parseByteList(tableEntry.length);
            break;
          case "head":
            table2 = uncompressTable(data, tableEntry);
            font.tables.head = head.parse(table2.data, table2.offset);
            font.unitsPerEm = font.tables.head.unitsPerEm;
            indexToLocFormat = font.tables.head.indexToLocFormat;
            break;
          case "hhea":
            table2 = uncompressTable(data, tableEntry);
            font.tables.hhea = hhea.parse(table2.data, table2.offset);
            font.ascender = font.tables.hhea.ascender;
            font.descender = font.tables.hhea.descender;
            font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;
            break;
          case "hmtx":
            hmtxTableEntry = tableEntry;
            break;
          case "ltag":
            table2 = uncompressTable(data, tableEntry);
            ltagTable = ltag.parse(table2.data, table2.offset);
            break;
          case "maxp":
            table2 = uncompressTable(data, tableEntry);
            font.tables.maxp = maxp.parse(table2.data, table2.offset);
            font.numGlyphs = font.tables.maxp.numGlyphs;
            break;
          case "name":
            nameTableEntry = tableEntry;
            break;
          case "OS/2":
            table2 = uncompressTable(data, tableEntry);
            font.tables.os2 = os2.parse(table2.data, table2.offset);
            break;
          case "post":
            table2 = uncompressTable(data, tableEntry);
            font.tables.post = post.parse(table2.data, table2.offset);
            font.glyphNames = new GlyphNames(font.tables.post);
            break;
          case "prep":
            table2 = uncompressTable(data, tableEntry);
            p = new parse.Parser(table2.data, table2.offset);
            font.tables.prep = p.parseByteList(tableEntry.length);
            break;
          case "glyf":
            glyfTableEntry = tableEntry;
            break;
          case "loca":
            locaTableEntry = tableEntry;
            break;
          case "CFF ":
            cffTableEntry = tableEntry;
            break;
          case "kern":
            kernTableEntry = tableEntry;
            break;
          case "GPOS":
            gposTableEntry = tableEntry;
            break;
          case "GSUB":
            gsubTableEntry = tableEntry;
            break;
          case "meta":
            metaTableEntry = tableEntry;
            break;
        }
      }
      var nameTable = uncompressTable(data, nameTableEntry);
      font.tables.name = _name.parse(nameTable.data, nameTable.offset, ltagTable);
      font.names = font.tables.name;
      if (glyfTableEntry && locaTableEntry) {
        var shortVersion = indexToLocFormat === 0;
        var locaTable = uncompressTable(data, locaTableEntry);
        var locaOffsets = loca.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);
        var glyfTable = uncompressTable(data, glyfTableEntry);
        font.glyphs = glyf.parse(glyfTable.data, glyfTable.offset, locaOffsets, font);
      } else if (cffTableEntry) {
        var cffTable = uncompressTable(data, cffTableEntry);
        cff.parse(cffTable.data, cffTable.offset, font);
      } else {
        throw new Error("Font doesn\'t contain TrueType or CFF outlines.");
      }
      var hmtxTable = uncompressTable(data, hmtxTableEntry);
      hmtx.parse(hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs);
      addGlyphNames(font);
      if (kernTableEntry) {
        var kernTable = uncompressTable(data, kernTableEntry);
        font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);
      } else {
        font.kerningPairs = {};
      }
      if (gposTableEntry) {
        var gposTable = uncompressTable(data, gposTableEntry);
        font.tables.gpos = gpos.parse(gposTable.data, gposTable.offset);
      }
      if (gsubTableEntry) {
        var gsubTable = uncompressTable(data, gsubTableEntry);
        font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);
      }
      if (fvarTableEntry) {
        var fvarTable = uncompressTable(data, fvarTableEntry);
        font.tables.fvar = fvar.parse(fvarTable.data, fvarTable.offset, font.names);
      }
      if (metaTableEntry) {
        var metaTable = uncompressTable(data, metaTableEntry);
        font.tables.meta = meta.parse(metaTable.data, metaTable.offset);
        font.metas = font.tables.meta;
      }
      return font;
    }
    function load(url, callback) {
      var isNode$$1 = typeof window === "undefined";
      var loadFn = isNode$$1 ? loadFromFile : loadFromUrl;
      loadFn(url, function(err, arrayBuffer) {
        if (err) {
          return callback(err);
        }
        var font;
        try {
          font = parseBuffer(arrayBuffer);
        } catch (e) {
          return callback(e, null);
        }
        return callback(null, font);
      });
    }
    function loadSync(url) {
      var fs = (()=>({}));
      var buffer = fs.readFileSync(url);
      return parseBuffer(nodeBufferToArrayBuffer(buffer));
    }
    exports2.Font = Font;
    exports2.Glyph = Glyph;
    exports2.Path = Path;
    exports2.BoundingBox = BoundingBox;
    exports2._parse = parse;
    exports2.parse = parseBuffer;
    exports2.load = load;
    exports2.loadSync = loadSync;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS((exports, module) => {
  module.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head;walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS((exports, module) => {
  var Yallist = function(list) {
    var self2 = this;
    if (!(self2 instanceof Yallist)) {
      self2 = new Yallist;
    }
    self2.tail = null;
    self2.head = null;
    self2.length = 0;
    if (list && typeof list.forEach === "function") {
      list.forEach(function(item) {
        self2.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i = 0, l = arguments.length;i < l; i++) {
        self2.push(arguments[i]);
      }
    }
    return self2;
  };
  var insert = function(self2, node, value) {
    var inserted = node === self2.head ? new Node2(value, null, node, self2) : new Node2(value, node, node.next, self2);
    if (inserted.next === null) {
      self2.tail = inserted;
    }
    if (inserted.prev === null) {
      self2.head = inserted;
    }
    self2.length++;
    return inserted;
  };
  var push = function(self2, item) {
    self2.tail = new Node2(item, self2.tail, null, self2);
    if (!self2.head) {
      self2.head = self2.tail;
    }
    self2.length++;
  };
  var unshift = function(self2, item) {
    self2.head = new Node2(item, null, self2.head, self2);
    if (!self2.tail) {
      self2.tail = self2.head;
    }
    self2.length++;
  };
  var Node2 = function(value, prev, next, list) {
    if (!(this instanceof Node2)) {
      return new Node2(value, prev, next, list);
    }
    this.list = list;
    this.value = value;
    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }
    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  };
  module.exports = Yallist;
  Yallist.Node = Node2;
  Yallist.create = Yallist;
  Yallist.prototype.removeNode = function(node) {
    if (node.list !== this) {
      throw new Error("removing node which does not belong to this list");
    }
    var next = node.next;
    var prev = node.prev;
    if (next) {
      next.prev = prev;
    }
    if (prev) {
      prev.next = next;
    }
    if (node === this.head) {
      this.head = next;
    }
    if (node === this.tail) {
      this.tail = prev;
    }
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
  };
  Yallist.prototype.unshiftNode = function(node) {
    if (node === this.head) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) {
      head.prev = node;
    }
    this.head = node;
    if (!this.tail) {
      this.tail = node;
    }
    this.length++;
  };
  Yallist.prototype.pushNode = function(node) {
    if (node === this.tail) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) {
      tail.next = node;
    }
    this.tail = node;
    if (!this.head) {
      this.head = node;
    }
    this.length++;
  };
  Yallist.prototype.push = function() {
    for (var i = 0, l = arguments.length;i < l; i++) {
      push(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.unshift = function() {
    for (var i = 0, l = arguments.length;i < l; i++) {
      unshift(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.pop = function() {
    if (!this.tail) {
      return;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.shift = function() {
    if (!this.head) {
      return;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i = 0;walker !== null; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  };
  Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i = this.length - 1;walker !== null; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  };
  Yallist.prototype.get = function(n) {
    for (var i = 0, walker = this.head;walker !== null && i < n; i++) {
      walker = walker.next;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.getReverse = function(n) {
    for (var i = 0, walker = this.tail;walker !== null && i < n; i++) {
      walker = walker.prev;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist;
    for (var walker = this.head;walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }
    return res;
  };
  Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist;
    for (var walker = this.tail;walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }
    return res;
  };
  Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = 0;walker !== null; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }
    return acc;
  };
  Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = this.length - 1;walker !== null; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }
    return acc;
  };
  Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.head;walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }
    return arr;
  };
  Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.tail;walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }
    return arr;
  };
  Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist;
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = 0, walker = this.head;walker !== null && i < from; i++) {
      walker = walker.next;
    }
    for (;walker !== null && i < to; i++, walker = walker.next) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist;
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = this.length, walker = this.tail;walker !== null && i > to; i--) {
      walker = walker.prev;
    }
    for (;walker !== null && i > from; i--, walker = walker.prev) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    if (start > this.length) {
      start = this.length - 1;
    }
    if (start < 0) {
      start = this.length + start;
    }
    for (var i = 0, walker = this.head;walker !== null && i < start; i++) {
      walker = walker.next;
    }
    var ret = [];
    for (var i = 0;walker && i < deleteCount; i++) {
      ret.push(walker.value);
      walker = this.removeNode(walker);
    }
    if (walker === null) {
      walker = this.tail;
    }
    if (walker !== this.head && walker !== this.tail) {
      walker = walker.prev;
    }
    for (var i = 0;i < nodes.length; i++) {
      walker = insert(this, walker, nodes[i]);
    }
    return ret;
  };
  Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for (var walker = head;walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
  };
  try {
    require_iterator()(Yallist);
  } catch (er) {
  }
});

// node_modules/lru-cache/index.js
var require_lru_cache = __commonJS((exports, module) => {
  var Yallist = require_yallist();
  var MAX = Symbol("max");
  var LENGTH = Symbol("length");
  var LENGTH_CALCULATOR = Symbol("lengthCalculator");
  var ALLOW_STALE = Symbol("allowStale");
  var MAX_AGE = Symbol("maxAge");
  var DISPOSE = Symbol("dispose");
  var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
  var LRU_LIST = Symbol("lruList");
  var CACHE = Symbol("cache");
  var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
  var naiveLength = () => 1;

  class LRUCache {
    constructor(options) {
      if (typeof options === "number")
        options = { max: options };
      if (!options)
        options = {};
      if (options.max && (typeof options.max !== "number" || options.max < 0))
        throw new TypeError("max must be a non-negative number");
      const max = this[MAX] = options.max || Infinity;
      const lc = options.length || naiveLength;
      this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
      this[ALLOW_STALE] = options.stale || false;
      if (options.maxAge && typeof options.maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      this[MAX_AGE] = options.maxAge || 0;
      this[DISPOSE] = options.dispose;
      this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
      this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
      this.reset();
    }
    set max(mL) {
      if (typeof mL !== "number" || mL < 0)
        throw new TypeError("max must be a non-negative number");
      this[MAX] = mL || Infinity;
      trim(this);
    }
    get max() {
      return this[MAX];
    }
    set allowStale(allowStale) {
      this[ALLOW_STALE] = !!allowStale;
    }
    get allowStale() {
      return this[ALLOW_STALE];
    }
    set maxAge(mA) {
      if (typeof mA !== "number")
        throw new TypeError("maxAge must be a non-negative number");
      this[MAX_AGE] = mA;
      trim(this);
    }
    get maxAge() {
      return this[MAX_AGE];
    }
    set lengthCalculator(lC) {
      if (typeof lC !== "function")
        lC = naiveLength;
      if (lC !== this[LENGTH_CALCULATOR]) {
        this[LENGTH_CALCULATOR] = lC;
        this[LENGTH] = 0;
        this[LRU_LIST].forEach((hit) => {
          hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
          this[LENGTH] += hit.length;
        });
      }
      trim(this);
    }
    get lengthCalculator() {
      return this[LENGTH_CALCULATOR];
    }
    get length() {
      return this[LENGTH];
    }
    get itemCount() {
      return this[LRU_LIST].length;
    }
    rforEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].tail;walker !== null; ) {
        const prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    }
    forEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].head;walker !== null; ) {
        const next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    }
    keys() {
      return this[LRU_LIST].toArray().map((k) => k.key);
    }
    values() {
      return this[LRU_LIST].toArray().map((k) => k.value);
    }
    reset() {
      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
      }
      this[CACHE] = new Map;
      this[LRU_LIST] = new Yallist;
      this[LENGTH] = 0;
    }
    dump() {
      return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter((h) => h);
    }
    dumpLru() {
      return this[LRU_LIST];
    }
    set(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      if (maxAge && typeof maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      const now = maxAge ? Date.now() : 0;
      const len = this[LENGTH_CALCULATOR](value, key);
      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          del2(this, this[CACHE].get(key));
          return false;
        }
        const node = this[CACHE].get(key);
        const item = node.value;
        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET])
            this[DISPOSE](key, item.value);
        }
        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }
      const hit = new Entry(key, value, len, now, maxAge);
      if (hit.length > this[MAX]) {
        if (this[DISPOSE])
          this[DISPOSE](key, value);
        return false;
      }
      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true;
    }
    has(key) {
      if (!this[CACHE].has(key))
        return false;
      const hit = this[CACHE].get(key).value;
      return !isStale(this, hit);
    }
    get(key) {
      return get(this, key, true);
    }
    peek(key) {
      return get(this, key, false);
    }
    pop() {
      const node = this[LRU_LIST].tail;
      if (!node)
        return null;
      del2(this, node);
      return node.value;
    }
    del(key) {
      del2(this, this[CACHE].get(key));
    }
    load(arr) {
      this.reset();
      const now = Date.now();
      for (let l = arr.length - 1;l >= 0; l--) {
        const hit = arr[l];
        const expiresAt = hit.e || 0;
        if (expiresAt === 0)
          this.set(hit.k, hit.v);
        else {
          const maxAge = expiresAt - now;
          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    }
    prune() {
      this[CACHE].forEach((value, key) => get(this, key, false));
    }
  }
  var get = (self2, key, doUse) => {
    const node = self2[CACHE].get(key);
    if (node) {
      const hit = node.value;
      if (isStale(self2, hit)) {
        del2(self2, node);
        if (!self2[ALLOW_STALE])
          return;
      } else {
        if (doUse) {
          if (self2[UPDATE_AGE_ON_GET])
            node.value.now = Date.now();
          self2[LRU_LIST].unshiftNode(node);
        }
      }
      return hit.value;
    }
  };
  var isStale = (self2, hit) => {
    if (!hit || !hit.maxAge && !self2[MAX_AGE])
      return false;
    const diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
  };
  var trim = (self2) => {
    if (self2[LENGTH] > self2[MAX]) {
      for (let walker = self2[LRU_LIST].tail;self2[LENGTH] > self2[MAX] && walker !== null; ) {
        const prev = walker.prev;
        del2(self2, walker);
        walker = prev;
      }
    }
  };
  var del2 = (self2, node) => {
    if (node) {
      const hit = node.value;
      if (self2[DISPOSE])
        self2[DISPOSE](hit.key, hit.value);
      self2[LENGTH] -= hit.length;
      self2[CACHE].delete(hit.key);
      self2[LRU_LIST].removeNode(node);
    }
  };

  class Entry {
    constructor(key, value, length, now, maxAge) {
      this.key = key;
      this.value = value;
      this.length = length;
      this.now = now;
      this.maxAge = maxAge || 0;
    }
  }
  var forEachStep = (self2, fn, node, thisp) => {
    let hit = node.value;
    if (isStale(self2, hit)) {
      del2(self2, node);
      if (!self2[ALLOW_STALE])
        hit = undefined;
    }
    if (hit)
      fn.call(thisp, hit.value, hit.key, self2);
  };
  module.exports = LRUCache;
});

// node_modules/npezza93-font-ligatures/dist/merge.js
var require_merge = __commonJS((exports) => {
  var mergeTrees = function(trees) {
    const result = {
      individual: {},
      range: []
    };
    for (const tree of trees) {
      mergeSubtree(result, tree);
    }
    return result;
  };
  var mergeSubtree = function(mainTree, mergeTree) {
    for (const [glyphId, value] of Object.entries(mergeTree.individual)) {
      if (mainTree.individual[glyphId]) {
        mergeTreeEntry(mainTree.individual[glyphId], value);
      } else {
        let matched = false;
        for (const [index, { range, entry }] of mainTree.range.entries()) {
          const overlap = getIndividualOverlap(Number(glyphId), range);
          if (overlap.both === null) {
            continue;
          }
          matched = true;
          mainTree.individual[glyphId] = value;
          mergeTreeEntry(mainTree.individual[glyphId], cloneEntry(entry));
          mainTree.range.splice(index, 1);
          for (const glyph of overlap.second) {
            if (Array.isArray(glyph)) {
              mainTree.range.push({
                range: glyph,
                entry: cloneEntry(entry)
              });
            } else {
              mainTree.individual[glyph] = cloneEntry(entry);
            }
          }
        }
        if (!matched) {
          mainTree.individual[glyphId] = value;
        }
      }
    }
    for (const { range, entry } of mergeTree.range) {
      let remainingRanges = [range];
      for (let index = 0;index < mainTree.range.length; index++) {
        const { range: range2, entry: resultEntry } = mainTree.range[index];
        for (const [remainingIndex, remainingRange] of remainingRanges.entries()) {
          if (Array.isArray(remainingRange)) {
            const overlap = getRangeOverlap(remainingRange, range2);
            if (overlap.both === null) {
              continue;
            }
            mainTree.range.splice(index, 1);
            index--;
            const entryToMerge = cloneEntry(resultEntry);
            if (Array.isArray(overlap.both)) {
              mainTree.range.push({
                range: overlap.both,
                entry: entryToMerge
              });
            } else {
              mainTree.individual[overlap.both] = entryToMerge;
            }
            mergeTreeEntry(entryToMerge, cloneEntry(entry));
            for (const second of overlap.second) {
              if (Array.isArray(second)) {
                mainTree.range.push({
                  range: second,
                  entry: cloneEntry(resultEntry)
                });
              } else {
                mainTree.individual[second] = cloneEntry(resultEntry);
              }
            }
            remainingRanges = overlap.first;
          } else {
            const overlap = getIndividualOverlap(remainingRange, range2);
            if (overlap.both === null) {
              continue;
            }
            mainTree.individual[remainingRange] = cloneEntry(entry);
            mergeTreeEntry(mainTree.individual[remainingRange], cloneEntry(resultEntry));
            mainTree.range.splice(index, 1);
            index--;
            for (const glyph of overlap.second) {
              if (Array.isArray(glyph)) {
                mainTree.range.push({
                  range: glyph,
                  entry: cloneEntry(resultEntry)
                });
              } else {
                mainTree.individual[glyph] = cloneEntry(resultEntry);
              }
            }
            remainingRanges.splice(remainingIndex, 1, ...overlap.first);
            break;
          }
        }
      }
      for (const glyphId of Object.keys(mainTree.individual)) {
        for (const [remainingIndex, remainingRange] of remainingRanges.entries()) {
          if (Array.isArray(remainingRange)) {
            const overlap = getIndividualOverlap(Number(glyphId), remainingRange);
            if (overlap.both === null) {
              continue;
            }
            mergeTreeEntry(mainTree.individual[glyphId], cloneEntry(entry));
            remainingRanges.splice(remainingIndex, 1, ...overlap.second);
            break;
          } else {
            if (Number(glyphId) === remainingRange) {
              mergeTreeEntry(mainTree.individual[glyphId], cloneEntry(entry));
              break;
            }
          }
        }
      }
      for (const remainingRange of remainingRanges) {
        if (Array.isArray(remainingRange)) {
          mainTree.range.push({
            range: remainingRange,
            entry: cloneEntry(entry)
          });
        } else {
          mainTree.individual[remainingRange] = cloneEntry(entry);
        }
      }
    }
  };
  var mergeTreeEntry = function(mainTree, mergeTree) {
    if (mergeTree.lookup && (!mainTree.lookup || mainTree.lookup.index > mergeTree.lookup.index || mainTree.lookup.index === mergeTree.lookup.index && mainTree.lookup.subIndex > mergeTree.lookup.subIndex)) {
      mainTree.lookup = mergeTree.lookup;
    }
    if (mergeTree.forward) {
      if (!mainTree.forward) {
        mainTree.forward = mergeTree.forward;
      } else {
        mergeSubtree(mainTree.forward, mergeTree.forward);
      }
    }
    if (mergeTree.reverse) {
      if (!mainTree.reverse) {
        mainTree.reverse = mergeTree.reverse;
      } else {
        mergeSubtree(mainTree.reverse, mergeTree.reverse);
      }
    }
  };
  var getRangeOverlap = function(first, second) {
    const result = {
      first: [],
      second: [],
      both: null
    };
    if (first[0] < second[1] && second[0] < first[1]) {
      const start = Math.max(first[0], second[0]);
      const end = Math.min(first[1], second[1]);
      result.both = rangeOrIndividual(start, end);
    }
    if (first[0] < second[0]) {
      const start = first[0];
      const end = Math.min(second[0], first[1]);
      result.first.push(rangeOrIndividual(start, end));
    } else if (second[0] < first[0]) {
      const start = second[0];
      const end = Math.min(second[1], first[0]);
      result.second.push(rangeOrIndividual(start, end));
    }
    if (first[1] > second[1]) {
      const start = Math.max(first[0], second[1]);
      const end = first[1];
      result.first.push(rangeOrIndividual(start, end));
    } else if (second[1] > first[1]) {
      const start = Math.max(first[1], second[0]);
      const end = second[1];
      result.second.push(rangeOrIndividual(start, end));
    }
    return result;
  };
  var getIndividualOverlap = function(first, second) {
    if (first < second[0] || first > second[1]) {
      return {
        first: [first],
        second: [second],
        both: null
      };
    }
    const result = {
      first: [],
      second: [],
      both: first
    };
    if (second[0] < first) {
      result.second.push(rangeOrIndividual(second[0], first));
    }
    if (second[1] > first) {
      result.second.push(rangeOrIndividual(first + 1, second[1]));
    }
    return result;
  };
  var rangeOrIndividual = function(start, end) {
    if (end - start === 1) {
      return start;
    } else {
      return [start, end];
    }
  };
  var cloneEntry = function(entry) {
    const result = {};
    if (entry.forward) {
      result.forward = cloneTree(entry.forward);
    }
    if (entry.reverse) {
      result.reverse = cloneTree(entry.reverse);
    }
    if (entry.lookup) {
      result.lookup = {
        contextRange: entry.lookup.contextRange.slice(),
        index: entry.lookup.index,
        length: entry.lookup.length,
        subIndex: entry.lookup.subIndex,
        substitutions: entry.lookup.substitutions.slice()
      };
    }
    return result;
  };
  var cloneTree = function(tree) {
    const individual = {};
    for (const [glyphId, entry] of Object.entries(tree.individual)) {
      individual[glyphId] = cloneEntry(entry);
    }
    return {
      individual,
      range: tree.range.map(({ range, entry }) => ({
        range: range.slice(),
        entry: cloneEntry(entry)
      }))
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = mergeTrees;
});

// node_modules/npezza93-font-ligatures/dist/walk.js
var require_walk = __commonJS((exports) => {
  var walkTree = function(tree, sequence, startIndex, index) {
    const glyphId = sequence[index];
    let subtree = tree[glyphId];
    if (!subtree) {
      return;
    }
    let lookup = subtree.lookup;
    if (subtree.reverse) {
      const reverseLookup = walkReverse(subtree.reverse, sequence, startIndex);
      if (!lookup && reverseLookup || reverseLookup && lookup && (lookup.index > reverseLookup.index || lookup.index === reverseLookup.index && lookup.subIndex > reverseLookup.subIndex)) {
        lookup = reverseLookup;
      }
    }
    if (++index >= sequence.length || !subtree.forward) {
      return lookup;
    }
    const forwardLookup = walkTree(subtree.forward, sequence, startIndex, index);
    if (!lookup && forwardLookup || forwardLookup && lookup && (lookup.index > forwardLookup.index || lookup.index === forwardLookup.index && lookup.subIndex > forwardLookup.subIndex)) {
      lookup = forwardLookup;
    }
    return lookup;
  };
  var walkReverse = function(tree, sequence, index) {
    let subtree = tree[sequence[--index]];
    let lookup = subtree && subtree.lookup;
    while (subtree) {
      if (!lookup && subtree.lookup || subtree.lookup && lookup && lookup.index > subtree.lookup.index) {
        lookup = subtree.lookup;
      }
      if (--index < 0 || !subtree.reverse) {
        break;
      }
      subtree = subtree.reverse[sequence[index]];
    }
    return lookup;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = walkTree;
});

// node_modules/npezza93-font-ligatures/dist/mergeRange.js
var require_mergeRange = __commonJS((exports) => {
  var mergeRange = function(ranges, newRangeStart, newRangeEnd) {
    let inRange = false;
    for (let i = 0;i < ranges.length; i++) {
      const range = ranges[i];
      if (!inRange) {
        if (newRangeEnd <= range[0]) {
          ranges.splice(i, 0, [newRangeStart, newRangeEnd]);
          return ranges;
        } else if (newRangeEnd <= range[1]) {
          range[0] = Math.min(newRangeStart, range[0]);
          return ranges;
        } else if (newRangeStart < range[1]) {
          range[0] = Math.min(newRangeStart, range[0]);
          inRange = true;
        } else {
          continue;
        }
      } else {
        if (newRangeEnd <= range[0]) {
          ranges[i - 1][1] = newRangeEnd;
          return ranges;
        } else if (newRangeEnd <= range[1]) {
          ranges[i - 1][1] = Math.max(newRangeEnd, range[1]);
          ranges.splice(i, 1);
          inRange = false;
          return ranges;
        } else {
          ranges.splice(i, 1);
          i--;
        }
      }
    }
    if (inRange) {
      ranges[ranges.length - 1][1] = newRangeEnd;
    } else {
      ranges.push([newRangeStart, newRangeEnd]);
    }
    return ranges;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = mergeRange;
});

// node_modules/npezza93-font-ligatures/dist/processors/coverage.js
var require_coverage = __commonJS((exports) => {
  var getCoverageGlyphIndex = function(table, glyphId) {
    switch (table.format) {
      case 1:
        const index = table.glyphs.indexOf(glyphId);
        return index !== -1 ? index : null;
      case 2:
        const range = table.ranges.find((range2) => range2.start <= glyphId && range2.end >= glyphId);
        return range ? range.index : null;
    }
  };
  var listGlyphsByIndex = function(table) {
    switch (table.format) {
      case 1:
        return table.glyphs.map((glyphId, index) => ({ glyphId, index }));
      case 2:
        let results = [];
        for (const [index, range] of table.ranges.entries()) {
          if (range.end === range.start) {
            results.push({ glyphId: range.start, index });
          } else {
            results.push({ glyphId: [range.start, range.end + 1], index });
          }
        }
        return results;
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = getCoverageGlyphIndex;
  exports.listGlyphsByIndex = listGlyphsByIndex;
});

// node_modules/npezza93-font-ligatures/dist/processors/substitution.js
var require_substitution = __commonJS((exports) => {
  var getRangeSubstitutionGlyphs = function(table, glyphId) {
    let replacementStart = glyphId[0];
    let currentReplacement = getIndividualSubstitutionGlyph(table, replacementStart);
    let search = glyphId[0] + 1;
    const result = new Map;
    while (search < glyphId[1]) {
      const sub = getIndividualSubstitutionGlyph(table, search);
      if (sub !== currentReplacement) {
        if (search - replacementStart <= 1) {
          result.set(replacementStart, currentReplacement);
        } else {
          result.set([replacementStart, search], currentReplacement);
        }
      }
      search++;
    }
    if (search - replacementStart <= 1) {
      result.set(replacementStart, currentReplacement);
    } else {
      result.set([replacementStart, search], currentReplacement);
    }
    return result;
  };
  var getIndividualSubstitutionGlyph = function(table, glyphId) {
    const coverageIndex = coverage_1.default(table.coverage, glyphId);
    if (coverageIndex === null) {
      return null;
    }
    switch (table.substFormat) {
      case 1:
        return (glyphId + table.deltaGlyphId) % 2 ** 16;
      case 2:
        return table.substitute[coverageIndex] != null ? table.substitute[coverageIndex] : null;
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var coverage_1 = require_coverage();
  exports.getRangeSubstitutionGlyphs = getRangeSubstitutionGlyphs;
  exports.getIndividualSubstitutionGlyph = getIndividualSubstitutionGlyph;
});

// node_modules/npezza93-font-ligatures/dist/processors/helper.js
var require_helper = __commonJS((exports) => {
  var processInputPosition = function(glyphs, position, currentEntries, lookupRecords, lookups) {
    const nextEntries = [];
    for (const currentEntry of currentEntries) {
      currentEntry.entry.forward = {
        individual: {},
        range: []
      };
      for (const glyph of glyphs) {
        nextEntries.push(...getInputTree(currentEntry.entry.forward, lookupRecords, lookups, position, glyph).map(({ entry, substitution }) => ({
          entry,
          substitutions: [...currentEntry.substitutions, substitution]
        })));
      }
    }
    return nextEntries;
  };
  var processLookaheadPosition = function(glyphs, currentEntries) {
    const nextEntries = [];
    for (const currentEntry of currentEntries) {
      for (const glyph of glyphs) {
        const entry = {};
        if (!currentEntry.entry.forward) {
          currentEntry.entry.forward = {
            individual: {},
            range: []
          };
        }
        nextEntries.push({
          entry,
          substitutions: currentEntry.substitutions
        });
        if (Array.isArray(glyph)) {
          currentEntry.entry.forward.range.push({
            entry,
            range: glyph
          });
        } else {
          currentEntry.entry.forward.individual[glyph] = entry;
        }
      }
    }
    return nextEntries;
  };
  var processBacktrackPosition = function(glyphs, currentEntries) {
    const nextEntries = [];
    for (const currentEntry of currentEntries) {
      for (const glyph of glyphs) {
        const entry = {};
        if (!currentEntry.entry.reverse) {
          currentEntry.entry.reverse = {
            individual: {},
            range: []
          };
        }
        nextEntries.push({
          entry,
          substitutions: currentEntry.substitutions
        });
        if (Array.isArray(glyph)) {
          currentEntry.entry.reverse.range.push({
            entry,
            range: glyph
          });
        } else {
          currentEntry.entry.reverse.individual[glyph] = entry;
        }
      }
    }
    return nextEntries;
  };
  var getInputTree = function(tree, substitutions, lookups, inputIndex, glyphId) {
    const result = [];
    if (!Array.isArray(glyphId)) {
      tree.individual[glyphId] = {};
      result.push({
        entry: tree.individual[glyphId],
        substitution: getSubstitutionAtPosition(substitutions, lookups, inputIndex, glyphId)
      });
    } else {
      const subs = getSubstitutionAtPositionRange(substitutions, lookups, inputIndex, glyphId);
      for (const [range, substitution] of subs) {
        const entry = {};
        if (Array.isArray(range)) {
          tree.range.push({ range, entry });
        } else {
          tree.individual[range] = {};
        }
        result.push({ entry, substitution });
      }
    }
    return result;
  };
  var getSubstitutionAtPositionRange = function(substitutions, lookups, index, range) {
    for (const substitution of substitutions.filter((s) => s.sequenceIndex === index)) {
      for (const substitutionTable of lookups[substitution.lookupListIndex].subtables) {
        const sub = substitution_1.getRangeSubstitutionGlyphs(substitutionTable, range);
        if (!Array.from(sub.values()).every((val) => val !== null)) {
          return sub;
        }
      }
    }
    return new Map([[range, null]]);
  };
  var getSubstitutionAtPosition = function(substitutions, lookups, index, glyphId) {
    for (const substitution of substitutions.filter((s) => s.sequenceIndex === index)) {
      for (const substitutionTable of lookups[substitution.lookupListIndex].subtables) {
        const sub = substitution_1.getIndividualSubstitutionGlyph(substitutionTable, glyphId);
        if (sub !== null) {
          return sub;
        }
      }
    }
    return null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var substitution_1 = require_substitution();
  exports.processInputPosition = processInputPosition;
  exports.processLookaheadPosition = processLookaheadPosition;
  exports.processBacktrackPosition = processBacktrackPosition;
  exports.getInputTree = getInputTree;
});

// node_modules/npezza93-font-ligatures/dist/processors/6-1.js
var require_6_1 = __commonJS((exports) => {
  var buildTree = function(table, lookups, tableIndex) {
    const result = {
      individual: {},
      range: []
    };
    const firstGlyphs = coverage_1.listGlyphsByIndex(table.coverage);
    for (const { glyphId, index } of firstGlyphs) {
      const chainRuleSet = table.chainRuleSets[index];
      if (!chainRuleSet) {
        continue;
      }
      for (const [subIndex, subTable] of chainRuleSet.entries()) {
        let currentEntries = helper_1.getInputTree(result, subTable.lookupRecords, lookups, 0, glyphId).map(({ entry, substitution }) => ({ entry, substitutions: [substitution] }));
        for (const [index2, glyph] of subTable.input.entries()) {
          currentEntries = helper_1.processInputPosition([glyph], index2 + 1, currentEntries, subTable.lookupRecords, lookups);
        }
        for (const glyph of subTable.lookahead) {
          currentEntries = helper_1.processLookaheadPosition([glyph], currentEntries);
        }
        for (const glyph of subTable.backtrack) {
          currentEntries = helper_1.processBacktrackPosition([glyph], currentEntries);
        }
        for (const { entry, substitutions } of currentEntries) {
          entry.lookup = {
            substitutions,
            length: subTable.input.length + 1,
            index: tableIndex,
            subIndex,
            contextRange: [
              -1 * subTable.backtrack.length,
              1 + subTable.input.length + subTable.lookahead.length
            ]
          };
        }
      }
    }
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var coverage_1 = require_coverage();
  var helper_1 = require_helper();
  exports.default = buildTree;
});

// node_modules/npezza93-font-ligatures/dist/processors/classDef.js
var require_classDef = __commonJS((exports) => {
  var getGlyphClass = function(table, glyphId) {
    switch (table.format) {
      case 2:
        if (Array.isArray(glyphId)) {
          return getRangeGlyphClass(table, glyphId);
        } else {
          return new Map([[
            glyphId,
            getIndividualGlyphClass(table, glyphId)
          ]]);
        }
      default:
        return new Map([[glyphId, null]]);
    }
  };
  var getRangeGlyphClass = function(table, glyphId) {
    let classStart = glyphId[0];
    let currentClass = getIndividualGlyphClass(table, classStart);
    let search = glyphId[0] + 1;
    const result = new Map;
    while (search < glyphId[1]) {
      const clazz = getIndividualGlyphClass(table, search);
      if (clazz !== currentClass) {
        if (search - classStart <= 1) {
          result.set(classStart, currentClass);
        } else {
          result.set([classStart, search], currentClass);
        }
      }
      search++;
    }
    if (search - classStart <= 1) {
      result.set(classStart, currentClass);
    } else {
      result.set([classStart, search], currentClass);
    }
    return result;
  };
  var getIndividualGlyphClass = function(table, glyphId) {
    for (const range of table.ranges) {
      if (range.start <= glyphId && range.end >= glyphId) {
        return range.classId;
      }
    }
    return null;
  };
  var listClassGlyphs = function(table, index) {
    switch (table.format) {
      case 2:
        const results = [];
        for (const range of table.ranges) {
          if (range.classId !== index) {
            continue;
          }
          if (range.end === range.start) {
            results.push(range.start);
          } else {
            results.push([range.start, range.end + 1]);
          }
        }
        return results;
      default:
        return [];
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = getGlyphClass;
  exports.listClassGlyphs = listClassGlyphs;
});

// node_modules/npezza93-font-ligatures/dist/processors/6-2.js
var require_6_2 = __commonJS((exports) => {
  var buildTree = function(table, lookups, tableIndex) {
    const results = [];
    const firstGlyphs = coverage_1.listGlyphsByIndex(table.coverage);
    for (const { glyphId } of firstGlyphs) {
      const firstInputClass = classDef_1.default(table.inputClassDef, glyphId);
      for (const [glyphId2, inputClass] of firstInputClass.entries()) {
        if (inputClass === null) {
          continue;
        }
        const classSet = table.chainClassSet[inputClass];
        if (!classSet) {
          continue;
        }
        for (const [subIndex, subTable] of classSet.entries()) {
          const result = {
            individual: {},
            range: []
          };
          let currentEntries = helper_1.getInputTree(result, subTable.lookupRecords, lookups, 0, glyphId2).map(({ entry, substitution }) => ({ entry, substitutions: [substitution] }));
          for (const [index, classNum] of subTable.input.entries()) {
            currentEntries = helper_1.processInputPosition(classDef_1.listClassGlyphs(table.inputClassDef, classNum), index + 1, currentEntries, subTable.lookupRecords, lookups);
          }
          for (const classNum of subTable.lookahead) {
            currentEntries = helper_1.processLookaheadPosition(classDef_1.listClassGlyphs(table.lookaheadClassDef, classNum), currentEntries);
          }
          for (const classNum of subTable.backtrack) {
            currentEntries = helper_1.processBacktrackPosition(classDef_1.listClassGlyphs(table.backtrackClassDef, classNum), currentEntries);
          }
          for (const { entry, substitutions } of currentEntries) {
            entry.lookup = {
              substitutions,
              index: tableIndex,
              subIndex,
              length: subTable.input.length + 1,
              contextRange: [
                -1 * subTable.backtrack.length,
                1 + subTable.input.length + subTable.lookahead.length
              ]
            };
          }
          results.push(result);
        }
      }
    }
    return merge_1.default(results);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var merge_1 = require_merge();
  var coverage_1 = require_coverage();
  var classDef_1 = require_classDef();
  var helper_1 = require_helper();
  exports.default = buildTree;
});

// node_modules/npezza93-font-ligatures/dist/processors/6-3.js
var require_6_3 = __commonJS((exports) => {
  var buildTree = function(table, lookups, tableIndex) {
    const result = {
      individual: {},
      range: []
    };
    const firstGlyphs = coverage_1.listGlyphsByIndex(table.inputCoverage[0]);
    for (const { glyphId } of firstGlyphs) {
      let currentEntries = helper_1.getInputTree(result, table.lookupRecords, lookups, 0, glyphId).map(({ entry, substitution }) => ({ entry, substitutions: [substitution] }));
      for (const [index, coverage] of table.inputCoverage.slice(1).entries()) {
        currentEntries = helper_1.processInputPosition(coverage_1.listGlyphsByIndex(coverage).map((glyph) => glyph.glyphId), index + 1, currentEntries, table.lookupRecords, lookups);
      }
      for (const coverage of table.lookaheadCoverage) {
        currentEntries = helper_1.processLookaheadPosition(coverage_1.listGlyphsByIndex(coverage).map((glyph) => glyph.glyphId), currentEntries);
      }
      for (const coverage of table.backtrackCoverage) {
        currentEntries = helper_1.processBacktrackPosition(coverage_1.listGlyphsByIndex(coverage).map((glyph) => glyph.glyphId), currentEntries);
      }
      for (const { entry, substitutions } of currentEntries) {
        entry.lookup = {
          substitutions,
          index: tableIndex,
          subIndex: 0,
          length: table.inputCoverage.length,
          contextRange: [
            -1 * table.backtrackCoverage.length,
            table.inputCoverage.length + table.lookaheadCoverage.length
          ]
        };
      }
    }
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var coverage_1 = require_coverage();
  var helper_1 = require_helper();
  exports.default = buildTree;
});

// node_modules/npezza93-font-ligatures/dist/processors/8-1.js
var require_8_1 = __commonJS((exports) => {
  var buildTree = function(table, tableIndex) {
    const result = {
      individual: {},
      range: []
    };
    const glyphs = coverage_1.listGlyphsByIndex(table.coverage);
    for (const { glyphId, index } of glyphs) {
      const initialEntry = {};
      if (Array.isArray(glyphId)) {
        result.range.push({
          entry: initialEntry,
          range: glyphId
        });
      } else {
        result.individual[glyphId] = initialEntry;
      }
      let currentEntries = [{
        entry: initialEntry,
        substitutions: [table.substitutes[index]]
      }];
      for (const coverage of table.lookaheadCoverage) {
        currentEntries = helper_1.processLookaheadPosition(coverage_1.listGlyphsByIndex(coverage).map((glyph) => glyph.glyphId), currentEntries);
      }
      for (const coverage of table.backtrackCoverage) {
        currentEntries = helper_1.processBacktrackPosition(coverage_1.listGlyphsByIndex(coverage).map((glyph) => glyph.glyphId), currentEntries);
      }
      for (const { entry, substitutions } of currentEntries) {
        entry.lookup = {
          substitutions,
          index: tableIndex,
          subIndex: 0,
          length: 1,
          contextRange: [
            -1 * table.backtrackCoverage.length,
            1 + table.lookaheadCoverage.length
          ]
        };
      }
    }
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var coverage_1 = require_coverage();
  var helper_1 = require_helper();
  exports.default = buildTree;
});

// node_modules/npezza93-font-ligatures/dist/flatten.js
var require_flatten = __commonJS((exports) => {
  var flatten = function(tree) {
    const result = {};
    for (const [glyphId, entry] of Object.entries(tree.individual)) {
      result[glyphId] = flattenEntry(entry);
    }
    for (const { range, entry } of tree.range) {
      const flattened = flattenEntry(entry);
      for (let glyphId = range[0];glyphId < range[1]; glyphId++) {
        result[glyphId] = flattened;
      }
    }
    return result;
  };
  var flattenEntry = function(entry) {
    const result = {};
    if (entry.forward) {
      result.forward = flatten(entry.forward);
    }
    if (entry.reverse) {
      result.reverse = flatten(entry.reverse);
    }
    if (entry.lookup) {
      result.lookup = entry.lookup;
    }
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = flatten;
});

// node_modules/npezza93-font-ligatures/dist/index.js
var require_dist2 = __commonJS((exports) => {
  var loadBuffer = function(buffer, options) {
    const font = opentype.parse(buffer);
    return new FontImpl(font, Object.assign({ cacheSize: 0 }, options));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var opentype = require_opentype();
  var lru = require_lru_cache();
  var merge_1 = require_merge();
  var walk_1 = require_walk();
  var mergeRange_1 = require_mergeRange();
  var _6_1_1 = require_6_1();
  var _6_2_1 = require_6_2();
  var _6_3_1 = require_6_3();
  var _8_1_1 = require_8_1();
  var flatten_1 = require_flatten();

  class FontImpl {
    constructor(font, options) {
      this._lookupTrees = [];
      this._glyphLookups = {};
      this._font = font;
      if (options.cacheSize > 0) {
        this._cache = new lru({
          max: options.cacheSize,
          length: (val, key) => key.length
        });
      }
      const caltFeatures = this._font.tables.gsub && this._font.tables.gsub.features.filter((f) => f.tag === "calt") || [];
      const lookupIndices = caltFeatures.reduce((acc, val) => [...acc, ...val.feature.lookupListIndexes], []);
      const allLookups = this._font.tables.gsub && this._font.tables.gsub.lookups || [];
      const lookupGroups = allLookups.filter((l, i) => lookupIndices.some((idx) => idx === i));
      for (const [index, lookup] of lookupGroups.entries()) {
        const trees = [];
        switch (lookup.lookupType) {
          case 6:
            for (const [index2, table] of lookup.subtables.entries()) {
              switch (table.substFormat) {
                case 1:
                  trees.push(_6_1_1.default(table, allLookups, index2));
                  break;
                case 2:
                  trees.push(_6_2_1.default(table, allLookups, index2));
                  break;
                case 3:
                  trees.push(_6_3_1.default(table, allLookups, index2));
                  break;
              }
            }
            break;
          case 8:
            for (const [index2, table] of lookup.subtables.entries()) {
              trees.push(_8_1_1.default(table, index2));
            }
            break;
        }
        const tree = flatten_1.default(merge_1.default(trees));
        this._lookupTrees.push({
          tree,
          processForward: lookup.lookupType !== 8
        });
        for (const glyphId of Object.keys(tree)) {
          if (!this._glyphLookups[glyphId]) {
            this._glyphLookups[glyphId] = [];
          }
          this._glyphLookups[glyphId].push(index);
        }
      }
    }
    findLigatures(text) {
      const cached = this._cache && this._cache.get(text);
      if (cached && !Array.isArray(cached)) {
        return cached;
      }
      const glyphIds = [];
      for (const char of text) {
        glyphIds.push(this._font.charToGlyphIndex(char));
      }
      if (this._lookupTrees.length === 0) {
        return {
          inputGlyphs: glyphIds,
          outputGlyphs: glyphIds,
          contextRanges: []
        };
      }
      const result = this._findInternal(glyphIds.slice());
      const finalResult = {
        inputGlyphs: glyphIds,
        outputGlyphs: result.sequence,
        contextRanges: result.ranges
      };
      if (this._cache) {
        this._cache.set(text, finalResult);
      }
      return finalResult;
    }
    findLigatureRanges(text) {
      if (this._lookupTrees.length === 0) {
        return [];
      }
      const cached = this._cache && this._cache.get(text);
      if (cached) {
        return Array.isArray(cached) ? cached : cached.contextRanges;
      }
      const glyphIds = [];
      for (const char of text) {
        glyphIds.push(this._font.charToGlyphIndex(char));
      }
      const result = this._findInternal(glyphIds);
      if (this._cache) {
        this._cache.set(text, result.ranges);
      }
      return result.ranges;
    }
    _findInternal(sequence) {
      const ranges = [];
      let nextLookup = this._getNextLookup(sequence, 0);
      while (nextLookup.index !== null) {
        const lookup = this._lookupTrees[nextLookup.index];
        if (lookup.processForward) {
          let lastGlyphIndex = nextLookup.last;
          for (let i = nextLookup.first;i < lastGlyphIndex; i++) {
            const result = walk_1.default(lookup.tree, sequence, i, i);
            if (result) {
              for (let j = 0;j < result.substitutions.length; j++) {
                const sub = result.substitutions[j];
                if (sub !== null) {
                  sequence[i + j] = sub;
                }
              }
              mergeRange_1.default(ranges, result.contextRange[0] + i, result.contextRange[1] + i);
              if (i + result.length >= lastGlyphIndex) {
                lastGlyphIndex = i + result.length + 1;
              }
              i += result.length - 1;
            }
          }
        } else {
          for (let i = nextLookup.last - 1;i >= nextLookup.first; i--) {
            const result = walk_1.default(lookup.tree, sequence, i, i);
            if (result) {
              for (let j = 0;j < result.substitutions.length; j++) {
                const sub = result.substitutions[j];
                if (sub !== null) {
                  sequence[i + j] = sub;
                }
              }
              mergeRange_1.default(ranges, result.contextRange[0] + i, result.contextRange[1] + i);
              i -= result.length - 1;
            }
          }
        }
        nextLookup = this._getNextLookup(sequence, nextLookup.index + 1);
      }
      return { sequence, ranges };
    }
    _getNextLookup(sequence, start) {
      const result = {
        index: null,
        first: Infinity,
        last: -1
      };
      for (let i = 0;i < sequence.length; i++) {
        const lookups = this._glyphLookups[sequence[i]];
        if (!lookups) {
          continue;
        }
        for (let j = 0;j < lookups.length; j++) {
          const lookupIndex = lookups[j];
          if (lookupIndex >= start) {
            if (result.index === null || lookupIndex <= result.index) {
              result.index = lookupIndex;
              if (result.first > i) {
                result.first = i;
              }
              result.last = i + 1;
            }
            break;
          }
        }
      }
      return result;
    }
  }
  exports.loadBuffer = loadBuffer;
});

// node_modules/xterm-addon-webgl/lib/xterm-addon-webgl.js
var require_xterm_addon_webgl = __commonJS((exports, module) => {
  (function(e, t) {
    typeof exports == "object" && typeof module == "object" ? module.exports = t() : typeof define == "function" && define.amd ? define([], t) : typeof exports == "object" ? exports.WebglAddon = t() : e.WebglAddon = t();
  })(self, () => (() => {
    var e = { 965: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.GlyphRenderer = undefined;
      const s2 = i2(374), r = i2(509), o = i2(855), n = i2(859), a = i2(381), h = 11, l = h * Float32Array.BYTES_PER_ELEMENT;
      let c, d = 0, _ = 0, u = 0;

      class g extends n.Disposable {
        constructor(e3, t3, i3) {
          super(), this._terminal = e3, this._gl = t3, this._dimensions = i3, this._activeBuffer = 0, this._vertices = { count: 0, attributes: new Float32Array(0), attributesBuffers: [new Float32Array(0), new Float32Array(0)] };
          const o2 = this._gl;
          r.TextureAtlas.maxAtlasPages === undefined && (r.TextureAtlas.maxAtlasPages = Math.min(32, (0, s2.throwIfFalsy)(o2.getParameter(o2.MAX_TEXTURE_IMAGE_UNITS))), r.TextureAtlas.maxTextureSize = (0, s2.throwIfFalsy)(o2.getParameter(o2.MAX_TEXTURE_SIZE))), this._program = (0, s2.throwIfFalsy)((0, a.createProgram)(o2, "#version 300 es\nlayout (location = 0) in vec2 a_unitquad;\nlayout (location = 1) in vec2 a_cellpos;\nlayout (location = 2) in vec2 a_offset;\nlayout (location = 3) in vec2 a_size;\nlayout (location = 4) in float a_texpage;\nlayout (location = 5) in vec2 a_texcoord;\nlayout (location = 6) in vec2 a_texsize;\n\nuniform mat4 u_projection;\nuniform vec2 u_resolution;\n\nout vec2 v_texcoord;\nflat out int v_texpage;\n\nvoid main() {\n  vec2 zeroToOne = (a_offset / u_resolution) + a_cellpos + (a_unitquad * a_size);\n  gl_Position = u_projection * vec4(zeroToOne, 0.0, 1.0);\n  v_texpage = int(a_texpage);\n  v_texcoord = a_texcoord + a_unitquad * a_texsize;\n}", function(e4) {
            let t4 = "";
            for (let i4 = 1;i4 < e4; i4++)
              t4 += ` else if (v_texpage == ${i4}) { outColor = texture(u_texture[${i4}], v_texcoord); }`;
            return `#version 300 es\nprecision lowp float;\n\nin vec2 v_texcoord;\nflat in int v_texpage;\n\nuniform sampler2D u_texture[${e4}];\n\nout vec4 outColor;\n\nvoid main() {\n  if (v_texpage == 0) {\n    outColor = texture(u_texture[0], v_texcoord);\n  } ${t4}\n}`;
          }(r.TextureAtlas.maxAtlasPages))), this.register((0, n.toDisposable)(() => o2.deleteProgram(this._program))), this._projectionLocation = (0, s2.throwIfFalsy)(o2.getUniformLocation(this._program, "u_projection")), this._resolutionLocation = (0, s2.throwIfFalsy)(o2.getUniformLocation(this._program, "u_resolution")), this._textureLocation = (0, s2.throwIfFalsy)(o2.getUniformLocation(this._program, "u_texture")), this._vertexArrayObject = o2.createVertexArray(), o2.bindVertexArray(this._vertexArrayObject);
          const h2 = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), c2 = o2.createBuffer();
          this.register((0, n.toDisposable)(() => o2.deleteBuffer(c2))), o2.bindBuffer(o2.ARRAY_BUFFER, c2), o2.bufferData(o2.ARRAY_BUFFER, h2, o2.STATIC_DRAW), o2.enableVertexAttribArray(0), o2.vertexAttribPointer(0, 2, this._gl.FLOAT, false, 0, 0);
          const d2 = new Uint8Array([0, 1, 2, 3]), _2 = o2.createBuffer();
          this.register((0, n.toDisposable)(() => o2.deleteBuffer(_2))), o2.bindBuffer(o2.ELEMENT_ARRAY_BUFFER, _2), o2.bufferData(o2.ELEMENT_ARRAY_BUFFER, d2, o2.STATIC_DRAW), this._attributesBuffer = (0, s2.throwIfFalsy)(o2.createBuffer()), this.register((0, n.toDisposable)(() => o2.deleteBuffer(this._attributesBuffer))), o2.bindBuffer(o2.ARRAY_BUFFER, this._attributesBuffer), o2.enableVertexAttribArray(2), o2.vertexAttribPointer(2, 2, o2.FLOAT, false, l, 0), o2.vertexAttribDivisor(2, 1), o2.enableVertexAttribArray(3), o2.vertexAttribPointer(3, 2, o2.FLOAT, false, l, 2 * Float32Array.BYTES_PER_ELEMENT), o2.vertexAttribDivisor(3, 1), o2.enableVertexAttribArray(4), o2.vertexAttribPointer(4, 1, o2.FLOAT, false, l, 4 * Float32Array.BYTES_PER_ELEMENT), o2.vertexAttribDivisor(4, 1), o2.enableVertexAttribArray(5), o2.vertexAttribPointer(5, 2, o2.FLOAT, false, l, 5 * Float32Array.BYTES_PER_ELEMENT), o2.vertexAttribDivisor(5, 1), o2.enableVertexAttribArray(6), o2.vertexAttribPointer(6, 2, o2.FLOAT, false, l, 7 * Float32Array.BYTES_PER_ELEMENT), o2.vertexAttribDivisor(6, 1), o2.enableVertexAttribArray(1), o2.vertexAttribPointer(1, 2, o2.FLOAT, false, l, 9 * Float32Array.BYTES_PER_ELEMENT), o2.vertexAttribDivisor(1, 1), o2.useProgram(this._program);
          const u2 = new Int32Array(r.TextureAtlas.maxAtlasPages);
          for (let e4 = 0;e4 < r.TextureAtlas.maxAtlasPages; e4++)
            u2[e4] = e4;
          o2.uniform1iv(this._textureLocation, u2), o2.uniformMatrix4fv(this._projectionLocation, false, a.PROJECTION_MATRIX), this._atlasTextures = [];
          for (let e4 = 0;e4 < r.TextureAtlas.maxAtlasPages; e4++) {
            const t4 = new a.GLTexture((0, s2.throwIfFalsy)(o2.createTexture()));
            this.register((0, n.toDisposable)(() => o2.deleteTexture(t4.texture))), o2.activeTexture(o2.TEXTURE0 + e4), o2.bindTexture(o2.TEXTURE_2D, t4.texture), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_WRAP_S, o2.CLAMP_TO_EDGE), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_WRAP_T, o2.CLAMP_TO_EDGE), o2.texImage2D(o2.TEXTURE_2D, 0, o2.RGBA, 1, 1, 0, o2.RGBA, o2.UNSIGNED_BYTE, new Uint8Array([255, 0, 0, 255])), this._atlasTextures[e4] = t4;
          }
          o2.enable(o2.BLEND), o2.blendFunc(o2.SRC_ALPHA, o2.ONE_MINUS_SRC_ALPHA), this.handleResize();
        }
        beginFrame() {
          return !this._atlas || this._atlas.beginFrame();
        }
        updateCell(e3, t3, i3, s3, r2, o2, n2, a2) {
          this._updateCell(this._vertices.attributes, e3, t3, i3, s3, r2, o2, n2, a2);
        }
        _updateCell(e3, t3, i3, s3, r2, n2, a2, l2, g2) {
          d = (i3 * this._terminal.cols + t3) * h, s3 !== o.NULL_CELL_CODE && s3 !== undefined ? this._atlas && (c = l2 && l2.length > 1 ? this._atlas.getRasterizedGlyphCombinedChar(l2, r2, n2, a2, false) : this._atlas.getRasterizedGlyph(s3, r2, n2, a2, false), _ = Math.floor((this._dimensions.device.cell.width - this._dimensions.device.char.width) / 2), r2 !== g2 && c.offset.x > _ ? (u = c.offset.x - _, e3[d] = -(c.offset.x - u) + this._dimensions.device.char.left, e3[d + 1] = -c.offset.y + this._dimensions.device.char.top, e3[d + 2] = (c.size.x - u) / this._dimensions.device.canvas.width, e3[d + 3] = c.size.y / this._dimensions.device.canvas.height, e3[d + 4] = c.texturePage, e3[d + 5] = c.texturePositionClipSpace.x + u / this._atlas.pages[c.texturePage].canvas.width, e3[d + 6] = c.texturePositionClipSpace.y, e3[d + 7] = c.sizeClipSpace.x - u / this._atlas.pages[c.texturePage].canvas.width, e3[d + 8] = c.sizeClipSpace.y) : (e3[d] = -c.offset.x + this._dimensions.device.char.left, e3[d + 1] = -c.offset.y + this._dimensions.device.char.top, e3[d + 2] = c.size.x / this._dimensions.device.canvas.width, e3[d + 3] = c.size.y / this._dimensions.device.canvas.height, e3[d + 4] = c.texturePage, e3[d + 5] = c.texturePositionClipSpace.x, e3[d + 6] = c.texturePositionClipSpace.y, e3[d + 7] = c.sizeClipSpace.x, e3[d + 8] = c.sizeClipSpace.y)) : e3.fill(0, d, d + h - 1 - 2);
        }
        clear() {
          const e3 = this._terminal, t3 = e3.cols * e3.rows * h;
          this._vertices.count !== t3 ? this._vertices.attributes = new Float32Array(t3) : this._vertices.attributes.fill(0);
          let i3 = 0;
          for (;i3 < this._vertices.attributesBuffers.length; i3++)
            this._vertices.count !== t3 ? this._vertices.attributesBuffers[i3] = new Float32Array(t3) : this._vertices.attributesBuffers[i3].fill(0);
          this._vertices.count = t3, i3 = 0;
          for (let t4 = 0;t4 < e3.rows; t4++)
            for (let s3 = 0;s3 < e3.cols; s3++)
              this._vertices.attributes[i3 + 9] = s3 / e3.cols, this._vertices.attributes[i3 + 10] = t4 / e3.rows, i3 += h;
        }
        handleResize() {
          const e3 = this._gl;
          e3.useProgram(this._program), e3.viewport(0, 0, e3.canvas.width, e3.canvas.height), e3.uniform2f(this._resolutionLocation, e3.canvas.width, e3.canvas.height), this.clear();
        }
        render(e3) {
          if (!this._atlas)
            return;
          const t3 = this._gl;
          t3.useProgram(this._program), t3.bindVertexArray(this._vertexArrayObject), this._activeBuffer = (this._activeBuffer + 1) % 2;
          const i3 = this._vertices.attributesBuffers[this._activeBuffer];
          let s3 = 0;
          for (let t4 = 0;t4 < e3.lineLengths.length; t4++) {
            const r2 = t4 * this._terminal.cols * h, o2 = this._vertices.attributes.subarray(r2, r2 + e3.lineLengths[t4] * h);
            i3.set(o2, s3), s3 += o2.length;
          }
          t3.bindBuffer(t3.ARRAY_BUFFER, this._attributesBuffer), t3.bufferData(t3.ARRAY_BUFFER, i3.subarray(0, s3), t3.STREAM_DRAW);
          for (let e4 = 0;e4 < this._atlas.pages.length; e4++)
            this._atlas.pages[e4].version !== this._atlasTextures[e4].version && this._bindAtlasPageTexture(t3, this._atlas, e4);
          t3.drawElementsInstanced(t3.TRIANGLE_STRIP, 4, t3.UNSIGNED_BYTE, 0, s3 / h);
        }
        setAtlas(e3) {
          this._atlas = e3;
          for (const e4 of this._atlasTextures)
            e4.version = -1;
        }
        _bindAtlasPageTexture(e3, t3, i3) {
          e3.activeTexture(e3.TEXTURE0 + i3), e3.bindTexture(e3.TEXTURE_2D, this._atlasTextures[i3].texture), e3.texParameteri(e3.TEXTURE_2D, e3.TEXTURE_WRAP_S, e3.CLAMP_TO_EDGE), e3.texParameteri(e3.TEXTURE_2D, e3.TEXTURE_WRAP_T, e3.CLAMP_TO_EDGE), e3.texImage2D(e3.TEXTURE_2D, 0, e3.RGBA, e3.RGBA, e3.UNSIGNED_BYTE, t3.pages[i3].canvas), e3.generateMipmap(e3.TEXTURE_2D), this._atlasTextures[i3].version = t3.pages[i3].version;
        }
        setDimensions(e3) {
          this._dimensions = e3;
        }
      }
      t2.GlyphRenderer = g;
    }, 742: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.RectangleRenderer = undefined;
      const s2 = i2(374), r = i2(859), o = i2(310), n = i2(381), a = 8 * Float32Array.BYTES_PER_ELEMENT;

      class h {
        constructor() {
          this.attributes = new Float32Array(160), this.count = 0;
        }
      }
      let l = 0, c = 0, d = 0, _ = 0, u = 0, g = 0, v = 0;

      class f extends r.Disposable {
        constructor(e3, t3, i3, o2) {
          super(), this._terminal = e3, this._gl = t3, this._dimensions = i3, this._themeService = o2, this._vertices = new h, this._verticesCursor = new h;
          const l2 = this._gl;
          this._program = (0, s2.throwIfFalsy)((0, n.createProgram)(l2, "#version 300 es\nlayout (location = 0) in vec2 a_position;\nlayout (location = 1) in vec2 a_size;\nlayout (location = 2) in vec4 a_color;\nlayout (location = 3) in vec2 a_unitquad;\n\nuniform mat4 u_projection;\n\nout vec4 v_color;\n\nvoid main() {\n  vec2 zeroToOne = a_position + (a_unitquad * a_size);\n  gl_Position = u_projection * vec4(zeroToOne, 0.0, 1.0);\n  v_color = a_color;\n}", "#version 300 es\nprecision lowp float;\n\nin vec4 v_color;\n\nout vec4 outColor;\n\nvoid main() {\n  outColor = v_color;\n}")), this.register((0, r.toDisposable)(() => l2.deleteProgram(this._program))), this._projectionLocation = (0, s2.throwIfFalsy)(l2.getUniformLocation(this._program, "u_projection")), this._vertexArrayObject = l2.createVertexArray(), l2.bindVertexArray(this._vertexArrayObject);
          const c2 = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), d2 = l2.createBuffer();
          this.register((0, r.toDisposable)(() => l2.deleteBuffer(d2))), l2.bindBuffer(l2.ARRAY_BUFFER, d2), l2.bufferData(l2.ARRAY_BUFFER, c2, l2.STATIC_DRAW), l2.enableVertexAttribArray(3), l2.vertexAttribPointer(3, 2, this._gl.FLOAT, false, 0, 0);
          const _2 = new Uint8Array([0, 1, 2, 3]), u2 = l2.createBuffer();
          this.register((0, r.toDisposable)(() => l2.deleteBuffer(u2))), l2.bindBuffer(l2.ELEMENT_ARRAY_BUFFER, u2), l2.bufferData(l2.ELEMENT_ARRAY_BUFFER, _2, l2.STATIC_DRAW), this._attributesBuffer = (0, s2.throwIfFalsy)(l2.createBuffer()), this.register((0, r.toDisposable)(() => l2.deleteBuffer(this._attributesBuffer))), l2.bindBuffer(l2.ARRAY_BUFFER, this._attributesBuffer), l2.enableVertexAttribArray(0), l2.vertexAttribPointer(0, 2, l2.FLOAT, false, a, 0), l2.vertexAttribDivisor(0, 1), l2.enableVertexAttribArray(1), l2.vertexAttribPointer(1, 2, l2.FLOAT, false, a, 2 * Float32Array.BYTES_PER_ELEMENT), l2.vertexAttribDivisor(1, 1), l2.enableVertexAttribArray(2), l2.vertexAttribPointer(2, 4, l2.FLOAT, false, a, 4 * Float32Array.BYTES_PER_ELEMENT), l2.vertexAttribDivisor(2, 1), this._updateCachedColors(o2.colors), this.register(this._themeService.onChangeColors((e4) => {
            this._updateCachedColors(e4), this._updateViewportRectangle();
          }));
        }
        renderBackgrounds() {
          this._renderVertices(this._vertices);
        }
        renderCursor() {
          this._renderVertices(this._verticesCursor);
        }
        _renderVertices(e3) {
          const t3 = this._gl;
          t3.useProgram(this._program), t3.bindVertexArray(this._vertexArrayObject), t3.uniformMatrix4fv(this._projectionLocation, false, n.PROJECTION_MATRIX), t3.bindBuffer(t3.ARRAY_BUFFER, this._attributesBuffer), t3.bufferData(t3.ARRAY_BUFFER, e3.attributes, t3.DYNAMIC_DRAW), t3.drawElementsInstanced(this._gl.TRIANGLE_STRIP, 4, t3.UNSIGNED_BYTE, 0, e3.count);
        }
        handleResize() {
          this._updateViewportRectangle();
        }
        setDimensions(e3) {
          this._dimensions = e3;
        }
        _updateCachedColors(e3) {
          this._bgFloat = this._colorToFloat32Array(e3.background), this._cursorFloat = this._colorToFloat32Array(e3.cursor);
        }
        _updateViewportRectangle() {
          this._addRectangleFloat(this._vertices.attributes, 0, 0, 0, this._terminal.cols * this._dimensions.device.cell.width, this._terminal.rows * this._dimensions.device.cell.height, this._bgFloat);
        }
        updateBackgrounds(e3) {
          const t3 = this._terminal, i3 = this._vertices;
          let s3, r2, n2, a2, h2, l2, c2, d2, _2, u2, g2, v2 = 1;
          for (s3 = 0;s3 < t3.rows; s3++) {
            for (n2 = -1, a2 = 0, h2 = 0, l2 = false, r2 = 0;r2 < t3.cols; r2++)
              c2 = (s3 * t3.cols + r2) * o.RENDER_MODEL_INDICIES_PER_CELL, d2 = e3.cells[c2 + o.RENDER_MODEL_BG_OFFSET], _2 = e3.cells[c2 + o.RENDER_MODEL_FG_OFFSET], u2 = !!(67108864 & _2), (d2 !== a2 || _2 !== h2 && (l2 || u2)) && ((a2 !== 0 || l2 && h2 !== 0) && (g2 = 8 * v2++, this._updateRectangle(i3, g2, h2, a2, n2, r2, s3)), n2 = r2, a2 = d2, h2 = _2, l2 = u2);
            (a2 !== 0 || l2 && h2 !== 0) && (g2 = 8 * v2++, this._updateRectangle(i3, g2, h2, a2, n2, t3.cols, s3));
          }
          i3.count = v2;
        }
        updateCursor(e3) {
          const t3 = this._verticesCursor, i3 = e3.cursor;
          if (!i3 || i3.style === "block")
            return void (t3.count = 0);
          let s3, r2 = 0;
          i3.style !== "bar" && i3.style !== "outline" || (s3 = 8 * r2++, this._addRectangleFloat(t3.attributes, s3, i3.x * this._dimensions.device.cell.width, i3.y * this._dimensions.device.cell.height, i3.style === "bar" ? i3.dpr * i3.cursorWidth : i3.dpr, this._dimensions.device.cell.height, this._cursorFloat)), i3.style !== "underline" && i3.style !== "outline" || (s3 = 8 * r2++, this._addRectangleFloat(t3.attributes, s3, i3.x * this._dimensions.device.cell.width, (i3.y + 1) * this._dimensions.device.cell.height - i3.dpr, i3.width * this._dimensions.device.cell.width, i3.dpr, this._cursorFloat)), i3.style === "outline" && (s3 = 8 * r2++, this._addRectangleFloat(t3.attributes, s3, i3.x * this._dimensions.device.cell.width, i3.y * this._dimensions.device.cell.height, i3.width * this._dimensions.device.cell.width, i3.dpr, this._cursorFloat), s3 = 8 * r2++, this._addRectangleFloat(t3.attributes, s3, (i3.x + i3.width) * this._dimensions.device.cell.width - i3.dpr, i3.y * this._dimensions.device.cell.height, i3.dpr, this._dimensions.device.cell.height, this._cursorFloat)), t3.count = r2;
        }
        _updateRectangle(e3, t3, i3, s3, r2, o2, a2) {
          if (67108864 & i3)
            switch (50331648 & i3) {
              case 16777216:
              case 33554432:
                l = this._themeService.colors.ansi[255 & i3].rgba;
                break;
              case 50331648:
                l = (16777215 & i3) << 8;
                break;
              default:
                l = this._themeService.colors.foreground.rgba;
            }
          else
            switch (50331648 & s3) {
              case 16777216:
              case 33554432:
                l = this._themeService.colors.ansi[255 & s3].rgba;
                break;
              case 50331648:
                l = (16777215 & s3) << 8;
                break;
              default:
                l = this._themeService.colors.background.rgba;
            }
          e3.attributes.length < t3 + 4 && (e3.attributes = (0, n.expandFloat32Array)(e3.attributes, this._terminal.rows * this._terminal.cols * 8)), c = r2 * this._dimensions.device.cell.width, d = a2 * this._dimensions.device.cell.height, _ = (l >> 24 & 255) / 255, u = (l >> 16 & 255) / 255, g = (l >> 8 & 255) / 255, v = 1, this._addRectangle(e3.attributes, t3, c, d, (o2 - r2) * this._dimensions.device.cell.width, this._dimensions.device.cell.height, _, u, g, v);
        }
        _addRectangle(e3, t3, i3, s3, r2, o2, n2, a2, h2, l2) {
          e3[t3] = i3 / this._dimensions.device.canvas.width, e3[t3 + 1] = s3 / this._dimensions.device.canvas.height, e3[t3 + 2] = r2 / this._dimensions.device.canvas.width, e3[t3 + 3] = o2 / this._dimensions.device.canvas.height, e3[t3 + 4] = n2, e3[t3 + 5] = a2, e3[t3 + 6] = h2, e3[t3 + 7] = l2;
        }
        _addRectangleFloat(e3, t3, i3, s3, r2, o2, n2) {
          e3[t3] = i3 / this._dimensions.device.canvas.width, e3[t3 + 1] = s3 / this._dimensions.device.canvas.height, e3[t3 + 2] = r2 / this._dimensions.device.canvas.width, e3[t3 + 3] = o2 / this._dimensions.device.canvas.height, e3[t3 + 4] = n2[0], e3[t3 + 5] = n2[1], e3[t3 + 6] = n2[2], e3[t3 + 7] = n2[3];
        }
        _colorToFloat32Array(e3) {
          return new Float32Array([(e3.rgba >> 24 & 255) / 255, (e3.rgba >> 16 & 255) / 255, (e3.rgba >> 8 & 255) / 255, (255 & e3.rgba) / 255]);
        }
      }
      t2.RectangleRenderer = f;
    }, 310: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.RenderModel = t2.COMBINED_CHAR_BIT_MASK = t2.RENDER_MODEL_EXT_OFFSET = t2.RENDER_MODEL_FG_OFFSET = t2.RENDER_MODEL_BG_OFFSET = t2.RENDER_MODEL_INDICIES_PER_CELL = undefined;
      const s2 = i2(296);
      t2.RENDER_MODEL_INDICIES_PER_CELL = 4, t2.RENDER_MODEL_BG_OFFSET = 1, t2.RENDER_MODEL_FG_OFFSET = 2, t2.RENDER_MODEL_EXT_OFFSET = 3, t2.COMBINED_CHAR_BIT_MASK = 2147483648, t2.RenderModel = class {
        constructor() {
          this.cells = new Uint32Array(0), this.lineLengths = new Uint32Array(0), this.selection = (0, s2.createSelectionRenderModel)();
        }
        resize(e3, i3) {
          const s3 = e3 * i3 * t2.RENDER_MODEL_INDICIES_PER_CELL;
          s3 !== this.cells.length && (this.cells = new Uint32Array(s3), this.lineLengths = new Uint32Array(i3));
        }
        clear() {
          this.cells.fill(0, 0), this.lineLengths.fill(0, 0);
        }
      };
    }, 666: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.JoinedCellData = t2.WebglRenderer = undefined;
      const s2 = i2(820), r = i2(274), o = i2(627), n = i2(457), a = i2(56), h = i2(374), l = i2(345), c = i2(859), d = i2(147), _ = i2(782), u = i2(855), g = i2(965), v = i2(742), f = i2(310), p = i2(733);

      class C extends c.Disposable {
        constructor(e3, t3, i3, n2, d2, u2, g2, v2, C2) {
          super(), this._terminal = e3, this._characterJoinerService = t3, this._charSizeService = i3, this._coreBrowserService = n2, this._coreService = d2, this._decorationService = u2, this._optionsService = g2, this._themeService = v2, this._cursorBlinkStateManager = new c.MutableDisposable, this._charAtlasDisposable = this.register(new c.MutableDisposable), this._model = new f.RenderModel, this._workCell = new _.CellData, this._rectangleRenderer = this.register(new c.MutableDisposable), this._glyphRenderer = this.register(new c.MutableDisposable), this._onChangeTextureAtlas = this.register(new l.EventEmitter), this.onChangeTextureAtlas = this._onChangeTextureAtlas.event, this._onAddTextureAtlasCanvas = this.register(new l.EventEmitter), this.onAddTextureAtlasCanvas = this._onAddTextureAtlasCanvas.event, this._onRemoveTextureAtlasCanvas = this.register(new l.EventEmitter), this.onRemoveTextureAtlasCanvas = this._onRemoveTextureAtlasCanvas.event, this._onRequestRedraw = this.register(new l.EventEmitter), this.onRequestRedraw = this._onRequestRedraw.event, this._onContextLoss = this.register(new l.EventEmitter), this.onContextLoss = this._onContextLoss.event, this.register(this._themeService.onChangeColors(() => this._handleColorChange())), this._cellColorResolver = new r.CellColorResolver(this._terminal, this._model.selection, this._decorationService, this._coreBrowserService, this._themeService), this._core = this._terminal._core, this._renderLayers = [new p.LinkRenderLayer(this._core.screenElement, 2, this._terminal, this._core.linkifier2, this._coreBrowserService, g2, this._themeService)], this.dimensions = (0, h.createRenderDimensions)(), this._devicePixelRatio = this._coreBrowserService.dpr, this._updateDimensions(), this._updateCursorBlink(), this.register(g2.onOptionChange(() => this._handleOptionsChanged())), this._canvas = this._coreBrowserService.mainDocument.createElement("canvas");
          const m2 = { antialias: false, depth: false, preserveDrawingBuffer: C2 };
          if (this._gl = this._canvas.getContext("webgl2", m2), !this._gl)
            throw new Error("WebGL2 not supported " + this._gl);
          this.register((0, s2.addDisposableDomListener)(this._canvas, "webglcontextlost", (e4) => {
            console.log("webglcontextlost event received"), e4.preventDefault(), this._contextRestorationTimeout = setTimeout(() => {
              this._contextRestorationTimeout = undefined, console.warn("webgl context not restored; firing onContextLoss"), this._onContextLoss.fire(e4);
            }, 3000);
          })), this.register((0, s2.addDisposableDomListener)(this._canvas, "webglcontextrestored", (e4) => {
            console.warn("webglcontextrestored event received"), clearTimeout(this._contextRestorationTimeout), this._contextRestorationTimeout = undefined, (0, o.removeTerminalFromCache)(this._terminal), this._initializeWebGLState(), this._requestRedrawViewport();
          })), this.register((0, a.observeDevicePixelDimensions)(this._canvas, this._coreBrowserService.window, (e4, t4) => this._setCanvasDevicePixelDimensions(e4, t4))), this._core.screenElement.appendChild(this._canvas), [this._rectangleRenderer.value, this._glyphRenderer.value] = this._initializeWebGLState(), this._isAttached = this._coreBrowserService.window.document.body.contains(this._core.screenElement), this.register((0, c.toDisposable)(() => {
            for (const e4 of this._renderLayers)
              e4.dispose();
            this._canvas.parentElement?.removeChild(this._canvas), (0, o.removeTerminalFromCache)(this._terminal);
          }));
        }
        get textureAtlas() {
          return this._charAtlas?.pages[0].canvas;
        }
        _handleColorChange() {
          this._refreshCharAtlas(), this._clearModel(true);
        }
        handleDevicePixelRatioChange() {
          this._devicePixelRatio !== this._coreBrowserService.dpr && (this._devicePixelRatio = this._coreBrowserService.dpr, this.handleResize(this._terminal.cols, this._terminal.rows));
        }
        handleResize(e3, t3) {
          this._updateDimensions(), this._model.resize(this._terminal.cols, this._terminal.rows);
          for (const e4 of this._renderLayers)
            e4.resize(this._terminal, this.dimensions);
          this._canvas.width = this.dimensions.device.canvas.width, this._canvas.height = this.dimensions.device.canvas.height, this._canvas.style.width = `${this.dimensions.css.canvas.width}px`, this._canvas.style.height = `${this.dimensions.css.canvas.height}px`, this._core.screenElement.style.width = `${this.dimensions.css.canvas.width}px`, this._core.screenElement.style.height = `${this.dimensions.css.canvas.height}px`, this._rectangleRenderer.value?.setDimensions(this.dimensions), this._rectangleRenderer.value?.handleResize(), this._glyphRenderer.value?.setDimensions(this.dimensions), this._glyphRenderer.value?.handleResize(), this._refreshCharAtlas(), this._clearModel(false);
        }
        handleCharSizeChanged() {
          this.handleResize(this._terminal.cols, this._terminal.rows);
        }
        handleBlur() {
          for (const e3 of this._renderLayers)
            e3.handleBlur(this._terminal);
          this._cursorBlinkStateManager.value?.pause(), this._requestRedrawViewport();
        }
        handleFocus() {
          for (const e3 of this._renderLayers)
            e3.handleFocus(this._terminal);
          this._cursorBlinkStateManager.value?.resume(), this._requestRedrawViewport();
        }
        handleSelectionChanged(e3, t3, i3) {
          for (const s3 of this._renderLayers)
            s3.handleSelectionChanged(this._terminal, e3, t3, i3);
          this._model.selection.update(this._terminal, e3, t3, i3), this._requestRedrawViewport();
        }
        handleCursorMove() {
          for (const e3 of this._renderLayers)
            e3.handleCursorMove(this._terminal);
          this._cursorBlinkStateManager.value?.restartBlinkAnimation();
        }
        _handleOptionsChanged() {
          this._updateDimensions(), this._refreshCharAtlas(), this._updateCursorBlink();
        }
        _initializeWebGLState() {
          return this._rectangleRenderer.value = new v.RectangleRenderer(this._terminal, this._gl, this.dimensions, this._themeService), this._glyphRenderer.value = new g.GlyphRenderer(this._terminal, this._gl, this.dimensions), this.handleCharSizeChanged(), [this._rectangleRenderer.value, this._glyphRenderer.value];
        }
        _refreshCharAtlas() {
          if (this.dimensions.device.char.width <= 0 && this.dimensions.device.char.height <= 0)
            return void (this._isAttached = false);
          const e3 = (0, o.acquireTextureAtlas)(this._terminal, this._optionsService.rawOptions, this._themeService.colors, this.dimensions.device.cell.width, this.dimensions.device.cell.height, this.dimensions.device.char.width, this.dimensions.device.char.height, this._coreBrowserService.dpr);
          this._charAtlas !== e3 && (this._onChangeTextureAtlas.fire(e3.pages[0].canvas), this._charAtlasDisposable.value = (0, c.getDisposeArrayDisposable)([(0, l.forwardEvent)(e3.onAddTextureAtlasCanvas, this._onAddTextureAtlasCanvas), (0, l.forwardEvent)(e3.onRemoveTextureAtlasCanvas, this._onRemoveTextureAtlasCanvas)])), this._charAtlas = e3, this._charAtlas.warmUp(), this._glyphRenderer.value?.setAtlas(this._charAtlas);
        }
        _clearModel(e3) {
          this._model.clear(), e3 && this._glyphRenderer.value?.clear();
        }
        clearTextureAtlas() {
          this._charAtlas?.clearTexture(), this._clearModel(true), this._requestRedrawViewport();
        }
        clear() {
          this._clearModel(true);
          for (const e3 of this._renderLayers)
            e3.reset(this._terminal);
          this._cursorBlinkStateManager.value?.restartBlinkAnimation(), this._updateCursorBlink();
        }
        registerCharacterJoiner(e3) {
          return -1;
        }
        deregisterCharacterJoiner(e3) {
          return false;
        }
        renderRows(e3, t3) {
          if (!this._isAttached) {
            if (!(this._coreBrowserService.window.document.body.contains(this._core.screenElement) && this._charSizeService.width && this._charSizeService.height))
              return;
            this._updateDimensions(), this._refreshCharAtlas(), this._isAttached = true;
          }
          for (const i3 of this._renderLayers)
            i3.handleGridChanged(this._terminal, e3, t3);
          this._glyphRenderer.value && this._rectangleRenderer.value && (this._glyphRenderer.value.beginFrame() ? (this._clearModel(true), this._updateModel(0, this._terminal.rows - 1)) : this._updateModel(e3, t3), this._rectangleRenderer.value.renderBackgrounds(), this._glyphRenderer.value.render(this._model), this._cursorBlinkStateManager.value && !this._cursorBlinkStateManager.value.isCursorVisible || this._rectangleRenderer.value.renderCursor());
        }
        _updateCursorBlink() {
          this._terminal.options.cursorBlink ? this._cursorBlinkStateManager.value = new n.CursorBlinkStateManager(() => {
            this._requestRedrawCursor();
          }, this._coreBrowserService) : this._cursorBlinkStateManager.clear(), this._requestRedrawCursor();
        }
        _updateModel(e3, t3) {
          const i3 = this._core;
          let s3, r2, o2, n2, a2, h2, l2, c2, d2, _2, g2, v2, p2, C2 = this._workCell;
          e3 = L(e3, i3.rows - 1, 0), t3 = L(t3, i3.rows - 1, 0);
          const x = this._terminal.buffer.active.baseY + this._terminal.buffer.active.cursorY, w = Math.min(this._terminal.buffer.active.cursorX, i3.cols - 1);
          let b = -1;
          const R = this._coreService.isCursorInitialized && !this._coreService.isCursorHidden && (!this._cursorBlinkStateManager.value || this._cursorBlinkStateManager.value.isCursorVisible);
          this._model.cursor = undefined;
          let M = false;
          for (r2 = e3;r2 <= t3; r2++)
            for (o2 = r2 + i3.buffer.ydisp, n2 = i3.buffer.lines.get(o2), this._model.lineLengths[r2] = 0, a2 = this._characterJoinerService.getJoinedCharacters(o2), v2 = 0;v2 < i3.cols; v2++)
              if (s3 = this._cellColorResolver.result.bg, n2.loadCell(v2, C2), v2 === 0 && (s3 = this._cellColorResolver.result.bg), h2 = false, l2 = v2, a2.length > 0 && v2 === a2[0][0] && (h2 = true, c2 = a2.shift(), C2 = new m(C2, n2.translateToString(true, c2[0], c2[1]), c2[1] - c2[0]), l2 = c2[1] - 1), d2 = C2.getChars(), _2 = C2.getCode(), g2 = (r2 * i3.cols + v2) * f.RENDER_MODEL_INDICIES_PER_CELL, this._cellColorResolver.resolve(C2, v2, o2), R && o2 === x && (v2 === w && (this._model.cursor = { x: w, y: this._terminal.buffer.active.cursorY, width: C2.getWidth(), style: this._coreBrowserService.isFocused ? i3.options.cursorStyle || "block" : i3.options.cursorInactiveStyle, cursorWidth: i3.options.cursorWidth, dpr: this._devicePixelRatio }, b = w + C2.getWidth() - 1), v2 >= w && v2 <= b && (this._coreBrowserService.isFocused && (i3.options.cursorStyle || "block") === "block" || this._coreBrowserService.isFocused === false && i3.options.cursorInactiveStyle === "block") && (this._cellColorResolver.result.fg = 50331648 | this._themeService.colors.cursorAccent.rgba >> 8 & 16777215, this._cellColorResolver.result.bg = 50331648 | this._themeService.colors.cursor.rgba >> 8 & 16777215)), _2 !== u.NULL_CELL_CODE && (this._model.lineLengths[r2] = v2 + 1), (this._model.cells[g2] !== _2 || this._model.cells[g2 + f.RENDER_MODEL_BG_OFFSET] !== this._cellColorResolver.result.bg || this._model.cells[g2 + f.RENDER_MODEL_FG_OFFSET] !== this._cellColorResolver.result.fg || this._model.cells[g2 + f.RENDER_MODEL_EXT_OFFSET] !== this._cellColorResolver.result.ext) && (M = true, d2.length > 1 && (_2 |= f.COMBINED_CHAR_BIT_MASK), this._model.cells[g2] = _2, this._model.cells[g2 + f.RENDER_MODEL_BG_OFFSET] = this._cellColorResolver.result.bg, this._model.cells[g2 + f.RENDER_MODEL_FG_OFFSET] = this._cellColorResolver.result.fg, this._model.cells[g2 + f.RENDER_MODEL_EXT_OFFSET] = this._cellColorResolver.result.ext, this._glyphRenderer.value.updateCell(v2, r2, _2, this._cellColorResolver.result.bg, this._cellColorResolver.result.fg, this._cellColorResolver.result.ext, d2, s3), h2))
                for (C2 = this._workCell, v2++;v2 < l2; v2++)
                  p2 = (r2 * i3.cols + v2) * f.RENDER_MODEL_INDICIES_PER_CELL, this._glyphRenderer.value.updateCell(v2, r2, u.NULL_CELL_CODE, 0, 0, 0, u.NULL_CELL_CHAR, 0), this._model.cells[p2] = u.NULL_CELL_CODE, this._model.cells[p2 + f.RENDER_MODEL_BG_OFFSET] = this._cellColorResolver.result.bg, this._model.cells[p2 + f.RENDER_MODEL_FG_OFFSET] = this._cellColorResolver.result.fg, this._model.cells[p2 + f.RENDER_MODEL_EXT_OFFSET] = this._cellColorResolver.result.ext;
          M && this._rectangleRenderer.value.updateBackgrounds(this._model), this._rectangleRenderer.value.updateCursor(this._model);
        }
        _updateDimensions() {
          this._charSizeService.width && this._charSizeService.height && (this.dimensions.device.char.width = Math.floor(this._charSizeService.width * this._devicePixelRatio), this.dimensions.device.char.height = Math.ceil(this._charSizeService.height * this._devicePixelRatio), this.dimensions.device.cell.height = Math.floor(this.dimensions.device.char.height * this._optionsService.rawOptions.lineHeight), this.dimensions.device.char.top = this._optionsService.rawOptions.lineHeight === 1 ? 0 : Math.round((this.dimensions.device.cell.height - this.dimensions.device.char.height) / 2), this.dimensions.device.cell.width = this.dimensions.device.char.width + Math.round(this._optionsService.rawOptions.letterSpacing), this.dimensions.device.char.left = Math.floor(this._optionsService.rawOptions.letterSpacing / 2), this.dimensions.device.canvas.height = this._terminal.rows * this.dimensions.device.cell.height, this.dimensions.device.canvas.width = this._terminal.cols * this.dimensions.device.cell.width, this.dimensions.css.canvas.height = Math.round(this.dimensions.device.canvas.height / this._devicePixelRatio), this.dimensions.css.canvas.width = Math.round(this.dimensions.device.canvas.width / this._devicePixelRatio), this.dimensions.css.cell.height = this.dimensions.device.cell.height / this._devicePixelRatio, this.dimensions.css.cell.width = this.dimensions.device.cell.width / this._devicePixelRatio);
        }
        _setCanvasDevicePixelDimensions(e3, t3) {
          this._canvas.width === e3 && this._canvas.height === t3 || (this._canvas.width = e3, this._canvas.height = t3, this._requestRedrawViewport());
        }
        _requestRedrawViewport() {
          this._onRequestRedraw.fire({ start: 0, end: this._terminal.rows - 1 });
        }
        _requestRedrawCursor() {
          const e3 = this._terminal.buffer.active.cursorY;
          this._onRequestRedraw.fire({ start: e3, end: e3 });
        }
      }
      t2.WebglRenderer = C;

      class m extends d.AttributeData {
        constructor(e3, t3, i3) {
          super(), this.content = 0, this.combinedData = "", this.fg = e3.fg, this.bg = e3.bg, this.combinedData = t3, this._width = i3;
        }
        isCombined() {
          return 2097152;
        }
        getWidth() {
          return this._width;
        }
        getChars() {
          return this.combinedData;
        }
        getCode() {
          return 2097151;
        }
        setFromCharData(e3) {
          throw new Error("not implemented");
        }
        getAsCharData() {
          return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
        }
      }
      function L(e3, t3, i3 = 0) {
        return Math.max(Math.min(e3, t3), i3);
      }
      t2.JoinedCellData = m;
    }, 381: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.GLTexture = t2.expandFloat32Array = t2.createShader = t2.createProgram = t2.PROJECTION_MATRIX = undefined;
      const s2 = i2(374);
      function r(e3, t3, i3) {
        const r2 = (0, s2.throwIfFalsy)(e3.createShader(t3));
        if (e3.shaderSource(r2, i3), e3.compileShader(r2), e3.getShaderParameter(r2, e3.COMPILE_STATUS))
          return r2;
        console.error(e3.getShaderInfoLog(r2)), e3.deleteShader(r2);
      }
      t2.PROJECTION_MATRIX = new Float32Array([2, 0, 0, 0, 0, -2, 0, 0, 0, 0, 1, 0, -1, 1, 0, 1]), t2.createProgram = function(e3, t3, i3) {
        const o = (0, s2.throwIfFalsy)(e3.createProgram());
        if (e3.attachShader(o, (0, s2.throwIfFalsy)(r(e3, e3.VERTEX_SHADER, t3))), e3.attachShader(o, (0, s2.throwIfFalsy)(r(e3, e3.FRAGMENT_SHADER, i3))), e3.linkProgram(o), e3.getProgramParameter(o, e3.LINK_STATUS))
          return o;
        console.error(e3.getProgramInfoLog(o)), e3.deleteProgram(o);
      }, t2.createShader = r, t2.expandFloat32Array = function(e3, t3) {
        const i3 = Math.min(2 * e3.length, t3), s3 = new Float32Array(i3);
        for (let t4 = 0;t4 < e3.length; t4++)
          s3[t4] = e3[t4];
        return s3;
      }, t2.GLTexture = class {
        constructor(e3) {
          this.texture = e3, this.version = -1;
        }
      };
    }, 592: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.BaseRenderLayer = undefined;
      const s2 = i2(627), r = i2(237), o = i2(374), n = i2(859);

      class a extends n.Disposable {
        constructor(e3, t3, i3, s3, r2, o2, a2, h) {
          super(), this._container = t3, this._alpha = r2, this._coreBrowserService = o2, this._optionsService = a2, this._themeService = h, this._deviceCharWidth = 0, this._deviceCharHeight = 0, this._deviceCellWidth = 0, this._deviceCellHeight = 0, this._deviceCharLeft = 0, this._deviceCharTop = 0, this._canvas = this._coreBrowserService.mainDocument.createElement("canvas"), this._canvas.classList.add(`xterm-${i3}-layer`), this._canvas.style.zIndex = s3.toString(), this._initCanvas(), this._container.appendChild(this._canvas), this.register(this._themeService.onChangeColors((t4) => {
            this._refreshCharAtlas(e3, t4), this.reset(e3);
          })), this.register((0, n.toDisposable)(() => {
            this._canvas.remove();
          }));
        }
        _initCanvas() {
          this._ctx = (0, o.throwIfFalsy)(this._canvas.getContext("2d", { alpha: this._alpha })), this._alpha || this._clearAll();
        }
        handleBlur(e3) {
        }
        handleFocus(e3) {
        }
        handleCursorMove(e3) {
        }
        handleGridChanged(e3, t3, i3) {
        }
        handleSelectionChanged(e3, t3, i3, s3 = false) {
        }
        _setTransparency(e3, t3) {
          if (t3 === this._alpha)
            return;
          const i3 = this._canvas;
          this._alpha = t3, this._canvas = this._canvas.cloneNode(), this._initCanvas(), this._container.replaceChild(this._canvas, i3), this._refreshCharAtlas(e3, this._themeService.colors), this.handleGridChanged(e3, 0, e3.rows - 1);
        }
        _refreshCharAtlas(e3, t3) {
          this._deviceCharWidth <= 0 && this._deviceCharHeight <= 0 || (this._charAtlas = (0, s2.acquireTextureAtlas)(e3, this._optionsService.rawOptions, t3, this._deviceCellWidth, this._deviceCellHeight, this._deviceCharWidth, this._deviceCharHeight, this._coreBrowserService.dpr), this._charAtlas.warmUp());
        }
        resize(e3, t3) {
          this._deviceCellWidth = t3.device.cell.width, this._deviceCellHeight = t3.device.cell.height, this._deviceCharWidth = t3.device.char.width, this._deviceCharHeight = t3.device.char.height, this._deviceCharLeft = t3.device.char.left, this._deviceCharTop = t3.device.char.top, this._canvas.width = t3.device.canvas.width, this._canvas.height = t3.device.canvas.height, this._canvas.style.width = `${t3.css.canvas.width}px`, this._canvas.style.height = `${t3.css.canvas.height}px`, this._alpha || this._clearAll(), this._refreshCharAtlas(e3, this._themeService.colors);
        }
        _fillBottomLineAtCells(e3, t3, i3 = 1) {
          this._ctx.fillRect(e3 * this._deviceCellWidth, (t3 + 1) * this._deviceCellHeight - this._coreBrowserService.dpr - 1, i3 * this._deviceCellWidth, this._coreBrowserService.dpr);
        }
        _clearAll() {
          this._alpha ? this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height) : (this._ctx.fillStyle = this._themeService.colors.background.css, this._ctx.fillRect(0, 0, this._canvas.width, this._canvas.height));
        }
        _clearCells(e3, t3, i3, s3) {
          this._alpha ? this._ctx.clearRect(e3 * this._deviceCellWidth, t3 * this._deviceCellHeight, i3 * this._deviceCellWidth, s3 * this._deviceCellHeight) : (this._ctx.fillStyle = this._themeService.colors.background.css, this._ctx.fillRect(e3 * this._deviceCellWidth, t3 * this._deviceCellHeight, i3 * this._deviceCellWidth, s3 * this._deviceCellHeight));
        }
        _fillCharTrueColor(e3, t3, i3, s3) {
          this._ctx.font = this._getFont(e3, false, false), this._ctx.textBaseline = r.TEXT_BASELINE, this._clipCell(i3, s3, t3.getWidth()), this._ctx.fillText(t3.getChars(), i3 * this._deviceCellWidth + this._deviceCharLeft, s3 * this._deviceCellHeight + this._deviceCharTop + this._deviceCharHeight);
        }
        _clipCell(e3, t3, i3) {
          this._ctx.beginPath(), this._ctx.rect(e3 * this._deviceCellWidth, t3 * this._deviceCellHeight, i3 * this._deviceCellWidth, this._deviceCellHeight), this._ctx.clip();
        }
        _getFont(e3, t3, i3) {
          return `${i3 ? "italic" : ""} ${t3 ? e3.options.fontWeightBold : e3.options.fontWeight} ${e3.options.fontSize * this._coreBrowserService.dpr}px ${e3.options.fontFamily}`;
        }
      }
      t2.BaseRenderLayer = a;
    }, 733: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.LinkRenderLayer = undefined;
      const s2 = i2(197), r = i2(237), o = i2(592);

      class n extends o.BaseRenderLayer {
        constructor(e3, t3, i3, s3, r2, o2, n2) {
          super(i3, e3, "link", t3, true, r2, o2, n2), this.register(s3.onShowLinkUnderline((e4) => this._handleShowLinkUnderline(e4))), this.register(s3.onHideLinkUnderline((e4) => this._handleHideLinkUnderline(e4)));
        }
        resize(e3, t3) {
          super.resize(e3, t3), this._state = undefined;
        }
        reset(e3) {
          this._clearCurrentLink();
        }
        _clearCurrentLink() {
          if (this._state) {
            this._clearCells(this._state.x1, this._state.y1, this._state.cols - this._state.x1, 1);
            const e3 = this._state.y2 - this._state.y1 - 1;
            e3 > 0 && this._clearCells(0, this._state.y1 + 1, this._state.cols, e3), this._clearCells(0, this._state.y2, this._state.x2, 1), this._state = undefined;
          }
        }
        _handleShowLinkUnderline(e3) {
          if (e3.fg === r.INVERTED_DEFAULT_COLOR ? this._ctx.fillStyle = this._themeService.colors.background.css : e3.fg !== undefined && (0, s2.is256Color)(e3.fg) ? this._ctx.fillStyle = this._themeService.colors.ansi[e3.fg].css : this._ctx.fillStyle = this._themeService.colors.foreground.css, e3.y1 === e3.y2)
            this._fillBottomLineAtCells(e3.x1, e3.y1, e3.x2 - e3.x1);
          else {
            this._fillBottomLineAtCells(e3.x1, e3.y1, e3.cols - e3.x1);
            for (let t3 = e3.y1 + 1;t3 < e3.y2; t3++)
              this._fillBottomLineAtCells(0, t3, e3.cols);
            this._fillBottomLineAtCells(0, e3.y2, e3.x2);
          }
          this._state = e3;
        }
        _handleHideLinkUnderline(e3) {
          this._clearCurrentLink();
        }
      }
      t2.LinkRenderLayer = n;
    }, 820: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.addDisposableDomListener = undefined, t2.addDisposableDomListener = function(e3, t3, i2, s2) {
        e3.addEventListener(t3, i2, s2);
        let r = false;
        return { dispose: () => {
          r || (r = true, e3.removeEventListener(t3, i2, s2));
        } };
      };
    }, 274: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.CellColorResolver = undefined;
      let i2, s2 = 0, r = 0, o = false, n = false, a = false;
      t2.CellColorResolver = class {
        constructor(e3, t3, i3, s3, r2) {
          this._terminal = e3, this._selectionRenderModel = t3, this._decorationService = i3, this._coreBrowserService = s3, this._themeService = r2, this.result = { fg: 0, bg: 0, ext: 0 };
        }
        resolve(e3, t3, h) {
          this.result.bg = e3.bg, this.result.fg = e3.fg, this.result.ext = 268435456 & e3.bg ? e3.extended.ext : 0, r = 0, s2 = 0, n = false, o = false, a = false, i2 = this._themeService.colors, this._decorationService.forEachDecorationAtCell(t3, h, "bottom", (e4) => {
            e4.backgroundColorRGB && (r = e4.backgroundColorRGB.rgba >> 8 & 16777215, n = true), e4.foregroundColorRGB && (s2 = e4.foregroundColorRGB.rgba >> 8 & 16777215, o = true);
          }), a = this._selectionRenderModel.isCellSelected(this._terminal, t3, h), a && (r = (this._coreBrowserService.isFocused ? i2.selectionBackgroundOpaque : i2.selectionInactiveBackgroundOpaque).rgba >> 8 & 16777215, n = true, i2.selectionForeground && (s2 = i2.selectionForeground.rgba >> 8 & 16777215, o = true)), this._decorationService.forEachDecorationAtCell(t3, h, "top", (e4) => {
            e4.backgroundColorRGB && (r = e4.backgroundColorRGB.rgba >> 8 & 16777215, n = true), e4.foregroundColorRGB && (s2 = e4.foregroundColorRGB.rgba >> 8 & 16777215, o = true);
          }), n && (r = a ? -16777216 & e3.bg & -134217729 | r | 50331648 : -16777216 & e3.bg | r | 50331648), o && (s2 = -16777216 & e3.fg & -67108865 | s2 | 50331648), 67108864 & this.result.fg && (n && !o && (s2 = (50331648 & this.result.bg) == 0 ? -134217728 & this.result.fg | 16777215 & i2.background.rgba >> 8 | 50331648 : -134217728 & this.result.fg | 67108863 & this.result.bg, o = true), !n && o && (r = (50331648 & this.result.fg) == 0 ? -67108864 & this.result.bg | 16777215 & i2.foreground.rgba >> 8 | 50331648 : -67108864 & this.result.bg | 67108863 & this.result.fg, n = true)), i2 = undefined, this.result.bg = n ? r : this.result.bg, this.result.fg = o ? s2 : this.result.fg;
        }
      };
    }, 627: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.removeTerminalFromCache = t2.acquireTextureAtlas = undefined;
      const s2 = i2(509), r = i2(197), o = [];
      t2.acquireTextureAtlas = function(e3, t3, i3, n, a, h, l, c) {
        const d = (0, r.generateConfig)(n, a, h, l, t3, i3, c);
        for (let t4 = 0;t4 < o.length; t4++) {
          const i4 = o[t4], s3 = i4.ownedBy.indexOf(e3);
          if (s3 >= 0) {
            if ((0, r.configEquals)(i4.config, d))
              return i4.atlas;
            i4.ownedBy.length === 1 ? (i4.atlas.dispose(), o.splice(t4, 1)) : i4.ownedBy.splice(s3, 1);
            break;
          }
        }
        for (let t4 = 0;t4 < o.length; t4++) {
          const i4 = o[t4];
          if ((0, r.configEquals)(i4.config, d))
            return i4.ownedBy.push(e3), i4.atlas;
        }
        const _ = e3._core, u = { atlas: new s2.TextureAtlas(document, d, _.unicodeService), config: d, ownedBy: [e3] };
        return o.push(u), u.atlas;
      }, t2.removeTerminalFromCache = function(e3) {
        for (let t3 = 0;t3 < o.length; t3++) {
          const i3 = o[t3].ownedBy.indexOf(e3);
          if (i3 !== -1) {
            o[t3].ownedBy.length === 1 ? (o[t3].atlas.dispose(), o.splice(t3, 1)) : o[t3].ownedBy.splice(i3, 1);
            break;
          }
        }
      };
    }, 197: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.is256Color = t2.configEquals = t2.generateConfig = undefined;
      const s2 = i2(160);
      t2.generateConfig = function(e3, t3, i3, r, o, n, a) {
        const h = { foreground: n.foreground, background: n.background, cursor: s2.NULL_COLOR, cursorAccent: s2.NULL_COLOR, selectionForeground: s2.NULL_COLOR, selectionBackgroundTransparent: s2.NULL_COLOR, selectionBackgroundOpaque: s2.NULL_COLOR, selectionInactiveBackgroundTransparent: s2.NULL_COLOR, selectionInactiveBackgroundOpaque: s2.NULL_COLOR, ansi: n.ansi.slice(), contrastCache: n.contrastCache, halfContrastCache: n.halfContrastCache };
        return { customGlyphs: o.customGlyphs, devicePixelRatio: a, letterSpacing: o.letterSpacing, lineHeight: o.lineHeight, deviceCellWidth: e3, deviceCellHeight: t3, deviceCharWidth: i3, deviceCharHeight: r, fontFamily: o.fontFamily, fontSize: o.fontSize, fontWeight: o.fontWeight, fontWeightBold: o.fontWeightBold, allowTransparency: o.allowTransparency, drawBoldTextInBrightColors: o.drawBoldTextInBrightColors, minimumContrastRatio: o.minimumContrastRatio, colors: h };
      }, t2.configEquals = function(e3, t3) {
        for (let i3 = 0;i3 < e3.colors.ansi.length; i3++)
          if (e3.colors.ansi[i3].rgba !== t3.colors.ansi[i3].rgba)
            return false;
        return e3.devicePixelRatio === t3.devicePixelRatio && e3.customGlyphs === t3.customGlyphs && e3.lineHeight === t3.lineHeight && e3.letterSpacing === t3.letterSpacing && e3.fontFamily === t3.fontFamily && e3.fontSize === t3.fontSize && e3.fontWeight === t3.fontWeight && e3.fontWeightBold === t3.fontWeightBold && e3.allowTransparency === t3.allowTransparency && e3.deviceCharWidth === t3.deviceCharWidth && e3.deviceCharHeight === t3.deviceCharHeight && e3.drawBoldTextInBrightColors === t3.drawBoldTextInBrightColors && e3.minimumContrastRatio === t3.minimumContrastRatio && e3.colors.foreground.rgba === t3.colors.foreground.rgba && e3.colors.background.rgba === t3.colors.background.rgba;
      }, t2.is256Color = function(e3) {
        return (50331648 & e3) == 16777216 || (50331648 & e3) == 33554432;
      };
    }, 237: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.TEXT_BASELINE = t2.DIM_OPACITY = t2.INVERTED_DEFAULT_COLOR = undefined;
      const s2 = i2(399);
      t2.INVERTED_DEFAULT_COLOR = 257, t2.DIM_OPACITY = 0.5, t2.TEXT_BASELINE = s2.isFirefox || s2.isLegacyEdge ? "bottom" : "ideographic";
    }, 457: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.CursorBlinkStateManager = undefined;
      t2.CursorBlinkStateManager = class {
        constructor(e3, t3) {
          this._renderCallback = e3, this._coreBrowserService = t3, this.isCursorVisible = true, this._coreBrowserService.isFocused && this._restartInterval();
        }
        get isPaused() {
          return !(this._blinkStartTimeout || this._blinkInterval);
        }
        dispose() {
          this._blinkInterval && (this._coreBrowserService.window.clearInterval(this._blinkInterval), this._blinkInterval = undefined), this._blinkStartTimeout && (this._coreBrowserService.window.clearTimeout(this._blinkStartTimeout), this._blinkStartTimeout = undefined), this._animationFrame && (this._coreBrowserService.window.cancelAnimationFrame(this._animationFrame), this._animationFrame = undefined);
        }
        restartBlinkAnimation() {
          this.isPaused || (this._animationTimeRestarted = Date.now(), this.isCursorVisible = true, this._animationFrame || (this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(() => {
            this._renderCallback(), this._animationFrame = undefined;
          })));
        }
        _restartInterval(e3 = 600) {
          this._blinkInterval && (this._coreBrowserService.window.clearInterval(this._blinkInterval), this._blinkInterval = undefined), this._blinkStartTimeout = this._coreBrowserService.window.setTimeout(() => {
            if (this._animationTimeRestarted) {
              const e4 = 600 - (Date.now() - this._animationTimeRestarted);
              if (this._animationTimeRestarted = undefined, e4 > 0)
                return void this._restartInterval(e4);
            }
            this.isCursorVisible = false, this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(() => {
              this._renderCallback(), this._animationFrame = undefined;
            }), this._blinkInterval = this._coreBrowserService.window.setInterval(() => {
              if (this._animationTimeRestarted) {
                const e4 = 600 - (Date.now() - this._animationTimeRestarted);
                return this._animationTimeRestarted = undefined, void this._restartInterval(e4);
              }
              this.isCursorVisible = !this.isCursorVisible, this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(() => {
                this._renderCallback(), this._animationFrame = undefined;
              });
            }, 600);
          }, e3);
        }
        pause() {
          this.isCursorVisible = true, this._blinkInterval && (this._coreBrowserService.window.clearInterval(this._blinkInterval), this._blinkInterval = undefined), this._blinkStartTimeout && (this._coreBrowserService.window.clearTimeout(this._blinkStartTimeout), this._blinkStartTimeout = undefined), this._animationFrame && (this._coreBrowserService.window.cancelAnimationFrame(this._animationFrame), this._animationFrame = undefined);
        }
        resume() {
          this.pause(), this._animationTimeRestarted = undefined, this._restartInterval(), this.restartBlinkAnimation();
        }
      };
    }, 860: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.tryDrawCustomChar = t2.powerlineDefinitions = t2.boxDrawingDefinitions = t2.blockElementDefinitions = undefined;
      const s2 = i2(374);
      t2.blockElementDefinitions = { "\u2580": [{ x: 0, y: 0, w: 8, h: 4 }], "\u2581": [{ x: 0, y: 7, w: 8, h: 1 }], "\u2582": [{ x: 0, y: 6, w: 8, h: 2 }], "\u2583": [{ x: 0, y: 5, w: 8, h: 3 }], "\u2584": [{ x: 0, y: 4, w: 8, h: 4 }], "\u2585": [{ x: 0, y: 3, w: 8, h: 5 }], "\u2586": [{ x: 0, y: 2, w: 8, h: 6 }], "\u2587": [{ x: 0, y: 1, w: 8, h: 7 }], "\u2588": [{ x: 0, y: 0, w: 8, h: 8 }], "\u2589": [{ x: 0, y: 0, w: 7, h: 8 }], "\u258A": [{ x: 0, y: 0, w: 6, h: 8 }], "\u258B": [{ x: 0, y: 0, w: 5, h: 8 }], "\u258C": [{ x: 0, y: 0, w: 4, h: 8 }], "\u258D": [{ x: 0, y: 0, w: 3, h: 8 }], "\u258E": [{ x: 0, y: 0, w: 2, h: 8 }], "\u258F": [{ x: 0, y: 0, w: 1, h: 8 }], "\u2590": [{ x: 4, y: 0, w: 4, h: 8 }], "\u2594": [{ x: 0, y: 0, w: 8, h: 1 }], "\u2595": [{ x: 7, y: 0, w: 1, h: 8 }], "\u2596": [{ x: 0, y: 4, w: 4, h: 4 }], "\u2597": [{ x: 4, y: 4, w: 4, h: 4 }], "\u2598": [{ x: 0, y: 0, w: 4, h: 4 }], "\u2599": [{ x: 0, y: 0, w: 4, h: 8 }, { x: 0, y: 4, w: 8, h: 4 }], "\u259A": [{ x: 0, y: 0, w: 4, h: 4 }, { x: 4, y: 4, w: 4, h: 4 }], "\u259B": [{ x: 0, y: 0, w: 4, h: 8 }, { x: 4, y: 0, w: 4, h: 4 }], "\u259C": [{ x: 0, y: 0, w: 8, h: 4 }, { x: 4, y: 0, w: 4, h: 8 }], "\u259D": [{ x: 4, y: 0, w: 4, h: 4 }], "\u259E": [{ x: 4, y: 0, w: 4, h: 4 }, { x: 0, y: 4, w: 4, h: 4 }], "\u259F": [{ x: 4, y: 0, w: 4, h: 8 }, { x: 0, y: 4, w: 8, h: 4 }], "\uD83E\uDF70": [{ x: 1, y: 0, w: 1, h: 8 }], "\uD83E\uDF71": [{ x: 2, y: 0, w: 1, h: 8 }], "\uD83E\uDF72": [{ x: 3, y: 0, w: 1, h: 8 }], "\uD83E\uDF73": [{ x: 4, y: 0, w: 1, h: 8 }], "\uD83E\uDF74": [{ x: 5, y: 0, w: 1, h: 8 }], "\uD83E\uDF75": [{ x: 6, y: 0, w: 1, h: 8 }], "\uD83E\uDF76": [{ x: 0, y: 1, w: 8, h: 1 }], "\uD83E\uDF77": [{ x: 0, y: 2, w: 8, h: 1 }], "\uD83E\uDF78": [{ x: 0, y: 3, w: 8, h: 1 }], "\uD83E\uDF79": [{ x: 0, y: 4, w: 8, h: 1 }], "\uD83E\uDF7A": [{ x: 0, y: 5, w: 8, h: 1 }], "\uD83E\uDF7B": [{ x: 0, y: 6, w: 8, h: 1 }], "\uD83E\uDF7C": [{ x: 0, y: 0, w: 1, h: 8 }, { x: 0, y: 7, w: 8, h: 1 }], "\uD83E\uDF7D": [{ x: 0, y: 0, w: 1, h: 8 }, { x: 0, y: 0, w: 8, h: 1 }], "\uD83E\uDF7E": [{ x: 7, y: 0, w: 1, h: 8 }, { x: 0, y: 0, w: 8, h: 1 }], "\uD83E\uDF7F": [{ x: 7, y: 0, w: 1, h: 8 }, { x: 0, y: 7, w: 8, h: 1 }], "\uD83E\uDF80": [{ x: 0, y: 0, w: 8, h: 1 }, { x: 0, y: 7, w: 8, h: 1 }], "\uD83E\uDF81": [{ x: 0, y: 0, w: 8, h: 1 }, { x: 0, y: 2, w: 8, h: 1 }, { x: 0, y: 4, w: 8, h: 1 }, { x: 0, y: 7, w: 8, h: 1 }], "\uD83E\uDF82": [{ x: 0, y: 0, w: 8, h: 2 }], "\uD83E\uDF83": [{ x: 0, y: 0, w: 8, h: 3 }], "\uD83E\uDF84": [{ x: 0, y: 0, w: 8, h: 5 }], "\uD83E\uDF85": [{ x: 0, y: 0, w: 8, h: 6 }], "\uD83E\uDF86": [{ x: 0, y: 0, w: 8, h: 7 }], "\uD83E\uDF87": [{ x: 6, y: 0, w: 2, h: 8 }], "\uD83E\uDF88": [{ x: 5, y: 0, w: 3, h: 8 }], "\uD83E\uDF89": [{ x: 3, y: 0, w: 5, h: 8 }], "\uD83E\uDF8A": [{ x: 2, y: 0, w: 6, h: 8 }], "\uD83E\uDF8B": [{ x: 1, y: 0, w: 7, h: 8 }], "\uD83E\uDF95": [{ x: 0, y: 0, w: 2, h: 2 }, { x: 4, y: 0, w: 2, h: 2 }, { x: 2, y: 2, w: 2, h: 2 }, { x: 6, y: 2, w: 2, h: 2 }, { x: 0, y: 4, w: 2, h: 2 }, { x: 4, y: 4, w: 2, h: 2 }, { x: 2, y: 6, w: 2, h: 2 }, { x: 6, y: 6, w: 2, h: 2 }], "\uD83E\uDF96": [{ x: 2, y: 0, w: 2, h: 2 }, { x: 6, y: 0, w: 2, h: 2 }, { x: 0, y: 2, w: 2, h: 2 }, { x: 4, y: 2, w: 2, h: 2 }, { x: 2, y: 4, w: 2, h: 2 }, { x: 6, y: 4, w: 2, h: 2 }, { x: 0, y: 6, w: 2, h: 2 }, { x: 4, y: 6, w: 2, h: 2 }], "\uD83E\uDF97": [{ x: 0, y: 2, w: 8, h: 2 }, { x: 0, y: 6, w: 8, h: 2 }] };
      const r = { "\u2591": [[1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 0]], "\u2592": [[1, 0], [0, 0], [0, 1], [0, 0]], "\u2593": [[0, 1], [1, 1], [1, 0], [1, 1]] };
      t2.boxDrawingDefinitions = { "\u2500": { 1: "M0,.5 L1,.5" }, "\u2501": { 3: "M0,.5 L1,.5" }, "\u2502": { 1: "M.5,0 L.5,1" }, "\u2503": { 3: "M.5,0 L.5,1" }, "\u250C": { 1: "M0.5,1 L.5,.5 L1,.5" }, "\u250F": { 3: "M0.5,1 L.5,.5 L1,.5" }, "\u2510": { 1: "M0,.5 L.5,.5 L.5,1" }, "\u2513": { 3: "M0,.5 L.5,.5 L.5,1" }, "\u2514": { 1: "M.5,0 L.5,.5 L1,.5" }, "\u2517": { 3: "M.5,0 L.5,.5 L1,.5" }, "\u2518": { 1: "M.5,0 L.5,.5 L0,.5" }, "\u251B": { 3: "M.5,0 L.5,.5 L0,.5" }, "\u251C": { 1: "M.5,0 L.5,1 M.5,.5 L1,.5" }, "\u2523": { 3: "M.5,0 L.5,1 M.5,.5 L1,.5" }, "\u2524": { 1: "M.5,0 L.5,1 M.5,.5 L0,.5" }, "\u252B": { 3: "M.5,0 L.5,1 M.5,.5 L0,.5" }, "\u252C": { 1: "M0,.5 L1,.5 M.5,.5 L.5,1" }, "\u2533": { 3: "M0,.5 L1,.5 M.5,.5 L.5,1" }, "\u2534": { 1: "M0,.5 L1,.5 M.5,.5 L.5,0" }, "\u253B": { 3: "M0,.5 L1,.5 M.5,.5 L.5,0" }, "\u253C": { 1: "M0,.5 L1,.5 M.5,0 L.5,1" }, "\u254B": { 3: "M0,.5 L1,.5 M.5,0 L.5,1" }, "\u2574": { 1: "M.5,.5 L0,.5" }, "\u2578": { 3: "M.5,.5 L0,.5" }, "\u2575": { 1: "M.5,.5 L.5,0" }, "\u2579": { 3: "M.5,.5 L.5,0" }, "\u2576": { 1: "M.5,.5 L1,.5" }, "\u257A": { 3: "M.5,.5 L1,.5" }, "\u2577": { 1: "M.5,.5 L.5,1" }, "\u257B": { 3: "M.5,.5 L.5,1" }, "\u2550": { 1: (e3, t3) => `M0,${0.5 - t3} L1,${0.5 - t3} M0,${0.5 + t3} L1,${0.5 + t3}` }, "\u2551": { 1: (e3, t3) => `M${0.5 - e3},0 L${0.5 - e3},1 M${0.5 + e3},0 L${0.5 + e3},1` }, "\u2552": { 1: (e3, t3) => `M.5,1 L.5,${0.5 - t3} L1,${0.5 - t3} M.5,${0.5 + t3} L1,${0.5 + t3}` }, "\u2553": { 1: (e3, t3) => `M${0.5 - e3},1 L${0.5 - e3},.5 L1,.5 M${0.5 + e3},.5 L${0.5 + e3},1` }, "\u2554": { 1: (e3, t3) => `M1,${0.5 - t3} L${0.5 - e3},${0.5 - t3} L${0.5 - e3},1 M1,${0.5 + t3} L${0.5 + e3},${0.5 + t3} L${0.5 + e3},1` }, "\u2555": { 1: (e3, t3) => `M0,${0.5 - t3} L.5,${0.5 - t3} L.5,1 M0,${0.5 + t3} L.5,${0.5 + t3}` }, "\u2556": { 1: (e3, t3) => `M${0.5 + e3},1 L${0.5 + e3},.5 L0,.5 M${0.5 - e3},.5 L${0.5 - e3},1` }, "\u2557": { 1: (e3, t3) => `M0,${0.5 + t3} L${0.5 - e3},${0.5 + t3} L${0.5 - e3},1 M0,${0.5 - t3} L${0.5 + e3},${0.5 - t3} L${0.5 + e3},1` }, "\u2558": { 1: (e3, t3) => `M.5,0 L.5,${0.5 + t3} L1,${0.5 + t3} M.5,${0.5 - t3} L1,${0.5 - t3}` }, "\u2559": { 1: (e3, t3) => `M1,.5 L${0.5 - e3},.5 L${0.5 - e3},0 M${0.5 + e3},.5 L${0.5 + e3},0` }, "\u255A": { 1: (e3, t3) => `M1,${0.5 - t3} L${0.5 + e3},${0.5 - t3} L${0.5 + e3},0 M1,${0.5 + t3} L${0.5 - e3},${0.5 + t3} L${0.5 - e3},0` }, "\u255B": { 1: (e3, t3) => `M0,${0.5 + t3} L.5,${0.5 + t3} L.5,0 M0,${0.5 - t3} L.5,${0.5 - t3}` }, "\u255C": { 1: (e3, t3) => `M0,.5 L${0.5 + e3},.5 L${0.5 + e3},0 M${0.5 - e3},.5 L${0.5 - e3},0` }, "\u255D": { 1: (e3, t3) => `M0,${0.5 - t3} L${0.5 - e3},${0.5 - t3} L${0.5 - e3},0 M0,${0.5 + t3} L${0.5 + e3},${0.5 + t3} L${0.5 + e3},0` }, "\u255E": { 1: (e3, t3) => `M.5,0 L.5,1 M.5,${0.5 - t3} L1,${0.5 - t3} M.5,${0.5 + t3} L1,${0.5 + t3}` }, "\u255F": { 1: (e3, t3) => `M${0.5 - e3},0 L${0.5 - e3},1 M${0.5 + e3},0 L${0.5 + e3},1 M${0.5 + e3},.5 L1,.5` }, "\u2560": { 1: (e3, t3) => `M${0.5 - e3},0 L${0.5 - e3},1 M1,${0.5 + t3} L${0.5 + e3},${0.5 + t3} L${0.5 + e3},1 M1,${0.5 - t3} L${0.5 + e3},${0.5 - t3} L${0.5 + e3},0` }, "\u2561": { 1: (e3, t3) => `M.5,0 L.5,1 M0,${0.5 - t3} L.5,${0.5 - t3} M0,${0.5 + t3} L.5,${0.5 + t3}` }, "\u2562": { 1: (e3, t3) => `M0,.5 L${0.5 - e3},.5 M${0.5 - e3},0 L${0.5 - e3},1 M${0.5 + e3},0 L${0.5 + e3},1` }, "\u2563": { 1: (e3, t3) => `M${0.5 + e3},0 L${0.5 + e3},1 M0,${0.5 + t3} L${0.5 - e3},${0.5 + t3} L${0.5 - e3},1 M0,${0.5 - t3} L${0.5 - e3},${0.5 - t3} L${0.5 - e3},0` }, "\u2564": { 1: (e3, t3) => `M0,${0.5 - t3} L1,${0.5 - t3} M0,${0.5 + t3} L1,${0.5 + t3} M.5,${0.5 + t3} L.5,1` }, "\u2565": { 1: (e3, t3) => `M0,.5 L1,.5 M${0.5 - e3},.5 L${0.5 - e3},1 M${0.5 + e3},.5 L${0.5 + e3},1` }, "\u2566": { 1: (e3, t3) => `M0,${0.5 - t3} L1,${0.5 - t3} M0,${0.5 + t3} L${0.5 - e3},${0.5 + t3} L${0.5 - e3},1 M1,${0.5 + t3} L${0.5 + e3},${0.5 + t3} L${0.5 + e3},1` }, "\u2567": { 1: (e3, t3) => `M.5,0 L.5,${0.5 - t3} M0,${0.5 - t3} L1,${0.5 - t3} M0,${0.5 + t3} L1,${0.5 + t3}` }, "\u2568": { 1: (e3, t3) => `M0,.5 L1,.5 M${0.5 - e3},.5 L${0.5 - e3},0 M${0.5 + e3},.5 L${0.5 + e3},0` }, "\u2569": { 1: (e3, t3) => `M0,${0.5 + t3} L1,${0.5 + t3} M0,${0.5 - t3} L${0.5 - e3},${0.5 - t3} L${0.5 - e3},0 M1,${0.5 - t3} L${0.5 + e3},${0.5 - t3} L${0.5 + e3},0` }, "\u256A": { 1: (e3, t3) => `M.5,0 L.5,1 M0,${0.5 - t3} L1,${0.5 - t3} M0,${0.5 + t3} L1,${0.5 + t3}` }, "\u256B": { 1: (e3, t3) => `M0,.5 L1,.5 M${0.5 - e3},0 L${0.5 - e3},1 M${0.5 + e3},0 L${0.5 + e3},1` }, "\u256C": { 1: (e3, t3) => `M0,${0.5 + t3} L${0.5 - e3},${0.5 + t3} L${0.5 - e3},1 M1,${0.5 + t3} L${0.5 + e3},${0.5 + t3} L${0.5 + e3},1 M0,${0.5 - t3} L${0.5 - e3},${0.5 - t3} L${0.5 - e3},0 M1,${0.5 - t3} L${0.5 + e3},${0.5 - t3} L${0.5 + e3},0` }, "\u2571": { 1: "M1,0 L0,1" }, "\u2572": { 1: "M0,0 L1,1" }, "\u2573": { 1: "M1,0 L0,1 M0,0 L1,1" }, "\u257C": { 1: "M.5,.5 L0,.5", 3: "M.5,.5 L1,.5" }, "\u257D": { 1: "M.5,.5 L.5,0", 3: "M.5,.5 L.5,1" }, "\u257E": { 1: "M.5,.5 L1,.5", 3: "M.5,.5 L0,.5" }, "\u257F": { 1: "M.5,.5 L.5,1", 3: "M.5,.5 L.5,0" }, "\u250D": { 1: "M.5,.5 L.5,1", 3: "M.5,.5 L1,.5" }, "\u250E": { 1: "M.5,.5 L1,.5", 3: "M.5,.5 L.5,1" }, "\u2511": { 1: "M.5,.5 L.5,1", 3: "M.5,.5 L0,.5" }, "\u2512": { 1: "M.5,.5 L0,.5", 3: "M.5,.5 L.5,1" }, "\u2515": { 1: "M.5,.5 L.5,0", 3: "M.5,.5 L1,.5" }, "\u2516": { 1: "M.5,.5 L1,.5", 3: "M.5,.5 L.5,0" }, "\u2519": { 1: "M.5,.5 L.5,0", 3: "M.5,.5 L0,.5" }, "\u251A": { 1: "M.5,.5 L0,.5", 3: "M.5,.5 L.5,0" }, "\u251D": { 1: "M.5,0 L.5,1", 3: "M.5,.5 L1,.5" }, "\u251E": { 1: "M0.5,1 L.5,.5 L1,.5", 3: "M.5,.5 L.5,0" }, "\u251F": { 1: "M.5,0 L.5,.5 L1,.5", 3: "M.5,.5 L.5,1" }, "\u2520": { 1: "M.5,.5 L1,.5", 3: "M.5,0 L.5,1" }, "\u2521": { 1: "M.5,.5 L.5,1", 3: "M.5,0 L.5,.5 L1,.5" }, "\u2522": { 1: "M.5,.5 L.5,0", 3: "M0.5,1 L.5,.5 L1,.5" }, "\u2525": { 1: "M.5,0 L.5,1", 3: "M.5,.5 L0,.5" }, "\u2526": { 1: "M0,.5 L.5,.5 L.5,1", 3: "M.5,.5 L.5,0" }, "\u2527": { 1: "M.5,0 L.5,.5 L0,.5", 3: "M.5,.5 L.5,1" }, "\u2528": { 1: "M.5,.5 L0,.5", 3: "M.5,0 L.5,1" }, "\u2529": { 1: "M.5,.5 L.5,1", 3: "M.5,0 L.5,.5 L0,.5" }, "\u252A": { 1: "M.5,.5 L.5,0", 3: "M0,.5 L.5,.5 L.5,1" }, "\u252D": { 1: "M0.5,1 L.5,.5 L1,.5", 3: "M.5,.5 L0,.5" }, "\u252E": { 1: "M0,.5 L.5,.5 L.5,1", 3: "M.5,.5 L1,.5" }, "\u252F": { 1: "M.5,.5 L.5,1", 3: "M0,.5 L1,.5" }, "\u2530": { 1: "M0,.5 L1,.5", 3: "M.5,.5 L.5,1" }, "\u2531": { 1: "M.5,.5 L1,.5", 3: "M0,.5 L.5,.5 L.5,1" }, "\u2532": { 1: "M.5,.5 L0,.5", 3: "M0.5,1 L.5,.5 L1,.5" }, "\u2535": { 1: "M.5,0 L.5,.5 L1,.5", 3: "M.5,.5 L0,.5" }, "\u2536": { 1: "M.5,0 L.5,.5 L0,.5", 3: "M.5,.5 L1,.5" }, "\u2537": { 1: "M.5,.5 L.5,0", 3: "M0,.5 L1,.5" }, "\u2538": { 1: "M0,.5 L1,.5", 3: "M.5,.5 L.5,0" }, "\u2539": { 1: "M.5,.5 L1,.5", 3: "M.5,0 L.5,.5 L0,.5" }, "\u253A": { 1: "M.5,.5 L0,.5", 3: "M.5,0 L.5,.5 L1,.5" }, "\u253D": { 1: "M.5,0 L.5,1 M.5,.5 L1,.5", 3: "M.5,.5 L0,.5" }, "\u253E": { 1: "M.5,0 L.5,1 M.5,.5 L0,.5", 3: "M.5,.5 L1,.5" }, "\u253F": { 1: "M.5,0 L.5,1", 3: "M0,.5 L1,.5" }, "\u2540": { 1: "M0,.5 L1,.5 M.5,.5 L.5,1", 3: "M.5,.5 L.5,0" }, "\u2541": { 1: "M.5,.5 L.5,0 M0,.5 L1,.5", 3: "M.5,.5 L.5,1" }, "\u2542": { 1: "M0,.5 L1,.5", 3: "M.5,0 L.5,1" }, "\u2543": { 1: "M0.5,1 L.5,.5 L1,.5", 3: "M.5,0 L.5,.5 L0,.5" }, "\u2544": { 1: "M0,.5 L.5,.5 L.5,1", 3: "M.5,0 L.5,.5 L1,.5" }, "\u2545": { 1: "M.5,0 L.5,.5 L1,.5", 3: "M0,.5 L.5,.5 L.5,1" }, "\u2546": { 1: "M.5,0 L.5,.5 L0,.5", 3: "M0.5,1 L.5,.5 L1,.5" }, "\u2547": { 1: "M.5,.5 L.5,1", 3: "M.5,.5 L.5,0 M0,.5 L1,.5" }, "\u2548": { 1: "M.5,.5 L.5,0", 3: "M0,.5 L1,.5 M.5,.5 L.5,1" }, "\u2549": { 1: "M.5,.5 L1,.5", 3: "M.5,0 L.5,1 M.5,.5 L0,.5" }, "\u254A": { 1: "M.5,.5 L0,.5", 3: "M.5,0 L.5,1 M.5,.5 L1,.5" }, "\u254C": { 1: "M.1,.5 L.4,.5 M.6,.5 L.9,.5" }, "\u254D": { 3: "M.1,.5 L.4,.5 M.6,.5 L.9,.5" }, "\u2504": { 1: "M.0667,.5 L.2667,.5 M.4,.5 L.6,.5 M.7333,.5 L.9333,.5" }, "\u2505": { 3: "M.0667,.5 L.2667,.5 M.4,.5 L.6,.5 M.7333,.5 L.9333,.5" }, "\u2508": { 1: "M.05,.5 L.2,.5 M.3,.5 L.45,.5 M.55,.5 L.7,.5 M.8,.5 L.95,.5" }, "\u2509": { 3: "M.05,.5 L.2,.5 M.3,.5 L.45,.5 M.55,.5 L.7,.5 M.8,.5 L.95,.5" }, "\u254E": { 1: "M.5,.1 L.5,.4 M.5,.6 L.5,.9" }, "\u254F": { 3: "M.5,.1 L.5,.4 M.5,.6 L.5,.9" }, "\u2506": { 1: "M.5,.0667 L.5,.2667 M.5,.4 L.5,.6 M.5,.7333 L.5,.9333" }, "\u2507": { 3: "M.5,.0667 L.5,.2667 M.5,.4 L.5,.6 M.5,.7333 L.5,.9333" }, "\u250A": { 1: "M.5,.05 L.5,.2 M.5,.3 L.5,.45 L.5,.55 M.5,.7 L.5,.95" }, "\u250B": { 3: "M.5,.05 L.5,.2 M.5,.3 L.5,.45 L.5,.55 M.5,.7 L.5,.95" }, "\u256D": { 1: (e3, t3) => `M.5,1 L.5,${0.5 + t3 / 0.15 * 0.5} C.5,${0.5 + t3 / 0.15 * 0.5},.5,.5,1,.5` }, "\u256E": { 1: (e3, t3) => `M.5,1 L.5,${0.5 + t3 / 0.15 * 0.5} C.5,${0.5 + t3 / 0.15 * 0.5},.5,.5,0,.5` }, "\u256F": { 1: (e3, t3) => `M.5,0 L.5,${0.5 - t3 / 0.15 * 0.5} C.5,${0.5 - t3 / 0.15 * 0.5},.5,.5,0,.5` }, "\u2570": { 1: (e3, t3) => `M.5,0 L.5,${0.5 - t3 / 0.15 * 0.5} C.5,${0.5 - t3 / 0.15 * 0.5},.5,.5,1,.5` } }, t2.powerlineDefinitions = { "\uE0B0": { d: "M0,0 L1,.5 L0,1", type: 0, rightPadding: 2 }, "\uE0B1": { d: "M-1,-.5 L1,.5 L-1,1.5", type: 1, leftPadding: 1, rightPadding: 1 }, "\uE0B2": { d: "M1,0 L0,.5 L1,1", type: 0, leftPadding: 2 }, "\uE0B3": { d: "M2,-.5 L0,.5 L2,1.5", type: 1, leftPadding: 1, rightPadding: 1 }, "\uE0B4": { d: "M0,0 L0,1 C0.552,1,1,0.776,1,.5 C1,0.224,0.552,0,0,0", type: 0, rightPadding: 1 }, "\uE0B5": { d: "M.2,1 C.422,1,.8,.826,.78,.5 C.8,.174,0.422,0,.2,0", type: 1, rightPadding: 1 }, "\uE0B6": { d: "M1,0 L1,1 C0.448,1,0,0.776,0,.5 C0,0.224,0.448,0,1,0", type: 0, leftPadding: 1 }, "\uE0B7": { d: "M.8,1 C0.578,1,0.2,.826,.22,.5 C0.2,0.174,0.578,0,0.8,0", type: 1, leftPadding: 1 }, "\uE0B8": { d: "M-.5,-.5 L1.5,1.5 L-.5,1.5", type: 0 }, "\uE0B9": { d: "M-.5,-.5 L1.5,1.5", type: 1, leftPadding: 1, rightPadding: 1 }, "\uE0BA": { d: "M1.5,-.5 L-.5,1.5 L1.5,1.5", type: 0 }, "\uE0BC": { d: "M1.5,-.5 L-.5,1.5 L-.5,-.5", type: 0 }, "\uE0BD": { d: "M1.5,-.5 L-.5,1.5", type: 1, leftPadding: 1, rightPadding: 1 }, "\uE0BE": { d: "M-.5,-.5 L1.5,1.5 L1.5,-.5", type: 0 } }, t2.powerlineDefinitions["\uE0BB"] = t2.powerlineDefinitions["\uE0BD"], t2.powerlineDefinitions["\uE0BF"] = t2.powerlineDefinitions["\uE0B9"], t2.tryDrawCustomChar = function(e3, i3, n2, l, c, d, _, u) {
        const g = t2.blockElementDefinitions[i3];
        if (g)
          return function(e4, t3, i4, s3, r2, o2) {
            for (let n3 = 0;n3 < t3.length; n3++) {
              const a2 = t3[n3], h2 = r2 / 8, l2 = o2 / 8;
              e4.fillRect(i4 + a2.x * h2, s3 + a2.y * l2, a2.w * h2, a2.h * l2);
            }
          }(e3, g, n2, l, c, d), true;
        const v = r[i3];
        if (v)
          return function(e4, t3, i4, r2, n3, a2) {
            let h2 = o.get(t3);
            h2 || (h2 = new Map, o.set(t3, h2));
            const l2 = e4.fillStyle;
            if (typeof l2 != "string")
              throw new Error(`Unexpected fillStyle type "${l2}"`);
            let c2 = h2.get(l2);
            if (!c2) {
              const i5 = t3[0].length, r3 = t3.length, o2 = e4.canvas.ownerDocument.createElement("canvas");
              o2.width = i5, o2.height = r3;
              const n4 = (0, s2.throwIfFalsy)(o2.getContext("2d")), a3 = new ImageData(i5, r3);
              let d2, _2, u2, g2;
              if (l2.startsWith("#"))
                d2 = parseInt(l2.slice(1, 3), 16), _2 = parseInt(l2.slice(3, 5), 16), u2 = parseInt(l2.slice(5, 7), 16), g2 = l2.length > 7 && parseInt(l2.slice(7, 9), 16) || 1;
              else {
                if (!l2.startsWith("rgba"))
                  throw new Error(`Unexpected fillStyle color format "${l2}" when drawing pattern glyph`);
                [d2, _2, u2, g2] = l2.substring(5, l2.length - 1).split(",").map((e5) => parseFloat(e5));
              }
              for (let e5 = 0;e5 < r3; e5++)
                for (let s3 = 0;s3 < i5; s3++)
                  a3.data[4 * (e5 * i5 + s3)] = d2, a3.data[4 * (e5 * i5 + s3) + 1] = _2, a3.data[4 * (e5 * i5 + s3) + 2] = u2, a3.data[4 * (e5 * i5 + s3) + 3] = t3[e5][s3] * (255 * g2);
              n4.putImageData(a3, 0, 0), c2 = (0, s2.throwIfFalsy)(e4.createPattern(o2, null)), h2.set(l2, c2);
            }
            e4.fillStyle = c2, e4.fillRect(i4, r2, n3, a2);
          }(e3, v, n2, l, c, d), true;
        const f = t2.boxDrawingDefinitions[i3];
        if (f)
          return function(e4, t3, i4, s3, r2, o2, n3) {
            e4.strokeStyle = e4.fillStyle;
            for (const [l2, c2] of Object.entries(t3)) {
              let t4;
              e4.beginPath(), e4.lineWidth = n3 * Number.parseInt(l2), t4 = typeof c2 == "function" ? c2(0.15, 0.15 / o2 * r2) : c2;
              for (const l3 of t4.split(" ")) {
                const t5 = l3[0], c3 = a[t5];
                if (!c3) {
                  console.error(`Could not find drawing instructions for "${t5}"`);
                  continue;
                }
                const d2 = l3.substring(1).split(",");
                d2[0] && d2[1] && c3(e4, h(d2, r2, o2, i4, s3, true, n3));
              }
              e4.stroke(), e4.closePath();
            }
          }(e3, f, n2, l, c, d, u), true;
        const p = t2.powerlineDefinitions[i3];
        return !!p && (function(e4, t3, i4, s3, r2, o2, n3, l2) {
          const c2 = new Path2D;
          c2.rect(i4, s3, r2, o2), e4.clip(c2), e4.beginPath();
          const d2 = n3 / 12;
          e4.lineWidth = l2 * d2;
          for (const n4 of t3.d.split(" ")) {
            const c3 = n4[0], _2 = a[c3];
            if (!_2) {
              console.error(`Could not find drawing instructions for "${c3}"`);
              continue;
            }
            const u2 = n4.substring(1).split(",");
            u2[0] && u2[1] && _2(e4, h(u2, r2, o2, i4, s3, false, l2, (t3.leftPadding ?? 0) * (d2 / 2), (t3.rightPadding ?? 0) * (d2 / 2)));
          }
          t3.type === 1 ? (e4.strokeStyle = e4.fillStyle, e4.stroke()) : e4.fill(), e4.closePath();
        }(e3, p, n2, l, c, d, _, u), true);
      };
      const o = new Map;
      function n(e3, t3, i3 = 0) {
        return Math.max(Math.min(e3, t3), i3);
      }
      const a = { C: (e3, t3) => e3.bezierCurveTo(t3[0], t3[1], t3[2], t3[3], t3[4], t3[5]), L: (e3, t3) => e3.lineTo(t3[0], t3[1]), M: (e3, t3) => e3.moveTo(t3[0], t3[1]) };
      function h(e3, t3, i3, s3, r2, o2, a2, h2 = 0, l = 0) {
        const c = e3.map((e4) => parseFloat(e4) || parseInt(e4));
        if (c.length < 2)
          throw new Error("Too few arguments for instruction");
        for (let e4 = 0;e4 < c.length; e4 += 2)
          c[e4] *= t3 - h2 * a2 - l * a2, o2 && c[e4] !== 0 && (c[e4] = n(Math.round(c[e4] + 0.5) - 0.5, t3, 0)), c[e4] += s3 + h2 * a2;
        for (let e4 = 1;e4 < c.length; e4 += 2)
          c[e4] *= i3, o2 && c[e4] !== 0 && (c[e4] = n(Math.round(c[e4] + 0.5) - 0.5, i3, 0)), c[e4] += r2;
        return c;
      }
    }, 56: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.observeDevicePixelDimensions = undefined;
      const s2 = i2(859);
      t2.observeDevicePixelDimensions = function(e3, t3, i3) {
        let r = new t3.ResizeObserver((t4) => {
          const s3 = t4.find((t5) => t5.target === e3);
          if (!s3)
            return;
          if (!("devicePixelContentBoxSize" in s3))
            return r?.disconnect(), void (r = undefined);
          const o = s3.devicePixelContentBoxSize[0].inlineSize, n = s3.devicePixelContentBoxSize[0].blockSize;
          o > 0 && n > 0 && i3(o, n);
        });
        try {
          r.observe(e3, { box: ["device-pixel-content-box"] });
        } catch {
          r.disconnect(), r = undefined;
        }
        return (0, s2.toDisposable)(() => r?.disconnect());
      };
    }, 374: (e2, t2) => {
      function i2(e3) {
        return 57508 <= e3 && e3 <= 57558;
      }
      Object.defineProperty(t2, "__esModule", { value: true }), t2.createRenderDimensions = t2.excludeFromContrastRatioDemands = t2.isRestrictedPowerlineGlyph = t2.isPowerlineGlyph = t2.throwIfFalsy = undefined, t2.throwIfFalsy = function(e3) {
        if (!e3)
          throw new Error("value must not be falsy");
        return e3;
      }, t2.isPowerlineGlyph = i2, t2.isRestrictedPowerlineGlyph = function(e3) {
        return 57520 <= e3 && e3 <= 57527;
      }, t2.excludeFromContrastRatioDemands = function(e3) {
        return i2(e3) || function(e4) {
          return 9472 <= e4 && e4 <= 9631;
        }(e3);
      }, t2.createRenderDimensions = function() {
        return { css: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 } }, device: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 }, char: { width: 0, height: 0, left: 0, top: 0 } } };
      };
    }, 296: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.createSelectionRenderModel = undefined;

      class i2 {
        constructor() {
          this.clear();
        }
        clear() {
          this.hasSelection = false, this.columnSelectMode = false, this.viewportStartRow = 0, this.viewportEndRow = 0, this.viewportCappedStartRow = 0, this.viewportCappedEndRow = 0, this.startCol = 0, this.endCol = 0, this.selectionStart = undefined, this.selectionEnd = undefined;
        }
        update(e3, t3, i3, s2 = false) {
          if (this.selectionStart = t3, this.selectionEnd = i3, !t3 || !i3 || t3[0] === i3[0] && t3[1] === i3[1])
            return void this.clear();
          const r = t3[1] - e3.buffer.active.viewportY, o = i3[1] - e3.buffer.active.viewportY, n = Math.max(r, 0), a = Math.min(o, e3.rows - 1);
          n >= e3.rows || a < 0 ? this.clear() : (this.hasSelection = true, this.columnSelectMode = s2, this.viewportStartRow = r, this.viewportEndRow = o, this.viewportCappedStartRow = n, this.viewportCappedEndRow = a, this.startCol = t3[0], this.endCol = i3[0]);
        }
        isCellSelected(e3, t3, i3) {
          return !!this.hasSelection && (i3 -= e3.buffer.active.viewportY, this.columnSelectMode ? this.startCol <= this.endCol ? t3 >= this.startCol && i3 >= this.viewportCappedStartRow && t3 < this.endCol && i3 <= this.viewportCappedEndRow : t3 < this.startCol && i3 >= this.viewportCappedStartRow && t3 >= this.endCol && i3 <= this.viewportCappedEndRow : i3 > this.viewportStartRow && i3 < this.viewportEndRow || this.viewportStartRow === this.viewportEndRow && i3 === this.viewportStartRow && t3 >= this.startCol && t3 < this.endCol || this.viewportStartRow < this.viewportEndRow && i3 === this.viewportEndRow && t3 < this.endCol || this.viewportStartRow < this.viewportEndRow && i3 === this.viewportStartRow && t3 >= this.startCol);
        }
      }
      t2.createSelectionRenderModel = function() {
        return new i2;
      };
    }, 509: function(e2, t2, i2) {
      var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
        var r2, o2 = arguments.length, n2 = o2 < 3 ? t3 : s3 === null ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n2 = Reflect.decorate(e3, t3, i3, s3);
        else
          for (var a2 = e3.length - 1;a2 >= 0; a2--)
            (r2 = e3[a2]) && (n2 = (o2 < 3 ? r2(n2) : o2 > 3 ? r2(t3, i3, n2) : r2(t3, i3)) || n2);
        return o2 > 3 && n2 && Object.defineProperty(t3, i3, n2), n2;
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.TextureAtlas = undefined;
      const r = i2(237), o = i2(860), n = i2(374), a = i2(160), h = i2(345), l = i2(485), c = i2(385), d = i2(147), _ = i2(855), u = i2(776), g = { texturePage: 0, texturePosition: { x: 0, y: 0 }, texturePositionClipSpace: { x: 0, y: 0 }, offset: { x: 0, y: 0 }, size: { x: 0, y: 0 }, sizeClipSpace: { x: 0, y: 0 } };
      let v;

      class f {
        get pages() {
          return this._pages;
        }
        constructor(e3, t3, i3) {
          this._document = e3, this._config = t3, this._unicodeService = i3, this._didWarmUp = false, this._cacheMap = new l.FourKeyMap, this._cacheMapCombined = new l.FourKeyMap, this._pages = [], this._activePages = [], this._workBoundingBox = { top: 0, left: 0, bottom: 0, right: 0 }, this._workAttributeData = new d.AttributeData, this._textureSize = 512, this._onAddTextureAtlasCanvas = new h.EventEmitter, this.onAddTextureAtlasCanvas = this._onAddTextureAtlasCanvas.event, this._onRemoveTextureAtlasCanvas = new h.EventEmitter, this.onRemoveTextureAtlasCanvas = this._onRemoveTextureAtlasCanvas.event, this._requestClearModel = false, this._createNewPage(), this._tmpCanvas = m(e3, 4 * this._config.deviceCellWidth + 4, this._config.deviceCellHeight + 4), this._tmpCtx = (0, n.throwIfFalsy)(this._tmpCanvas.getContext("2d", { alpha: this._config.allowTransparency, willReadFrequently: true }));
        }
        dispose() {
          for (const e3 of this.pages)
            e3.canvas.remove();
          this._onAddTextureAtlasCanvas.dispose();
        }
        warmUp() {
          this._didWarmUp || (this._doWarmUp(), this._didWarmUp = true);
        }
        _doWarmUp() {
          const e3 = new c.IdleTaskQueue;
          for (let t3 = 33;t3 < 126; t3++)
            e3.enqueue(() => {
              if (!this._cacheMap.get(t3, _.DEFAULT_COLOR, _.DEFAULT_COLOR, _.DEFAULT_EXT)) {
                const e4 = this._drawToCache(t3, _.DEFAULT_COLOR, _.DEFAULT_COLOR, _.DEFAULT_EXT);
                this._cacheMap.set(t3, _.DEFAULT_COLOR, _.DEFAULT_COLOR, _.DEFAULT_EXT, e4);
              }
            });
        }
        beginFrame() {
          return this._requestClearModel;
        }
        clearTexture() {
          if (this._pages[0].currentRow.x !== 0 || this._pages[0].currentRow.y !== 0) {
            for (const e3 of this._pages)
              e3.clear();
            this._cacheMap.clear(), this._cacheMapCombined.clear(), this._didWarmUp = false;
          }
        }
        _createNewPage() {
          if (f.maxAtlasPages && this._pages.length >= Math.max(4, f.maxAtlasPages)) {
            const e4 = this._pages.filter((e5) => 2 * e5.canvas.width <= (f.maxTextureSize || 4096)).sort((e5, t4) => t4.canvas.width !== e5.canvas.width ? t4.canvas.width - e5.canvas.width : t4.percentageUsed - e5.percentageUsed);
            let t3 = -1, i3 = 0;
            for (let s4 = 0;s4 < e4.length; s4++)
              if (e4[s4].canvas.width !== i3)
                t3 = s4, i3 = e4[s4].canvas.width;
              else if (s4 - t3 == 3)
                break;
            const s3 = e4.slice(t3, t3 + 4), r2 = s3.map((e5) => e5.glyphs[0].texturePage).sort((e5, t4) => e5 > t4 ? 1 : -1), o2 = this.pages.length - s3.length, n2 = this._mergePages(s3, o2);
            n2.version++;
            for (let e5 = r2.length - 1;e5 >= 0; e5--)
              this._deletePage(r2[e5]);
            this.pages.push(n2), this._requestClearModel = true, this._onAddTextureAtlasCanvas.fire(n2.canvas);
          }
          const e3 = new p(this._document, this._textureSize);
          return this._pages.push(e3), this._activePages.push(e3), this._onAddTextureAtlasCanvas.fire(e3.canvas), e3;
        }
        _mergePages(e3, t3) {
          const i3 = 2 * e3[0].canvas.width, s3 = new p(this._document, i3, e3);
          for (const [r2, o2] of e3.entries()) {
            const e4 = r2 * o2.canvas.width % i3, n2 = Math.floor(r2 / 2) * o2.canvas.height;
            s3.ctx.drawImage(o2.canvas, e4, n2);
            for (const s4 of o2.glyphs)
              s4.texturePage = t3, s4.sizeClipSpace.x = s4.size.x / i3, s4.sizeClipSpace.y = s4.size.y / i3, s4.texturePosition.x += e4, s4.texturePosition.y += n2, s4.texturePositionClipSpace.x = s4.texturePosition.x / i3, s4.texturePositionClipSpace.y = s4.texturePosition.y / i3;
            this._onRemoveTextureAtlasCanvas.fire(o2.canvas);
            const a2 = this._activePages.indexOf(o2);
            a2 !== -1 && this._activePages.splice(a2, 1);
          }
          return s3;
        }
        _deletePage(e3) {
          this._pages.splice(e3, 1);
          for (let t3 = e3;t3 < this._pages.length; t3++) {
            const e4 = this._pages[t3];
            for (const t4 of e4.glyphs)
              t4.texturePage--;
            e4.version++;
          }
        }
        getRasterizedGlyphCombinedChar(e3, t3, i3, s3, r2) {
          return this._getFromCacheMap(this._cacheMapCombined, e3, t3, i3, s3, r2);
        }
        getRasterizedGlyph(e3, t3, i3, s3, r2) {
          return this._getFromCacheMap(this._cacheMap, e3, t3, i3, s3, r2);
        }
        _getFromCacheMap(e3, t3, i3, s3, r2, o2 = false) {
          return v = e3.get(t3, i3, s3, r2), v || (v = this._drawToCache(t3, i3, s3, r2, o2), e3.set(t3, i3, s3, r2, v)), v;
        }
        _getColorFromAnsiIndex(e3) {
          if (e3 >= this._config.colors.ansi.length)
            throw new Error("No color found for idx " + e3);
          return this._config.colors.ansi[e3];
        }
        _getBackgroundColor(e3, t3, i3, s3) {
          if (this._config.allowTransparency)
            return a.NULL_COLOR;
          let r2;
          switch (e3) {
            case 16777216:
            case 33554432:
              r2 = this._getColorFromAnsiIndex(t3);
              break;
            case 50331648:
              const e4 = d.AttributeData.toColorRGB(t3);
              r2 = a.rgba.toColor(e4[0], e4[1], e4[2]);
              break;
            default:
              r2 = i3 ? a.color.opaque(this._config.colors.foreground) : this._config.colors.background;
          }
          return r2;
        }
        _getForegroundColor(e3, t3, i3, s3, o2, n2, h2, l2, c2, _2) {
          const u2 = this._getMinimumContrastColor(e3, t3, i3, s3, o2, n2, h2, c2, l2, _2);
          if (u2)
            return u2;
          let g2;
          switch (o2) {
            case 16777216:
            case 33554432:
              this._config.drawBoldTextInBrightColors && c2 && n2 < 8 && (n2 += 8), g2 = this._getColorFromAnsiIndex(n2);
              break;
            case 50331648:
              const e4 = d.AttributeData.toColorRGB(n2);
              g2 = a.rgba.toColor(e4[0], e4[1], e4[2]);
              break;
            default:
              g2 = h2 ? this._config.colors.background : this._config.colors.foreground;
          }
          return this._config.allowTransparency && (g2 = a.color.opaque(g2)), l2 && (g2 = a.color.multiplyOpacity(g2, r.DIM_OPACITY)), g2;
        }
        _resolveBackgroundRgba(e3, t3, i3) {
          switch (e3) {
            case 16777216:
            case 33554432:
              return this._getColorFromAnsiIndex(t3).rgba;
            case 50331648:
              return t3 << 8;
            default:
              return i3 ? this._config.colors.foreground.rgba : this._config.colors.background.rgba;
          }
        }
        _resolveForegroundRgba(e3, t3, i3, s3) {
          switch (e3) {
            case 16777216:
            case 33554432:
              return this._config.drawBoldTextInBrightColors && s3 && t3 < 8 && (t3 += 8), this._getColorFromAnsiIndex(t3).rgba;
            case 50331648:
              return t3 << 8;
            default:
              return i3 ? this._config.colors.background.rgba : this._config.colors.foreground.rgba;
          }
        }
        _getMinimumContrastColor(e3, t3, i3, s3, r2, o2, n2, h2, l2, c2) {
          if (this._config.minimumContrastRatio === 1 || c2)
            return;
          const d2 = this._getContrastCache(l2), _2 = d2.getColor(e3, s3);
          if (_2 !== undefined)
            return _2 || undefined;
          const u2 = this._resolveBackgroundRgba(t3, i3, n2), g2 = this._resolveForegroundRgba(r2, o2, n2, h2), v2 = a.rgba.ensureContrastRatio(u2, g2, this._config.minimumContrastRatio / (l2 ? 2 : 1));
          if (!v2)
            return void d2.setColor(e3, s3, null);
          const f2 = a.rgba.toColor(v2 >> 24 & 255, v2 >> 16 & 255, v2 >> 8 & 255);
          return d2.setColor(e3, s3, f2), f2;
        }
        _getContrastCache(e3) {
          return e3 ? this._config.colors.halfContrastCache : this._config.colors.contrastCache;
        }
        _drawToCache(e3, t3, i3, s3, a2 = false) {
          const h2 = typeof e3 == "number" ? String.fromCharCode(e3) : e3, l2 = Math.min(this._config.deviceCellWidth * Math.max(h2.length, 2) + 4, this._textureSize);
          this._tmpCanvas.width < l2 && (this._tmpCanvas.width = l2);
          const c2 = Math.min(this._config.deviceCellHeight + 8, this._textureSize);
          if (this._tmpCanvas.height < c2 && (this._tmpCanvas.height = c2), this._tmpCtx.save(), this._workAttributeData.fg = i3, this._workAttributeData.bg = t3, this._workAttributeData.extended.ext = s3, this._workAttributeData.isInvisible())
            return g;
          const _2 = !!this._workAttributeData.isBold(), u2 = !!this._workAttributeData.isInverse(), v2 = !!this._workAttributeData.isDim(), p2 = !!this._workAttributeData.isItalic(), m2 = !!this._workAttributeData.isUnderline(), L = !!this._workAttributeData.isStrikethrough(), x = !!this._workAttributeData.isOverline();
          let w = this._workAttributeData.getFgColor(), b = this._workAttributeData.getFgColorMode(), R = this._workAttributeData.getBgColor(), M = this._workAttributeData.getBgColorMode();
          if (u2) {
            const e4 = w;
            w = R, R = e4;
            const t4 = b;
            b = M, M = t4;
          }
          const y = this._getBackgroundColor(M, R, u2, v2);
          this._tmpCtx.globalCompositeOperation = "copy", this._tmpCtx.fillStyle = y.css, this._tmpCtx.fillRect(0, 0, this._tmpCanvas.width, this._tmpCanvas.height), this._tmpCtx.globalCompositeOperation = "source-over";
          const A = _2 ? this._config.fontWeightBold : this._config.fontWeight, E = p2 ? "italic" : "";
          this._tmpCtx.font = `${E} ${A} ${this._config.fontSize * this._config.devicePixelRatio}px ${this._config.fontFamily}`, this._tmpCtx.textBaseline = r.TEXT_BASELINE;
          const S = h2.length === 1 && (0, n.isPowerlineGlyph)(h2.charCodeAt(0)), T = h2.length === 1 && (0, n.isRestrictedPowerlineGlyph)(h2.charCodeAt(0)), D = this._getForegroundColor(t3, M, R, i3, b, w, u2, v2, _2, (0, n.excludeFromContrastRatioDemands)(h2.charCodeAt(0)));
          this._tmpCtx.fillStyle = D.css;
          const F = T ? 0 : 4;
          let B = false;
          this._config.customGlyphs !== false && (B = (0, o.tryDrawCustomChar)(this._tmpCtx, h2, F, F, this._config.deviceCellWidth, this._config.deviceCellHeight, this._config.fontSize, this._config.devicePixelRatio));
          let P, I = !S;
          if (P = typeof e3 == "number" ? this._unicodeService.wcwidth(e3) : this._unicodeService.getStringCellWidth(e3), m2) {
            this._tmpCtx.save();
            const e4 = Math.max(1, Math.floor(this._config.fontSize * this._config.devicePixelRatio / 15)), t4 = e4 % 2 == 1 ? 0.5 : 0;
            if (this._tmpCtx.lineWidth = e4, this._workAttributeData.isUnderlineColorDefault())
              this._tmpCtx.strokeStyle = this._tmpCtx.fillStyle;
            else if (this._workAttributeData.isUnderlineColorRGB())
              I = false, this._tmpCtx.strokeStyle = `rgb(${d.AttributeData.toColorRGB(this._workAttributeData.getUnderlineColor()).join(",")})`;
            else {
              I = false;
              let e5 = this._workAttributeData.getUnderlineColor();
              this._config.drawBoldTextInBrightColors && this._workAttributeData.isBold() && e5 < 8 && (e5 += 8), this._tmpCtx.strokeStyle = this._getColorFromAnsiIndex(e5).css;
            }
            this._tmpCtx.beginPath();
            const i4 = F, s4 = Math.ceil(F + this._config.deviceCharHeight) - t4 - (a2 ? 2 * e4 : 0), r2 = s4 + e4, o2 = s4 + 2 * e4;
            for (let n2 = 0;n2 < P; n2++) {
              this._tmpCtx.save();
              const a3 = i4 + n2 * this._config.deviceCellWidth, h3 = i4 + (n2 + 1) * this._config.deviceCellWidth, l3 = a3 + this._config.deviceCellWidth / 2;
              switch (this._workAttributeData.extended.underlineStyle) {
                case 2:
                  this._tmpCtx.moveTo(a3, s4), this._tmpCtx.lineTo(h3, s4), this._tmpCtx.moveTo(a3, o2), this._tmpCtx.lineTo(h3, o2);
                  break;
                case 3:
                  const i5 = e4 <= 1 ? o2 : Math.ceil(F + this._config.deviceCharHeight - e4 / 2) - t4, n3 = e4 <= 1 ? s4 : Math.ceil(F + this._config.deviceCharHeight + e4 / 2) - t4, c3 = new Path2D;
                  c3.rect(a3, s4, this._config.deviceCellWidth, o2 - s4), this._tmpCtx.clip(c3), this._tmpCtx.moveTo(a3 - this._config.deviceCellWidth / 2, r2), this._tmpCtx.bezierCurveTo(a3 - this._config.deviceCellWidth / 2, n3, a3, n3, a3, r2), this._tmpCtx.bezierCurveTo(a3, i5, l3, i5, l3, r2), this._tmpCtx.bezierCurveTo(l3, n3, h3, n3, h3, r2), this._tmpCtx.bezierCurveTo(h3, i5, h3 + this._config.deviceCellWidth / 2, i5, h3 + this._config.deviceCellWidth / 2, r2);
                  break;
                case 4:
                  this._tmpCtx.setLineDash([Math.round(e4), Math.round(e4)]), this._tmpCtx.moveTo(a3, s4), this._tmpCtx.lineTo(h3, s4);
                  break;
                case 5:
                  this._tmpCtx.setLineDash([4 * this._config.devicePixelRatio, 3 * this._config.devicePixelRatio]), this._tmpCtx.moveTo(a3, s4), this._tmpCtx.lineTo(h3, s4);
                  break;
                default:
                  this._tmpCtx.moveTo(a3, s4), this._tmpCtx.lineTo(h3, s4);
              }
              this._tmpCtx.stroke(), this._tmpCtx.restore();
            }
            if (this._tmpCtx.restore(), !B && this._config.fontSize >= 12 && !this._config.allowTransparency && h2 !== " ") {
              this._tmpCtx.save(), this._tmpCtx.textBaseline = "alphabetic";
              const t5 = this._tmpCtx.measureText(h2);
              if (this._tmpCtx.restore(), ("actualBoundingBoxDescent" in t5) && t5.actualBoundingBoxDescent > 0) {
                this._tmpCtx.save();
                const t6 = new Path2D;
                t6.rect(i4, s4 - Math.ceil(e4 / 2), this._config.deviceCellWidth * P, o2 - s4 + Math.ceil(e4 / 2)), this._tmpCtx.clip(t6), this._tmpCtx.lineWidth = 3 * this._config.devicePixelRatio, this._tmpCtx.strokeStyle = y.css, this._tmpCtx.strokeText(h2, F, F + this._config.deviceCharHeight), this._tmpCtx.restore();
              }
            }
          }
          if (x) {
            const e4 = Math.max(1, Math.floor(this._config.fontSize * this._config.devicePixelRatio / 15)), t4 = e4 % 2 == 1 ? 0.5 : 0;
            this._tmpCtx.lineWidth = e4, this._tmpCtx.strokeStyle = this._tmpCtx.fillStyle, this._tmpCtx.beginPath(), this._tmpCtx.moveTo(F, F + t4), this._tmpCtx.lineTo(F + this._config.deviceCharWidth * P, F + t4), this._tmpCtx.stroke();
          }
          if (B || this._tmpCtx.fillText(h2, F, F + this._config.deviceCharHeight), h2 === "_" && !this._config.allowTransparency) {
            let e4 = C(this._tmpCtx.getImageData(F, F, this._config.deviceCellWidth, this._config.deviceCellHeight), y, D, I);
            if (e4)
              for (let t4 = 1;t4 <= 5 && (this._tmpCtx.save(), this._tmpCtx.fillStyle = y.css, this._tmpCtx.fillRect(0, 0, this._tmpCanvas.width, this._tmpCanvas.height), this._tmpCtx.restore(), this._tmpCtx.fillText(h2, F, F + this._config.deviceCharHeight - t4), e4 = C(this._tmpCtx.getImageData(F, F, this._config.deviceCellWidth, this._config.deviceCellHeight), y, D, I), e4); t4++)
                ;
          }
          if (L) {
            const e4 = Math.max(1, Math.floor(this._config.fontSize * this._config.devicePixelRatio / 10)), t4 = this._tmpCtx.lineWidth % 2 == 1 ? 0.5 : 0;
            this._tmpCtx.lineWidth = e4, this._tmpCtx.strokeStyle = this._tmpCtx.fillStyle, this._tmpCtx.beginPath(), this._tmpCtx.moveTo(F, F + Math.floor(this._config.deviceCharHeight / 2) - t4), this._tmpCtx.lineTo(F + this._config.deviceCharWidth * P, F + Math.floor(this._config.deviceCharHeight / 2) - t4), this._tmpCtx.stroke();
          }
          this._tmpCtx.restore();
          const O = this._tmpCtx.getImageData(0, 0, this._tmpCanvas.width, this._tmpCanvas.height);
          let $;
          if ($ = this._config.allowTransparency ? function(e4) {
            for (let t4 = 0;t4 < e4.data.length; t4 += 4)
              if (e4.data[t4 + 3] > 0)
                return false;
            return true;
          }(O) : C(O, y, D, I), $)
            return g;
          const k = this._findGlyphBoundingBox(O, this._workBoundingBox, l2, T, B, F);
          let U, N;
          for (;; ) {
            if (this._activePages.length === 0) {
              const e4 = this._createNewPage();
              U = e4, N = e4.currentRow, N.height = k.size.y;
              break;
            }
            U = this._activePages[this._activePages.length - 1], N = U.currentRow;
            for (const e4 of this._activePages)
              k.size.y <= e4.currentRow.height && (U = e4, N = e4.currentRow);
            for (let e4 = this._activePages.length - 1;e4 >= 0; e4--)
              for (const t4 of this._activePages[e4].fixedRows)
                t4.height <= N.height && k.size.y <= t4.height && (U = this._activePages[e4], N = t4);
            if (N.y + k.size.y >= U.canvas.height || N.height > k.size.y + 2) {
              let e4 = false;
              if (U.currentRow.y + U.currentRow.height + k.size.y >= U.canvas.height) {
                let t4;
                for (const e5 of this._activePages)
                  if (e5.currentRow.y + e5.currentRow.height + k.size.y < e5.canvas.height) {
                    t4 = e5;
                    break;
                  }
                if (t4)
                  U = t4;
                else if (f.maxAtlasPages && this._pages.length >= f.maxAtlasPages && N.y + k.size.y <= U.canvas.height && N.height >= k.size.y && N.x + k.size.x <= U.canvas.width)
                  e4 = true;
                else {
                  const t5 = this._createNewPage();
                  U = t5, N = t5.currentRow, N.height = k.size.y, e4 = true;
                }
              }
              e4 || (U.currentRow.height > 0 && U.fixedRows.push(U.currentRow), N = { x: 0, y: U.currentRow.y + U.currentRow.height, height: k.size.y }, U.fixedRows.push(N), U.currentRow = { x: 0, y: N.y + N.height, height: 0 });
            }
            if (N.x + k.size.x <= U.canvas.width)
              break;
            N === U.currentRow ? (N.x = 0, N.y += N.height, N.height = 0) : U.fixedRows.splice(U.fixedRows.indexOf(N), 1);
          }
          return k.texturePage = this._pages.indexOf(U), k.texturePosition.x = N.x, k.texturePosition.y = N.y, k.texturePositionClipSpace.x = N.x / U.canvas.width, k.texturePositionClipSpace.y = N.y / U.canvas.height, k.sizeClipSpace.x /= U.canvas.width, k.sizeClipSpace.y /= U.canvas.height, N.height = Math.max(N.height, k.size.y), N.x += k.size.x, U.ctx.putImageData(O, k.texturePosition.x - this._workBoundingBox.left, k.texturePosition.y - this._workBoundingBox.top, this._workBoundingBox.left, this._workBoundingBox.top, k.size.x, k.size.y), U.addGlyph(k), U.version++, k;
        }
        _findGlyphBoundingBox(e3, t3, i3, s3, r2, o2) {
          t3.top = 0;
          const n2 = s3 ? this._config.deviceCellHeight : this._tmpCanvas.height, a2 = s3 ? this._config.deviceCellWidth : i3;
          let h2 = false;
          for (let i4 = 0;i4 < n2; i4++) {
            for (let s4 = 0;s4 < a2; s4++) {
              const r3 = i4 * this._tmpCanvas.width * 4 + 4 * s4 + 3;
              if (e3.data[r3] !== 0) {
                t3.top = i4, h2 = true;
                break;
              }
            }
            if (h2)
              break;
          }
          t3.left = 0, h2 = false;
          for (let i4 = 0;i4 < o2 + a2; i4++) {
            for (let s4 = 0;s4 < n2; s4++) {
              const r3 = s4 * this._tmpCanvas.width * 4 + 4 * i4 + 3;
              if (e3.data[r3] !== 0) {
                t3.left = i4, h2 = true;
                break;
              }
            }
            if (h2)
              break;
          }
          t3.right = a2, h2 = false;
          for (let i4 = o2 + a2 - 1;i4 >= o2; i4--) {
            for (let s4 = 0;s4 < n2; s4++) {
              const r3 = s4 * this._tmpCanvas.width * 4 + 4 * i4 + 3;
              if (e3.data[r3] !== 0) {
                t3.right = i4, h2 = true;
                break;
              }
            }
            if (h2)
              break;
          }
          t3.bottom = n2, h2 = false;
          for (let i4 = n2 - 1;i4 >= 0; i4--) {
            for (let s4 = 0;s4 < a2; s4++) {
              const r3 = i4 * this._tmpCanvas.width * 4 + 4 * s4 + 3;
              if (e3.data[r3] !== 0) {
                t3.bottom = i4, h2 = true;
                break;
              }
            }
            if (h2)
              break;
          }
          return { texturePage: 0, texturePosition: { x: 0, y: 0 }, texturePositionClipSpace: { x: 0, y: 0 }, size: { x: t3.right - t3.left + 1, y: t3.bottom - t3.top + 1 }, sizeClipSpace: { x: t3.right - t3.left + 1, y: t3.bottom - t3.top + 1 }, offset: { x: -t3.left + o2 + (s3 || r2 ? Math.floor((this._config.deviceCellWidth - this._config.deviceCharWidth) / 2) : 0), y: -t3.top + o2 + (s3 || r2 ? this._config.lineHeight === 1 ? 0 : Math.round((this._config.deviceCellHeight - this._config.deviceCharHeight) / 2) : 0) } };
        }
      }
      t2.TextureAtlas = f, s2([u.traceCall], f.prototype, "_drawToCache", null);

      class p {
        get percentageUsed() {
          return this._usedPixels / (this.canvas.width * this.canvas.height);
        }
        get glyphs() {
          return this._glyphs;
        }
        addGlyph(e3) {
          this._glyphs.push(e3), this._usedPixels += e3.size.x * e3.size.y;
        }
        constructor(e3, t3, i3) {
          if (this._usedPixels = 0, this._glyphs = [], this.version = 0, this.currentRow = { x: 0, y: 0, height: 0 }, this.fixedRows = [], i3)
            for (const e4 of i3)
              this._glyphs.push(...e4.glyphs), this._usedPixels += e4._usedPixels;
          this.canvas = m(e3, t3, t3), this.ctx = (0, n.throwIfFalsy)(this.canvas.getContext("2d", { alpha: true }));
        }
        clear() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height), this.currentRow.x = 0, this.currentRow.y = 0, this.currentRow.height = 0, this.fixedRows.length = 0, this.version++;
        }
      }
      function C(e3, t3, i3, s3) {
        const r2 = t3.rgba >>> 24, o2 = t3.rgba >>> 16 & 255, n2 = t3.rgba >>> 8 & 255, a2 = i3.rgba >>> 24, h2 = i3.rgba >>> 16 & 255, l2 = i3.rgba >>> 8 & 255, c2 = Math.floor((Math.abs(r2 - a2) + Math.abs(o2 - h2) + Math.abs(n2 - l2)) / 12);
        let d2 = true;
        for (let t4 = 0;t4 < e3.data.length; t4 += 4)
          e3.data[t4] === r2 && e3.data[t4 + 1] === o2 && e3.data[t4 + 2] === n2 || s3 && Math.abs(e3.data[t4] - r2) + Math.abs(e3.data[t4 + 1] - o2) + Math.abs(e3.data[t4 + 2] - n2) < c2 ? e3.data[t4 + 3] = 0 : d2 = false;
        return d2;
      }
      function m(e3, t3, i3) {
        const s3 = e3.createElement("canvas");
        return s3.width = t3, s3.height = i3, s3;
      }
    }, 160: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.contrastRatio = t2.toPaddedHex = t2.rgba = t2.rgb = t2.css = t2.color = t2.channels = t2.NULL_COLOR = undefined;
      const s2 = i2(399);
      let r = 0, o = 0, n = 0, a = 0;
      var h, l, c, d, _;
      function u(e3) {
        const t3 = e3.toString(16);
        return t3.length < 2 ? "0" + t3 : t3;
      }
      function g(e3, t3) {
        return e3 < t3 ? (t3 + 0.05) / (e3 + 0.05) : (e3 + 0.05) / (t3 + 0.05);
      }
      t2.NULL_COLOR = { css: "#00000000", rgba: 0 }, function(e3) {
        e3.toCss = function(e4, t3, i3, s3) {
          return s3 !== undefined ? `#${u(e4)}${u(t3)}${u(i3)}${u(s3)}` : `#${u(e4)}${u(t3)}${u(i3)}`;
        }, e3.toRgba = function(e4, t3, i3, s3 = 255) {
          return (e4 << 24 | t3 << 16 | i3 << 8 | s3) >>> 0;
        };
      }(h || (t2.channels = h = {})), function(e3) {
        function t3(e4, t4) {
          return a = Math.round(255 * t4), [r, o, n] = _.toChannels(e4.rgba), { css: h.toCss(r, o, n, a), rgba: h.toRgba(r, o, n, a) };
        }
        e3.blend = function(e4, t4) {
          if (a = (255 & t4.rgba) / 255, a === 1)
            return { css: t4.css, rgba: t4.rgba };
          const i3 = t4.rgba >> 24 & 255, s3 = t4.rgba >> 16 & 255, l2 = t4.rgba >> 8 & 255, c2 = e4.rgba >> 24 & 255, d2 = e4.rgba >> 16 & 255, _2 = e4.rgba >> 8 & 255;
          return r = c2 + Math.round((i3 - c2) * a), o = d2 + Math.round((s3 - d2) * a), n = _2 + Math.round((l2 - _2) * a), { css: h.toCss(r, o, n), rgba: h.toRgba(r, o, n) };
        }, e3.isOpaque = function(e4) {
          return (255 & e4.rgba) == 255;
        }, e3.ensureContrastRatio = function(e4, t4, i3) {
          const s3 = _.ensureContrastRatio(e4.rgba, t4.rgba, i3);
          if (s3)
            return _.toColor(s3 >> 24 & 255, s3 >> 16 & 255, s3 >> 8 & 255);
        }, e3.opaque = function(e4) {
          const t4 = (255 | e4.rgba) >>> 0;
          return [r, o, n] = _.toChannels(t4), { css: h.toCss(r, o, n), rgba: t4 };
        }, e3.opacity = t3, e3.multiplyOpacity = function(e4, i3) {
          return a = 255 & e4.rgba, t3(e4, a * i3 / 255);
        }, e3.toColorRGB = function(e4) {
          return [e4.rgba >> 24 & 255, e4.rgba >> 16 & 255, e4.rgba >> 8 & 255];
        };
      }(l || (t2.color = l = {})), function(e3) {
        let t3, i3;
        if (!s2.isNode) {
          const e4 = document.createElement("canvas");
          e4.width = 1, e4.height = 1;
          const s3 = e4.getContext("2d", { willReadFrequently: true });
          s3 && (t3 = s3, t3.globalCompositeOperation = "copy", i3 = t3.createLinearGradient(0, 0, 1, 1));
        }
        e3.toColor = function(e4) {
          if (e4.match(/#[\da-f]{3,8}/i))
            switch (e4.length) {
              case 4:
                return r = parseInt(e4.slice(1, 2).repeat(2), 16), o = parseInt(e4.slice(2, 3).repeat(2), 16), n = parseInt(e4.slice(3, 4).repeat(2), 16), _.toColor(r, o, n);
              case 5:
                return r = parseInt(e4.slice(1, 2).repeat(2), 16), o = parseInt(e4.slice(2, 3).repeat(2), 16), n = parseInt(e4.slice(3, 4).repeat(2), 16), a = parseInt(e4.slice(4, 5).repeat(2), 16), _.toColor(r, o, n, a);
              case 7:
                return { css: e4, rgba: (parseInt(e4.slice(1), 16) << 8 | 255) >>> 0 };
              case 9:
                return { css: e4, rgba: parseInt(e4.slice(1), 16) >>> 0 };
            }
          const s3 = e4.match(/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(,\s*(0|1|\d?\.(\d+))\s*)?\)/);
          if (s3)
            return r = parseInt(s3[1]), o = parseInt(s3[2]), n = parseInt(s3[3]), a = Math.round(255 * (s3[5] === undefined ? 1 : parseFloat(s3[5]))), _.toColor(r, o, n, a);
          if (!t3 || !i3)
            throw new Error("css.toColor: Unsupported css format");
          if (t3.fillStyle = i3, t3.fillStyle = e4, typeof t3.fillStyle != "string")
            throw new Error("css.toColor: Unsupported css format");
          if (t3.fillRect(0, 0, 1, 1), [r, o, n, a] = t3.getImageData(0, 0, 1, 1).data, a !== 255)
            throw new Error("css.toColor: Unsupported css format");
          return { rgba: h.toRgba(r, o, n, a), css: e4 };
        };
      }(c || (t2.css = c = {})), function(e3) {
        function t3(e4, t4, i3) {
          const s3 = e4 / 255, r2 = t4 / 255, o2 = i3 / 255;
          return 0.2126 * (s3 <= 0.03928 ? s3 / 12.92 : Math.pow((s3 + 0.055) / 1.055, 2.4)) + 0.7152 * (r2 <= 0.03928 ? r2 / 12.92 : Math.pow((r2 + 0.055) / 1.055, 2.4)) + 0.0722 * (o2 <= 0.03928 ? o2 / 12.92 : Math.pow((o2 + 0.055) / 1.055, 2.4));
        }
        e3.relativeLuminance = function(e4) {
          return t3(e4 >> 16 & 255, e4 >> 8 & 255, 255 & e4);
        }, e3.relativeLuminance2 = t3;
      }(d || (t2.rgb = d = {})), function(e3) {
        function t3(e4, t4, i4) {
          const s3 = e4 >> 24 & 255, r2 = e4 >> 16 & 255, o2 = e4 >> 8 & 255;
          let n2 = t4 >> 24 & 255, a2 = t4 >> 16 & 255, h2 = t4 >> 8 & 255, l2 = g(d.relativeLuminance2(n2, a2, h2), d.relativeLuminance2(s3, r2, o2));
          for (;l2 < i4 && (n2 > 0 || a2 > 0 || h2 > 0); )
            n2 -= Math.max(0, Math.ceil(0.1 * n2)), a2 -= Math.max(0, Math.ceil(0.1 * a2)), h2 -= Math.max(0, Math.ceil(0.1 * h2)), l2 = g(d.relativeLuminance2(n2, a2, h2), d.relativeLuminance2(s3, r2, o2));
          return (n2 << 24 | a2 << 16 | h2 << 8 | 255) >>> 0;
        }
        function i3(e4, t4, i4) {
          const s3 = e4 >> 24 & 255, r2 = e4 >> 16 & 255, o2 = e4 >> 8 & 255;
          let n2 = t4 >> 24 & 255, a2 = t4 >> 16 & 255, h2 = t4 >> 8 & 255, l2 = g(d.relativeLuminance2(n2, a2, h2), d.relativeLuminance2(s3, r2, o2));
          for (;l2 < i4 && (n2 < 255 || a2 < 255 || h2 < 255); )
            n2 = Math.min(255, n2 + Math.ceil(0.1 * (255 - n2))), a2 = Math.min(255, a2 + Math.ceil(0.1 * (255 - a2))), h2 = Math.min(255, h2 + Math.ceil(0.1 * (255 - h2))), l2 = g(d.relativeLuminance2(n2, a2, h2), d.relativeLuminance2(s3, r2, o2));
          return (n2 << 24 | a2 << 16 | h2 << 8 | 255) >>> 0;
        }
        e3.ensureContrastRatio = function(e4, s3, r2) {
          const o2 = d.relativeLuminance(e4 >> 8), n2 = d.relativeLuminance(s3 >> 8);
          if (g(o2, n2) < r2) {
            if (n2 < o2) {
              const n3 = t3(e4, s3, r2), a3 = g(o2, d.relativeLuminance(n3 >> 8));
              if (a3 < r2) {
                const t4 = i3(e4, s3, r2);
                return a3 > g(o2, d.relativeLuminance(t4 >> 8)) ? n3 : t4;
              }
              return n3;
            }
            const a2 = i3(e4, s3, r2), h2 = g(o2, d.relativeLuminance(a2 >> 8));
            if (h2 < r2) {
              const i4 = t3(e4, s3, r2);
              return h2 > g(o2, d.relativeLuminance(i4 >> 8)) ? a2 : i4;
            }
            return a2;
          }
        }, e3.reduceLuminance = t3, e3.increaseLuminance = i3, e3.toChannels = function(e4) {
          return [e4 >> 24 & 255, e4 >> 16 & 255, e4 >> 8 & 255, 255 & e4];
        }, e3.toColor = function(e4, t4, i4, s3) {
          return { css: h.toCss(e4, t4, i4, s3), rgba: h.toRgba(e4, t4, i4, s3) };
        };
      }(_ || (t2.rgba = _ = {})), t2.toPaddedHex = u, t2.contrastRatio = g;
    }, 345: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.runAndSubscribe = t2.forwardEvent = t2.EventEmitter = undefined, t2.EventEmitter = class {
        constructor() {
          this._listeners = [], this._disposed = false;
        }
        get event() {
          return this._event || (this._event = (e3) => (this._listeners.push(e3), { dispose: () => {
            if (!this._disposed) {
              for (let t3 = 0;t3 < this._listeners.length; t3++)
                if (this._listeners[t3] === e3)
                  return void this._listeners.splice(t3, 1);
            }
          } })), this._event;
        }
        fire(e3, t3) {
          const i2 = [];
          for (let e4 = 0;e4 < this._listeners.length; e4++)
            i2.push(this._listeners[e4]);
          for (let s2 = 0;s2 < i2.length; s2++)
            i2[s2].call(undefined, e3, t3);
        }
        dispose() {
          this.clearListeners(), this._disposed = true;
        }
        clearListeners() {
          this._listeners && (this._listeners.length = 0);
        }
      }, t2.forwardEvent = function(e3, t3) {
        return e3((e4) => t3.fire(e4));
      }, t2.runAndSubscribe = function(e3, t3) {
        return t3(undefined), e3((e4) => t3(e4));
      };
    }, 859: (e2, t2) => {
      function i2(e3) {
        for (const t3 of e3)
          t3.dispose();
        e3.length = 0;
      }
      Object.defineProperty(t2, "__esModule", { value: true }), t2.getDisposeArrayDisposable = t2.disposeArray = t2.toDisposable = t2.MutableDisposable = t2.Disposable = undefined, t2.Disposable = class {
        constructor() {
          this._disposables = [], this._isDisposed = false;
        }
        dispose() {
          this._isDisposed = true;
          for (const e3 of this._disposables)
            e3.dispose();
          this._disposables.length = 0;
        }
        register(e3) {
          return this._disposables.push(e3), e3;
        }
        unregister(e3) {
          const t3 = this._disposables.indexOf(e3);
          t3 !== -1 && this._disposables.splice(t3, 1);
        }
      }, t2.MutableDisposable = class {
        constructor() {
          this._isDisposed = false;
        }
        get value() {
          return this._isDisposed ? undefined : this._value;
        }
        set value(e3) {
          this._isDisposed || e3 === this._value || (this._value?.dispose(), this._value = e3);
        }
        clear() {
          this.value = undefined;
        }
        dispose() {
          this._isDisposed = true, this._value?.dispose(), this._value = undefined;
        }
      }, t2.toDisposable = function(e3) {
        return { dispose: e3 };
      }, t2.disposeArray = i2, t2.getDisposeArrayDisposable = function(e3) {
        return { dispose: () => i2(e3) };
      };
    }, 485: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.FourKeyMap = t2.TwoKeyMap = undefined;

      class i2 {
        constructor() {
          this._data = {};
        }
        set(e3, t3, i3) {
          this._data[e3] || (this._data[e3] = {}), this._data[e3][t3] = i3;
        }
        get(e3, t3) {
          return this._data[e3] ? this._data[e3][t3] : undefined;
        }
        clear() {
          this._data = {};
        }
      }
      t2.TwoKeyMap = i2, t2.FourKeyMap = class {
        constructor() {
          this._data = new i2;
        }
        set(e3, t3, s2, r, o) {
          this._data.get(e3, t3) || this._data.set(e3, t3, new i2), this._data.get(e3, t3).set(s2, r, o);
        }
        get(e3, t3, i3, s2) {
          return this._data.get(e3, t3)?.get(i3, s2);
        }
        clear() {
          this._data.clear();
        }
      };
    }, 399: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.isChromeOS = t2.isLinux = t2.isWindows = t2.isIphone = t2.isIpad = t2.isMac = t2.getSafariVersion = t2.isSafari = t2.isLegacyEdge = t2.isFirefox = t2.isNode = undefined, t2.isNode = typeof process != "undefined";
      const i2 = t2.isNode ? "node" : navigator.userAgent, s2 = t2.isNode ? "node" : navigator.platform;
      t2.isFirefox = i2.includes("Firefox"), t2.isLegacyEdge = i2.includes("Edge"), t2.isSafari = /^((?!chrome|android).)*safari/i.test(i2), t2.getSafariVersion = function() {
        if (!t2.isSafari)
          return 0;
        const e3 = i2.match(/Version\/(\d+)/);
        return e3 === null || e3.length < 2 ? 0 : parseInt(e3[1]);
      }, t2.isMac = ["Macintosh", "MacIntel", "MacPPC", "Mac68K"].includes(s2), t2.isIpad = s2 === "iPad", t2.isIphone = s2 === "iPhone", t2.isWindows = ["Windows", "Win16", "Win32", "WinCE"].includes(s2), t2.isLinux = s2.indexOf("Linux") >= 0, t2.isChromeOS = /\bCrOS\b/.test(i2);
    }, 385: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.DebouncedIdleTask = t2.IdleTaskQueue = t2.PriorityTaskQueue = undefined;
      const s2 = i2(399);

      class r {
        constructor() {
          this._tasks = [], this._i = 0;
        }
        enqueue(e3) {
          this._tasks.push(e3), this._start();
        }
        flush() {
          for (;this._i < this._tasks.length; )
            this._tasks[this._i]() || this._i++;
          this.clear();
        }
        clear() {
          this._idleCallback && (this._cancelCallback(this._idleCallback), this._idleCallback = undefined), this._i = 0, this._tasks.length = 0;
        }
        _start() {
          this._idleCallback || (this._idleCallback = this._requestCallback(this._process.bind(this)));
        }
        _process(e3) {
          this._idleCallback = undefined;
          let t3 = 0, i3 = 0, s3 = e3.timeRemaining(), r2 = 0;
          for (;this._i < this._tasks.length; ) {
            if (t3 = Date.now(), this._tasks[this._i]() || this._i++, t3 = Math.max(1, Date.now() - t3), i3 = Math.max(t3, i3), r2 = e3.timeRemaining(), 1.5 * i3 > r2)
              return s3 - t3 < -20 && console.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(s3 - t3))}ms`), void this._start();
            s3 = r2;
          }
          this.clear();
        }
      }

      class o extends r {
        _requestCallback(e3) {
          return setTimeout(() => e3(this._createDeadline(16)));
        }
        _cancelCallback(e3) {
          clearTimeout(e3);
        }
        _createDeadline(e3) {
          const t3 = Date.now() + e3;
          return { timeRemaining: () => Math.max(0, t3 - Date.now()) };
        }
      }
      t2.PriorityTaskQueue = o, t2.IdleTaskQueue = !s2.isNode && ("requestIdleCallback" in window) ? class extends r {
        _requestCallback(e3) {
          return requestIdleCallback(e3);
        }
        _cancelCallback(e3) {
          cancelIdleCallback(e3);
        }
      } : o, t2.DebouncedIdleTask = class {
        constructor() {
          this._queue = new t2.IdleTaskQueue;
        }
        set(e3) {
          this._queue.clear(), this._queue.enqueue(e3);
        }
        flush() {
          this._queue.flush();
        }
      };
    }, 147: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.ExtendedAttrs = t2.AttributeData = undefined;

      class i2 {
        constructor() {
          this.fg = 0, this.bg = 0, this.extended = new s2;
        }
        static toColorRGB(e3) {
          return [e3 >>> 16 & 255, e3 >>> 8 & 255, 255 & e3];
        }
        static fromColorRGB(e3) {
          return (255 & e3[0]) << 16 | (255 & e3[1]) << 8 | 255 & e3[2];
        }
        clone() {
          const e3 = new i2;
          return e3.fg = this.fg, e3.bg = this.bg, e3.extended = this.extended.clone(), e3;
        }
        isInverse() {
          return 67108864 & this.fg;
        }
        isBold() {
          return 134217728 & this.fg;
        }
        isUnderline() {
          return this.hasExtendedAttrs() && this.extended.underlineStyle !== 0 ? 1 : 268435456 & this.fg;
        }
        isBlink() {
          return 536870912 & this.fg;
        }
        isInvisible() {
          return 1073741824 & this.fg;
        }
        isItalic() {
          return 67108864 & this.bg;
        }
        isDim() {
          return 134217728 & this.bg;
        }
        isStrikethrough() {
          return 2147483648 & this.fg;
        }
        isProtected() {
          return 536870912 & this.bg;
        }
        isOverline() {
          return 1073741824 & this.bg;
        }
        getFgColorMode() {
          return 50331648 & this.fg;
        }
        getBgColorMode() {
          return 50331648 & this.bg;
        }
        isFgRGB() {
          return (50331648 & this.fg) == 50331648;
        }
        isBgRGB() {
          return (50331648 & this.bg) == 50331648;
        }
        isFgPalette() {
          return (50331648 & this.fg) == 16777216 || (50331648 & this.fg) == 33554432;
        }
        isBgPalette() {
          return (50331648 & this.bg) == 16777216 || (50331648 & this.bg) == 33554432;
        }
        isFgDefault() {
          return (50331648 & this.fg) == 0;
        }
        isBgDefault() {
          return (50331648 & this.bg) == 0;
        }
        isAttributeDefault() {
          return this.fg === 0 && this.bg === 0;
        }
        getFgColor() {
          switch (50331648 & this.fg) {
            case 16777216:
            case 33554432:
              return 255 & this.fg;
            case 50331648:
              return 16777215 & this.fg;
            default:
              return -1;
          }
        }
        getBgColor() {
          switch (50331648 & this.bg) {
            case 16777216:
            case 33554432:
              return 255 & this.bg;
            case 50331648:
              return 16777215 & this.bg;
            default:
              return -1;
          }
        }
        hasExtendedAttrs() {
          return 268435456 & this.bg;
        }
        updateExtended() {
          this.extended.isEmpty() ? this.bg &= -268435457 : this.bg |= 268435456;
        }
        getUnderlineColor() {
          if (268435456 & this.bg && ~this.extended.underlineColor)
            switch (50331648 & this.extended.underlineColor) {
              case 16777216:
              case 33554432:
                return 255 & this.extended.underlineColor;
              case 50331648:
                return 16777215 & this.extended.underlineColor;
              default:
                return this.getFgColor();
            }
          return this.getFgColor();
        }
        getUnderlineColorMode() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 & this.extended.underlineColor : this.getFgColorMode();
        }
        isUnderlineColorRGB() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 50331648 : this.isFgRGB();
        }
        isUnderlineColorPalette() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 16777216 || (50331648 & this.extended.underlineColor) == 33554432 : this.isFgPalette();
        }
        isUnderlineColorDefault() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 0 : this.isFgDefault();
        }
        getUnderlineStyle() {
          return 268435456 & this.fg ? 268435456 & this.bg ? this.extended.underlineStyle : 1 : 0;
        }
      }
      t2.AttributeData = i2;

      class s2 {
        get ext() {
          return this._urlId ? -469762049 & this._ext | this.underlineStyle << 26 : this._ext;
        }
        set ext(e3) {
          this._ext = e3;
        }
        get underlineStyle() {
          return this._urlId ? 5 : (469762048 & this._ext) >> 26;
        }
        set underlineStyle(e3) {
          this._ext &= -469762049, this._ext |= e3 << 26 & 469762048;
        }
        get underlineColor() {
          return 67108863 & this._ext;
        }
        set underlineColor(e3) {
          this._ext &= -67108864, this._ext |= 67108863 & e3;
        }
        get urlId() {
          return this._urlId;
        }
        set urlId(e3) {
          this._urlId = e3;
        }
        constructor(e3 = 0, t3 = 0) {
          this._ext = 0, this._urlId = 0, this._ext = e3, this._urlId = t3;
        }
        clone() {
          return new s2(this._ext, this._urlId);
        }
        isEmpty() {
          return this.underlineStyle === 0 && this._urlId === 0;
        }
      }
      t2.ExtendedAttrs = s2;
    }, 782: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.CellData = undefined;
      const s2 = i2(133), r = i2(855), o = i2(147);

      class n extends o.AttributeData {
        constructor() {
          super(...arguments), this.content = 0, this.fg = 0, this.bg = 0, this.extended = new o.ExtendedAttrs, this.combinedData = "";
        }
        static fromCharData(e3) {
          const t3 = new n;
          return t3.setFromCharData(e3), t3;
        }
        isCombined() {
          return 2097152 & this.content;
        }
        getWidth() {
          return this.content >> 22;
        }
        getChars() {
          return 2097152 & this.content ? this.combinedData : 2097151 & this.content ? (0, s2.stringFromCodePoint)(2097151 & this.content) : "";
        }
        getCode() {
          return this.isCombined() ? this.combinedData.charCodeAt(this.combinedData.length - 1) : 2097151 & this.content;
        }
        setFromCharData(e3) {
          this.fg = e3[r.CHAR_DATA_ATTR_INDEX], this.bg = 0;
          let t3 = false;
          if (e3[r.CHAR_DATA_CHAR_INDEX].length > 2)
            t3 = true;
          else if (e3[r.CHAR_DATA_CHAR_INDEX].length === 2) {
            const i3 = e3[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0);
            if (55296 <= i3 && i3 <= 56319) {
              const s3 = e3[r.CHAR_DATA_CHAR_INDEX].charCodeAt(1);
              56320 <= s3 && s3 <= 57343 ? this.content = 1024 * (i3 - 55296) + s3 - 56320 + 65536 | e3[r.CHAR_DATA_WIDTH_INDEX] << 22 : t3 = true;
            } else
              t3 = true;
          } else
            this.content = e3[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | e3[r.CHAR_DATA_WIDTH_INDEX] << 22;
          t3 && (this.combinedData = e3[r.CHAR_DATA_CHAR_INDEX], this.content = 2097152 | e3[r.CHAR_DATA_WIDTH_INDEX] << 22);
        }
        getAsCharData() {
          return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
        }
      }
      t2.CellData = n;
    }, 855: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.WHITESPACE_CELL_CODE = t2.WHITESPACE_CELL_WIDTH = t2.WHITESPACE_CELL_CHAR = t2.NULL_CELL_CODE = t2.NULL_CELL_WIDTH = t2.NULL_CELL_CHAR = t2.CHAR_DATA_CODE_INDEX = t2.CHAR_DATA_WIDTH_INDEX = t2.CHAR_DATA_CHAR_INDEX = t2.CHAR_DATA_ATTR_INDEX = t2.DEFAULT_EXT = t2.DEFAULT_ATTR = t2.DEFAULT_COLOR = undefined, t2.DEFAULT_COLOR = 0, t2.DEFAULT_ATTR = 256 | t2.DEFAULT_COLOR << 9, t2.DEFAULT_EXT = 0, t2.CHAR_DATA_ATTR_INDEX = 0, t2.CHAR_DATA_CHAR_INDEX = 1, t2.CHAR_DATA_WIDTH_INDEX = 2, t2.CHAR_DATA_CODE_INDEX = 3, t2.NULL_CELL_CHAR = "", t2.NULL_CELL_WIDTH = 1, t2.NULL_CELL_CODE = 0, t2.WHITESPACE_CELL_CHAR = " ", t2.WHITESPACE_CELL_WIDTH = 1, t2.WHITESPACE_CELL_CODE = 32;
    }, 133: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.Utf8ToUtf32 = t2.StringToUtf32 = t2.utf32ToString = t2.stringFromCodePoint = undefined, t2.stringFromCodePoint = function(e3) {
        return e3 > 65535 ? (e3 -= 65536, String.fromCharCode(55296 + (e3 >> 10)) + String.fromCharCode(e3 % 1024 + 56320)) : String.fromCharCode(e3);
      }, t2.utf32ToString = function(e3, t3 = 0, i2 = e3.length) {
        let s2 = "";
        for (let r = t3;r < i2; ++r) {
          let t4 = e3[r];
          t4 > 65535 ? (t4 -= 65536, s2 += String.fromCharCode(55296 + (t4 >> 10)) + String.fromCharCode(t4 % 1024 + 56320)) : s2 += String.fromCharCode(t4);
        }
        return s2;
      }, t2.StringToUtf32 = class {
        constructor() {
          this._interim = 0;
        }
        clear() {
          this._interim = 0;
        }
        decode(e3, t3) {
          const i2 = e3.length;
          if (!i2)
            return 0;
          let s2 = 0, r = 0;
          if (this._interim) {
            const i3 = e3.charCodeAt(r++);
            56320 <= i3 && i3 <= 57343 ? t3[s2++] = 1024 * (this._interim - 55296) + i3 - 56320 + 65536 : (t3[s2++] = this._interim, t3[s2++] = i3), this._interim = 0;
          }
          for (let o = r;o < i2; ++o) {
            const r2 = e3.charCodeAt(o);
            if (55296 <= r2 && r2 <= 56319) {
              if (++o >= i2)
                return this._interim = r2, s2;
              const n = e3.charCodeAt(o);
              56320 <= n && n <= 57343 ? t3[s2++] = 1024 * (r2 - 55296) + n - 56320 + 65536 : (t3[s2++] = r2, t3[s2++] = n);
            } else
              r2 !== 65279 && (t3[s2++] = r2);
          }
          return s2;
        }
      }, t2.Utf8ToUtf32 = class {
        constructor() {
          this.interim = new Uint8Array(3);
        }
        clear() {
          this.interim.fill(0);
        }
        decode(e3, t3) {
          const i2 = e3.length;
          if (!i2)
            return 0;
          let s2, r, o, n, a = 0, h = 0, l = 0;
          if (this.interim[0]) {
            let s3 = false, r2 = this.interim[0];
            r2 &= (224 & r2) == 192 ? 31 : (240 & r2) == 224 ? 15 : 7;
            let o2, n2 = 0;
            for (;(o2 = 63 & this.interim[++n2]) && n2 < 4; )
              r2 <<= 6, r2 |= o2;
            const h2 = (224 & this.interim[0]) == 192 ? 2 : (240 & this.interim[0]) == 224 ? 3 : 4, c2 = h2 - n2;
            for (;l < c2; ) {
              if (l >= i2)
                return 0;
              if (o2 = e3[l++], (192 & o2) != 128) {
                l--, s3 = true;
                break;
              }
              this.interim[n2++] = o2, r2 <<= 6, r2 |= 63 & o2;
            }
            s3 || (h2 === 2 ? r2 < 128 ? l-- : t3[a++] = r2 : h2 === 3 ? r2 < 2048 || r2 >= 55296 && r2 <= 57343 || r2 === 65279 || (t3[a++] = r2) : r2 < 65536 || r2 > 1114111 || (t3[a++] = r2)), this.interim.fill(0);
          }
          const c = i2 - 4;
          let d = l;
          for (;d < i2; ) {
            for (;!(!(d < c) || 128 & (s2 = e3[d]) || 128 & (r = e3[d + 1]) || 128 & (o = e3[d + 2]) || 128 & (n = e3[d + 3])); )
              t3[a++] = s2, t3[a++] = r, t3[a++] = o, t3[a++] = n, d += 4;
            if (s2 = e3[d++], s2 < 128)
              t3[a++] = s2;
            else if ((224 & s2) == 192) {
              if (d >= i2)
                return this.interim[0] = s2, a;
              if (r = e3[d++], (192 & r) != 128) {
                d--;
                continue;
              }
              if (h = (31 & s2) << 6 | 63 & r, h < 128) {
                d--;
                continue;
              }
              t3[a++] = h;
            } else if ((240 & s2) == 224) {
              if (d >= i2)
                return this.interim[0] = s2, a;
              if (r = e3[d++], (192 & r) != 128) {
                d--;
                continue;
              }
              if (d >= i2)
                return this.interim[0] = s2, this.interim[1] = r, a;
              if (o = e3[d++], (192 & o) != 128) {
                d--;
                continue;
              }
              if (h = (15 & s2) << 12 | (63 & r) << 6 | 63 & o, h < 2048 || h >= 55296 && h <= 57343 || h === 65279)
                continue;
              t3[a++] = h;
            } else if ((248 & s2) == 240) {
              if (d >= i2)
                return this.interim[0] = s2, a;
              if (r = e3[d++], (192 & r) != 128) {
                d--;
                continue;
              }
              if (d >= i2)
                return this.interim[0] = s2, this.interim[1] = r, a;
              if (o = e3[d++], (192 & o) != 128) {
                d--;
                continue;
              }
              if (d >= i2)
                return this.interim[0] = s2, this.interim[1] = r, this.interim[2] = o, a;
              if (n = e3[d++], (192 & n) != 128) {
                d--;
                continue;
              }
              if (h = (7 & s2) << 18 | (63 & r) << 12 | (63 & o) << 6 | 63 & n, h < 65536 || h > 1114111)
                continue;
              t3[a++] = h;
            }
          }
          return a;
        }
      };
    }, 776: function(e2, t2, i2) {
      var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
        var r2, o2 = arguments.length, n2 = o2 < 3 ? t3 : s3 === null ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          n2 = Reflect.decorate(e3, t3, i3, s3);
        else
          for (var a2 = e3.length - 1;a2 >= 0; a2--)
            (r2 = e3[a2]) && (n2 = (o2 < 3 ? r2(n2) : o2 > 3 ? r2(t3, i3, n2) : r2(t3, i3)) || n2);
        return o2 > 3 && n2 && Object.defineProperty(t3, i3, n2), n2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i3, s3) {
          t3(i3, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.traceCall = t2.setTraceLogger = t2.LogService = undefined;
      const o = i2(859), n = i2(97), a = { trace: n.LogLevelEnum.TRACE, debug: n.LogLevelEnum.DEBUG, info: n.LogLevelEnum.INFO, warn: n.LogLevelEnum.WARN, error: n.LogLevelEnum.ERROR, off: n.LogLevelEnum.OFF };
      let h, l = t2.LogService = class extends o.Disposable {
        get logLevel() {
          return this._logLevel;
        }
        constructor(e3) {
          super(), this._optionsService = e3, this._logLevel = n.LogLevelEnum.OFF, this._updateLogLevel(), this.register(this._optionsService.onSpecificOptionChange("logLevel", () => this._updateLogLevel())), h = this;
        }
        _updateLogLevel() {
          this._logLevel = a[this._optionsService.rawOptions.logLevel];
        }
        _evalLazyOptionalParams(e3) {
          for (let t3 = 0;t3 < e3.length; t3++)
            typeof e3[t3] == "function" && (e3[t3] = e3[t3]());
        }
        _log(e3, t3, i3) {
          this._evalLazyOptionalParams(i3), e3.call(console, (this._optionsService.options.logger ? "" : "xterm.js: ") + t3, ...i3);
        }
        trace(e3, ...t3) {
          this._logLevel <= n.LogLevelEnum.TRACE && this._log(this._optionsService.options.logger?.trace.bind(this._optionsService.options.logger) ?? console.log, e3, t3);
        }
        debug(e3, ...t3) {
          this._logLevel <= n.LogLevelEnum.DEBUG && this._log(this._optionsService.options.logger?.debug.bind(this._optionsService.options.logger) ?? console.log, e3, t3);
        }
        info(e3, ...t3) {
          this._logLevel <= n.LogLevelEnum.INFO && this._log(this._optionsService.options.logger?.info.bind(this._optionsService.options.logger) ?? console.info, e3, t3);
        }
        warn(e3, ...t3) {
          this._logLevel <= n.LogLevelEnum.WARN && this._log(this._optionsService.options.logger?.warn.bind(this._optionsService.options.logger) ?? console.warn, e3, t3);
        }
        error(e3, ...t3) {
          this._logLevel <= n.LogLevelEnum.ERROR && this._log(this._optionsService.options.logger?.error.bind(this._optionsService.options.logger) ?? console.error, e3, t3);
        }
      };
      t2.LogService = l = s2([r(0, n.IOptionsService)], l), t2.setTraceLogger = function(e3) {
        h = e3;
      }, t2.traceCall = function(e3, t3, i3) {
        if (typeof i3.value != "function")
          throw new Error("not supported");
        const s3 = i3.value;
        i3.value = function(...e4) {
          if (h.logLevel !== n.LogLevelEnum.TRACE)
            return s3.apply(this, e4);
          h.trace(`GlyphRenderer#${s3.name}(${e4.map((e5) => JSON.stringify(e5)).join(", ")})`);
          const t4 = s3.apply(this, e4);
          return h.trace(`GlyphRenderer#${s3.name} return`, t4), t4;
        };
      };
    }, 726: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.createDecorator = t2.getServiceDependencies = t2.serviceRegistry = undefined;
      const i2 = "di$target", s2 = "di$dependencies";
      t2.serviceRegistry = new Map, t2.getServiceDependencies = function(e3) {
        return e3[s2] || [];
      }, t2.createDecorator = function(e3) {
        if (t2.serviceRegistry.has(e3))
          return t2.serviceRegistry.get(e3);
        const r = function(e4, t3, o) {
          if (arguments.length !== 3)
            throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
          (function(e5, t4, r2) {
            t4[i2] === t4 ? t4[s2].push({ id: e5, index: r2 }) : (t4[s2] = [{ id: e5, index: r2 }], t4[i2] = t4);
          })(r, e4, o);
        };
        return r.toString = () => e3, t2.serviceRegistry.set(e3, r), r;
      };
    }, 97: (e2, t2, i2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.IDecorationService = t2.IUnicodeService = t2.IOscLinkService = t2.IOptionsService = t2.ILogService = t2.LogLevelEnum = t2.IInstantiationService = t2.ICharsetService = t2.ICoreService = t2.ICoreMouseService = t2.IBufferService = undefined;
      const s2 = i2(726);
      var r;
      t2.IBufferService = (0, s2.createDecorator)("BufferService"), t2.ICoreMouseService = (0, s2.createDecorator)("CoreMouseService"), t2.ICoreService = (0, s2.createDecorator)("CoreService"), t2.ICharsetService = (0, s2.createDecorator)("CharsetService"), t2.IInstantiationService = (0, s2.createDecorator)("InstantiationService"), function(e3) {
        e3[e3.TRACE = 0] = "TRACE", e3[e3.DEBUG = 1] = "DEBUG", e3[e3.INFO = 2] = "INFO", e3[e3.WARN = 3] = "WARN", e3[e3.ERROR = 4] = "ERROR", e3[e3.OFF = 5] = "OFF";
      }(r || (t2.LogLevelEnum = r = {})), t2.ILogService = (0, s2.createDecorator)("LogService"), t2.IOptionsService = (0, s2.createDecorator)("OptionsService"), t2.IOscLinkService = (0, s2.createDecorator)("OscLinkService"), t2.IUnicodeService = (0, s2.createDecorator)("UnicodeService"), t2.IDecorationService = (0, s2.createDecorator)("DecorationService");
    } }, t = {};
    function i(s2) {
      var r = t[s2];
      if (r !== undefined)
        return r.exports;
      var o = t[s2] = { exports: {} };
      return e[s2].call(o.exports, o, o.exports, i), o.exports;
    }
    var s = {};
    return (() => {
      var e2 = s;
      Object.defineProperty(e2, "__esModule", { value: true }), e2.WebglAddon = undefined;
      const t2 = i(345), r = i(859), o = i(399), n = i(666), a = i(776);

      class h extends r.Disposable {
        constructor(e3) {
          if (o.isSafari && (0, o.getSafariVersion)() < 16)
            throw new Error("Webgl2 is only supported on Safari 16 and above");
          super(), this._preserveDrawingBuffer = e3, this._onChangeTextureAtlas = this.register(new t2.EventEmitter), this.onChangeTextureAtlas = this._onChangeTextureAtlas.event, this._onAddTextureAtlasCanvas = this.register(new t2.EventEmitter), this.onAddTextureAtlasCanvas = this._onAddTextureAtlasCanvas.event, this._onRemoveTextureAtlasCanvas = this.register(new t2.EventEmitter), this.onRemoveTextureAtlasCanvas = this._onRemoveTextureAtlasCanvas.event, this._onContextLoss = this.register(new t2.EventEmitter), this.onContextLoss = this._onContextLoss.event;
        }
        activate(e3) {
          const i2 = e3._core;
          if (!e3.element)
            return void this.register(i2.onWillOpen(() => this.activate(e3)));
          this._terminal = e3;
          const { coreService: s2, optionsService: o2 } = i2, h2 = i2, l = h2._renderService, c = h2._characterJoinerService, d = h2._charSizeService, _ = h2._coreBrowserService, u = h2._decorationService, g = h2._logService, v = h2._themeService;
          (0, a.setTraceLogger)(g), this._renderer = this.register(new n.WebglRenderer(e3, c, d, _, s2, u, o2, v, this._preserveDrawingBuffer)), this.register((0, t2.forwardEvent)(this._renderer.onContextLoss, this._onContextLoss)), this.register((0, t2.forwardEvent)(this._renderer.onChangeTextureAtlas, this._onChangeTextureAtlas)), this.register((0, t2.forwardEvent)(this._renderer.onAddTextureAtlasCanvas, this._onAddTextureAtlasCanvas)), this.register((0, t2.forwardEvent)(this._renderer.onRemoveTextureAtlasCanvas, this._onRemoveTextureAtlasCanvas)), l.setRenderer(this._renderer), this.register((0, r.toDisposable)(() => {
            const t3 = this._terminal._core._renderService;
            t3.setRenderer(this._terminal._core._createRenderer()), t3.handleResize(e3.cols, e3.rows);
          }));
        }
        get textureAtlas() {
          return this._renderer?.textureAtlas;
        }
        clearTextureAtlas() {
          this._renderer?.clearTextureAtlas();
        }
      }
      e2.WebglAddon = h;
    })(), s;
  })());
});

// current_keymaps.js
var exports_current_keymaps = {};
__export(exports_current_keymaps, {
  default: () => {
    {
      return current_keymaps_default;
    }
  }
});
var current_keymaps_default;
var init_current_keymaps = __esm(() => {
  current_keymaps_default = JSON.parse('{"KeyA":{"unmodified":"a","withShift":"A","withAltGraph":"\xE5","withAltGraphShift":"\xC5"},"KeyB":{"unmodified":"b","withShift":"B","withAltGraph":"\u222B","withAltGraphShift":"\u0131"},"KeyC":{"unmodified":"c","withShift":"C","withAltGraph":"\xE7","withAltGraphShift":"\xC7"},"KeyD":{"unmodified":"d","withShift":"D","withAltGraph":"\u2202","withAltGraphShift":"\xCE"},"KeyE":{"unmodified":"e","withShift":"E","withAltGraph":"\xB4","withAltGraphShift":"\xB4"},"KeyF":{"unmodified":"f","withShift":"F","withAltGraph":"\u0192","withAltGraphShift":"\xCF"},"KeyG":{"unmodified":"g","withShift":"G","withAltGraph":"\xA9","withAltGraphShift":"\u02DD"},"KeyH":{"unmodified":"h","withShift":"H","withAltGraph":"\u02D9","withAltGraphShift":"\xD3"},"KeyI":{"unmodified":"i","withShift":"I","withAltGraph":"\u02C6","withAltGraphShift":"\u02C6"},"KeyJ":{"unmodified":"j","withShift":"J","withAltGraph":"\u2206","withAltGraphShift":"\xD4"},"KeyK":{"unmodified":"k","withShift":"K","withAltGraph":"\u02DA","withAltGraphShift":"\uF8FF"},"KeyL":{"unmodified":"l","withShift":"L","withAltGraph":"\xAC","withAltGraphShift":"\xD2"},"KeyM":{"unmodified":"m","withShift":"M","withAltGraph":"\xB5","withAltGraphShift":"\xC2"},"KeyN":{"unmodified":"n","withShift":"N","withAltGraph":"\u02DC","withAltGraphShift":"\u02DC"},"KeyO":{"unmodified":"o","withShift":"O","withAltGraph":"\xF8","withAltGraphShift":"\xD8"},"KeyP":{"unmodified":"p","withShift":"P","withAltGraph":"\u03C0","withAltGraphShift":"\u220F"},"KeyQ":{"unmodified":"q","withShift":"Q","withAltGraph":"\u0153","withAltGraphShift":"\u0152"},"KeyR":{"unmodified":"r","withShift":"R","withAltGraph":"\xAE","withAltGraphShift":"\u2030"},"KeyS":{"unmodified":"s","withShift":"S","withAltGraph":"\xDF","withAltGraphShift":"\xCD"},"KeyT":{"unmodified":"t","withShift":"T","withAltGraph":"\u2020","withAltGraphShift":"\u02C7"},"KeyU":{"unmodified":"u","withShift":"U","withAltGraph":"\xA8","withAltGraphShift":"\xA8"},"KeyV":{"unmodified":"v","withShift":"V","withAltGraph":"\u221A","withAltGraphShift":"\u25CA"},"KeyW":{"unmodified":"w","withShift":"W","withAltGraph":"\u2211","withAltGraphShift":"\u201E"},"KeyX":{"unmodified":"x","withShift":"X","withAltGraph":"\u2248","withAltGraphShift":"\u02DB"},"KeyY":{"unmodified":"y","withShift":"Y","withAltGraph":"\xA5","withAltGraphShift":"\xC1"},"KeyZ":{"unmodified":"z","withShift":"Z","withAltGraph":"\u03A9","withAltGraphShift":"\xB8"},"Digit1":{"unmodified":"1","withShift":"!","withAltGraph":"\xA1","withAltGraphShift":"\u2044"},"Digit2":{"unmodified":"2","withShift":"@","withAltGraph":"\u2122","withAltGraphShift":"\u20AC"},"Digit3":{"unmodified":"3","withShift":"#","withAltGraph":"\xA3","withAltGraphShift":"\u2039"},"Digit4":{"unmodified":"4","withShift":"$","withAltGraph":"\xA2","withAltGraphShift":"\u203A"},"Digit5":{"unmodified":"5","withShift":"%","withAltGraph":"\u221E","withAltGraphShift":"\uFB01"},"Digit6":{"unmodified":"6","withShift":"^","withAltGraph":"\xA7","withAltGraphShift":"\uFB02"},"Digit7":{"unmodified":"7","withShift":"&","withAltGraph":"\xB6","withAltGraphShift":"\u2021"},"Digit8":{"unmodified":"8","withShift":"*","withAltGraph":"\u2022","withAltGraphShift":"\xB0"},"Digit9":{"unmodified":"9","withShift":"(","withAltGraph":"\xAA","withAltGraphShift":"\xB7"},"Digit0":{"unmodified":"0","withShift":")","withAltGraph":"\xBA","withAltGraphShift":"\u201A"},"Space":{"unmodified":" ","withShift":" ","withAltGraph":"\xA0","withAltGraphShift":"\xA0"},"Minus":{"unmodified":"-","withShift":"_","withAltGraph":"\u2013","withAltGraphShift":"\u2014"},"Equal":{"unmodified":"=","withShift":"+","withAltGraph":"\u2260","withAltGraphShift":"\xB1"},"BracketLeft":{"unmodified":"[","withShift":"{","withAltGraph":"\u201C","withAltGraphShift":"\u201D"},"BracketRight":{"unmodified":"]","withShift":"}","withAltGraph":"\u2018","withAltGraphShift":"\u2019"},"Backslash":{"unmodified":"\\\\","withShift":"|","withAltGraph":"\xAB","withAltGraphShift":"\xBB"},"Semicolon":{"unmodified":";","withShift":":","withAltGraph":"\u2026","withAltGraphShift":"\xDA"},"Quote":{"unmodified":"\'","withShift":"\\"","withAltGraph":"\xE6","withAltGraphShift":"\xC6"},"Backquote":{"unmodified":"`","withShift":"~","withAltGraph":"`","withAltGraphShift":"`"},"Comma":{"unmodified":",","withShift":"<","withAltGraph":"\u2264","withAltGraphShift":"\xAF"},"Period":{"unmodified":".","withShift":">","withAltGraph":"\u2265","withAltGraphShift":"\u02D8"},"Slash":{"unmodified":"/","withShift":"?","withAltGraph":"\xF7","withAltGraphShift":"\xBF"},"NumpadDivide":{"unmodified":"/","withShift":"/","withAltGraph":"/","withAltGraphShift":"/"},"NumpadMultiply":{"unmodified":"*","withShift":"*","withAltGraph":"*","withAltGraphShift":"*"},"NumpadSubtract":{"unmodified":"-","withShift":"-","withAltGraph":"-","withAltGraphShift":"-"},"NumpadAdd":{"unmodified":"+","withShift":"+","withAltGraph":"+","withAltGraphShift":"+"},"Numpad1":{"unmodified":"1","withShift":"1","withAltGraph":"1","withAltGraphShift":"1"},"Numpad2":{"unmodified":"2","withShift":"2","withAltGraph":"2","withAltGraphShift":"2"},"Numpad3":{"unmodified":"3","withShift":"3","withAltGraph":"3","withAltGraphShift":"3"},"Numpad4":{"unmodified":"4","withShift":"4","withAltGraph":"4","withAltGraphShift":"4"},"Numpad5":{"unmodified":"5","withShift":"5","withAltGraph":"5","withAltGraphShift":"5"},"Numpad6":{"unmodified":"6","withShift":"6","withAltGraph":"6","withAltGraphShift":"6"},"Numpad7":{"unmodified":"7","withShift":"7","withAltGraph":"7","withAltGraphShift":"7"},"Numpad8":{"unmodified":"8","withShift":"8","withAltGraph":"8","withAltGraphShift":"8"},"Numpad9":{"unmodified":"9","withShift":"9","withAltGraph":"9","withAltGraphShift":"9"},"Numpad0":{"unmodified":"0","withShift":"0","withAltGraph":"0","withAltGraphShift":"0"},"NumpadDecimal":{"unmodified":".","withShift":".","withAltGraph":".","withAltGraphShift":"."},"IntlBackslash":{"unmodified":"\xA7","withShift":"\xB1","withAltGraph":"\xA7","withAltGraphShift":"\xB1"},"NumpadEqual":{"unmodified":"=","withShift":"=","withAltGraph":"=","withAltGraphShift":"="},"AudioVolumeUp":{"unmodified":null,"withShift":"=","withAltGraph":null,"withAltGraphShift":"="}}');
});

// node_modules/@hotwired/stimulus/dist/stimulus.js
var extendEvent = function(event) {
  if ("immediatePropagationStopped" in event) {
    return event;
  } else {
    const { stopImmediatePropagation } = event;
    return Object.assign(event, {
      immediatePropagationStopped: false,
      stopImmediatePropagation() {
        this.immediatePropagationStopped = true;
        stopImmediatePropagation.call(this);
      }
    });
  }
};
var parseActionDescriptorString = function(descriptorString) {
  const source = descriptorString.trim();
  const matches = source.match(descriptorPattern) || [];
  let eventName = matches[2];
  let keyFilter = matches[3];
  if (keyFilter && !["keydown", "keyup", "keypress"].includes(eventName)) {
    eventName += `.${keyFilter}`;
    keyFilter = "";
  }
  return {
    eventTarget: parseEventTarget(matches[4]),
    eventName,
    eventOptions: matches[7] ? parseEventOptions(matches[7]) : {},
    identifier: matches[5],
    methodName: matches[6],
    keyFilter: matches[1] || keyFilter
  };
};
var parseEventTarget = function(eventTargetName) {
  if (eventTargetName == "window") {
    return window;
  } else if (eventTargetName == "document") {
    return document;
  }
};
var parseEventOptions = function(eventOptions) {
  return eventOptions.split(":").reduce((options, token) => Object.assign(options, { [token.replace(/^!/, "")]: !/^!/.test(token) }), {});
};
var stringifyEventTarget = function(eventTarget) {
  if (eventTarget == window) {
    return "window";
  } else if (eventTarget == document) {
    return "document";
  }
};
var camelize = function(value) {
  return value.replace(/(?:[_-])([a-z0-9])/g, (_, char) => char.toUpperCase());
};
var namespaceCamelize = function(value) {
  return camelize(value.replace(/--/g, "-").replace(/__/g, "_"));
};
var capitalize = function(value) {
  return value.charAt(0).toUpperCase() + value.slice(1);
};
var dasherize = function(value) {
  return value.replace(/([A-Z])/g, (_, char) => `-${char.toLowerCase()}`);
};
var tokenize = function(value) {
  return value.match(/[^\s]+/g) || [];
};
var isSomething = function(object) {
  return object !== null && object !== undefined;
};
var hasProperty = function(object, property) {
  return Object.prototype.hasOwnProperty.call(object, property);
};
var getDefaultEventNameForElement = function(element) {
  const tagName = element.tagName.toLowerCase();
  if (tagName in defaultEventNames) {
    return defaultEventNames[tagName](element);
  }
};
var error = function(message) {
  throw new Error(message);
};
var typecast = function(value) {
  try {
    return JSON.parse(value);
  } catch (o_O) {
    return value;
  }
};
var add = function(map, key, value) {
  fetch(map, key).add(value);
};
var del = function(map, key, value) {
  fetch(map, key).delete(value);
  prune(map, key);
};
var fetch = function(map, key) {
  let values = map.get(key);
  if (!values) {
    values = new Set;
    map.set(key, values);
  }
  return values;
};
var prune = function(map, key) {
  const values = map.get(key);
  if (values != null && values.size == 0) {
    map.delete(key);
  }
};
var parseTokenString = function(tokenString, element, attributeName) {
  return tokenString.trim().split(/\s+/).filter((content) => content.length).map((content, index) => ({ element, attributeName, content, index }));
};
var zip = function(left, right) {
  const length = Math.max(left.length, right.length);
  return Array.from({ length }, (_, index) => [left[index], right[index]]);
};
var tokensAreEqual = function(left, right) {
  return left && right && left.index == right.index && left.content == right.content;
};
var readInheritableStaticArrayValues = function(constructor, propertyName) {
  const ancestors = getAncestorsForConstructor(constructor);
  return Array.from(ancestors.reduce((values, constructor2) => {
    getOwnStaticArrayValues(constructor2, propertyName).forEach((name) => values.add(name));
    return values;
  }, new Set));
};
var readInheritableStaticObjectPairs = function(constructor, propertyName) {
  const ancestors = getAncestorsForConstructor(constructor);
  return ancestors.reduce((pairs, constructor2) => {
    pairs.push(...getOwnStaticObjectPairs(constructor2, propertyName));
    return pairs;
  }, []);
};
var getAncestorsForConstructor = function(constructor) {
  const ancestors = [];
  while (constructor) {
    ancestors.push(constructor);
    constructor = Object.getPrototypeOf(constructor);
  }
  return ancestors.reverse();
};
var getOwnStaticArrayValues = function(constructor, propertyName) {
  const definition = constructor[propertyName];
  return Array.isArray(definition) ? definition : [];
};
var getOwnStaticObjectPairs = function(constructor, propertyName) {
  const definition = constructor[propertyName];
  return definition ? Object.keys(definition).map((key) => [key, definition[key]]) : [];
};
var bless = function(constructor) {
  return shadow(constructor, getBlessedProperties(constructor));
};
var shadow = function(constructor, properties) {
  const shadowConstructor = extend(constructor);
  const shadowProperties = getShadowProperties(constructor.prototype, properties);
  Object.defineProperties(shadowConstructor.prototype, shadowProperties);
  return shadowConstructor;
};
var getBlessedProperties = function(constructor) {
  const blessings = readInheritableStaticArrayValues(constructor, "blessings");
  return blessings.reduce((blessedProperties, blessing) => {
    const properties = blessing(constructor);
    for (const key in properties) {
      const descriptor = blessedProperties[key] || {};
      blessedProperties[key] = Object.assign(descriptor, properties[key]);
    }
    return blessedProperties;
  }, {});
};
var getShadowProperties = function(prototype, properties) {
  return getOwnKeys(properties).reduce((shadowProperties, key) => {
    const descriptor = getShadowedDescriptor(prototype, properties, key);
    if (descriptor) {
      Object.assign(shadowProperties, { [key]: descriptor });
    }
    return shadowProperties;
  }, {});
};
var getShadowedDescriptor = function(prototype, properties, key) {
  const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);
  const shadowedByValue = shadowingDescriptor && ("value" in shadowingDescriptor);
  if (!shadowedByValue) {
    const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;
    if (shadowingDescriptor) {
      descriptor.get = shadowingDescriptor.get || descriptor.get;
      descriptor.set = shadowingDescriptor.set || descriptor.set;
    }
    return descriptor;
  }
};
var blessDefinition = function(definition) {
  return {
    identifier: definition.identifier,
    controllerConstructor: bless(definition.controllerConstructor)
  };
};
var attributeValueContainsToken = function(attributeName, token) {
  return `[${attributeName}~="${token}"]`;
};
var objectFromEntries = function(array) {
  return array.reduce((memo, [k, v]) => Object.assign(Object.assign({}, memo), { [k]: v }), {});
};
var domReady = function() {
  return new Promise((resolve) => {
    if (document.readyState == "loading") {
      document.addEventListener("DOMContentLoaded", () => resolve());
    } else {
      resolve();
    }
  });
};
var ClassPropertiesBlessing = function(constructor) {
  const classes = readInheritableStaticArrayValues(constructor, "classes");
  return classes.reduce((properties, classDefinition) => {
    return Object.assign(properties, propertiesForClassDefinition(classDefinition));
  }, {});
};
var propertiesForClassDefinition = function(key) {
  return {
    [`${key}Class`]: {
      get() {
        const { classes } = this;
        if (classes.has(key)) {
          return classes.get(key);
        } else {
          const attribute = classes.getAttributeName(key);
          throw new Error(`Missing attribute "${attribute}"`);
        }
      }
    },
    [`${key}Classes`]: {
      get() {
        return this.classes.getAll(key);
      }
    },
    [`has${capitalize(key)}Class`]: {
      get() {
        return this.classes.has(key);
      }
    }
  };
};
var OutletPropertiesBlessing = function(constructor) {
  const outlets = readInheritableStaticArrayValues(constructor, "outlets");
  return outlets.reduce((properties, outletDefinition) => {
    return Object.assign(properties, propertiesForOutletDefinition(outletDefinition));
  }, {});
};
var getOutletController = function(controller, element, identifier) {
  return controller.application.getControllerForElementAndIdentifier(element, identifier);
};
var getControllerAndEnsureConnectedScope = function(controller, element, outletName) {
  let outletController = getOutletController(controller, element, outletName);
  if (outletController)
    return outletController;
  controller.application.router.proposeToConnectScopeForElementAndIdentifier(element, outletName);
  outletController = getOutletController(controller, element, outletName);
  if (outletController)
    return outletController;
};
var propertiesForOutletDefinition = function(name) {
  const camelizedName = namespaceCamelize(name);
  return {
    [`${camelizedName}Outlet`]: {
      get() {
        const outletElement = this.outlets.find(name);
        const selector = this.outlets.getSelectorForOutletName(name);
        if (outletElement) {
          const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
          if (outletController)
            return outletController;
          throw new Error(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`);
        }
        throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
      }
    },
    [`${camelizedName}Outlets`]: {
      get() {
        const outlets = this.outlets.findAll(name);
        if (outlets.length > 0) {
          return outlets.map((outletElement) => {
            const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
            if (outletController)
              return outletController;
            console.warn(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`, outletElement);
          }).filter((controller) => controller);
        }
        return [];
      }
    },
    [`${camelizedName}OutletElement`]: {
      get() {
        const outletElement = this.outlets.find(name);
        const selector = this.outlets.getSelectorForOutletName(name);
        if (outletElement) {
          return outletElement;
        } else {
          throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
        }
      }
    },
    [`${camelizedName}OutletElements`]: {
      get() {
        return this.outlets.findAll(name);
      }
    },
    [`has${capitalize(camelizedName)}Outlet`]: {
      get() {
        return this.outlets.has(name);
      }
    }
  };
};
var TargetPropertiesBlessing = function(constructor) {
  const targets = readInheritableStaticArrayValues(constructor, "targets");
  return targets.reduce((properties, targetDefinition) => {
    return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
  }, {});
};
var propertiesForTargetDefinition = function(name) {
  return {
    [`${name}Target`]: {
      get() {
        const target = this.targets.find(name);
        if (target) {
          return target;
        } else {
          throw new Error(`Missing target element "${name}" for "${this.identifier}" controller`);
        }
      }
    },
    [`${name}Targets`]: {
      get() {
        return this.targets.findAll(name);
      }
    },
    [`has${capitalize(name)}Target`]: {
      get() {
        return this.targets.has(name);
      }
    }
  };
};
var ValuePropertiesBlessing = function(constructor) {
  const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, "values");
  const propertyDescriptorMap = {
    valueDescriptorMap: {
      get() {
        return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {
          const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair, this.identifier);
          const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
          return Object.assign(result, { [attributeName]: valueDescriptor });
        }, {});
      }
    }
  };
  return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {
    return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
  }, propertyDescriptorMap);
};
var propertiesForValueDefinitionPair = function(valueDefinitionPair, controller) {
  const definition = parseValueDefinitionPair(valueDefinitionPair, controller);
  const { key, name, reader: read, writer: write } = definition;
  return {
    [name]: {
      get() {
        const value = this.data.get(key);
        if (value !== null) {
          return read(value);
        } else {
          return definition.defaultValue;
        }
      },
      set(value) {
        if (value === undefined) {
          this.data.delete(key);
        } else {
          this.data.set(key, write(value));
        }
      }
    },
    [`has${capitalize(name)}`]: {
      get() {
        return this.data.has(key) || definition.hasCustomDefaultValue;
      }
    }
  };
};
var parseValueDefinitionPair = function([token, typeDefinition], controller) {
  return valueDescriptorForTokenAndTypeDefinition({
    controller,
    token,
    typeDefinition
  });
};
var parseValueTypeConstant = function(constant) {
  switch (constant) {
    case Array:
      return "array";
    case Boolean:
      return "boolean";
    case Number:
      return "number";
    case Object:
      return "object";
    case String:
      return "string";
  }
};
var parseValueTypeDefault = function(defaultValue) {
  switch (typeof defaultValue) {
    case "boolean":
      return "boolean";
    case "number":
      return "number";
    case "string":
      return "string";
  }
  if (Array.isArray(defaultValue))
    return "array";
  if (Object.prototype.toString.call(defaultValue) === "[object Object]")
    return "object";
};
var parseValueTypeObject = function(payload) {
  const { controller, token, typeObject } = payload;
  const hasType = isSomething(typeObject.type);
  const hasDefault = isSomething(typeObject.default);
  const fullObject = hasType && hasDefault;
  const onlyType = hasType && !hasDefault;
  const onlyDefault = !hasType && hasDefault;
  const typeFromObject = parseValueTypeConstant(typeObject.type);
  const typeFromDefaultValue = parseValueTypeDefault(payload.typeObject.default);
  if (onlyType)
    return typeFromObject;
  if (onlyDefault)
    return typeFromDefaultValue;
  if (typeFromObject !== typeFromDefaultValue) {
    const propertyPath = controller ? `${controller}.${token}` : token;
    throw new Error(`The specified default value for the Stimulus Value "${propertyPath}" must match the defined type "${typeFromObject}". The provided default value of "${typeObject.default}" is of type "${typeFromDefaultValue}".`);
  }
  if (fullObject)
    return typeFromObject;
};
var parseValueTypeDefinition = function(payload) {
  const { controller, token, typeDefinition } = payload;
  const typeObject = { controller, token, typeObject: typeDefinition };
  const typeFromObject = parseValueTypeObject(typeObject);
  const typeFromDefaultValue = parseValueTypeDefault(typeDefinition);
  const typeFromConstant = parseValueTypeConstant(typeDefinition);
  const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
  if (type)
    return type;
  const propertyPath = controller ? `${controller}.${typeDefinition}` : token;
  throw new Error(`Unknown value type "${propertyPath}" for "${token}" value`);
};
var defaultValueForDefinition = function(typeDefinition) {
  const constant = parseValueTypeConstant(typeDefinition);
  if (constant)
    return defaultValuesByType[constant];
  const hasDefault = hasProperty(typeDefinition, "default");
  const hasType = hasProperty(typeDefinition, "type");
  const typeObject = typeDefinition;
  if (hasDefault)
    return typeObject.default;
  if (hasType) {
    const { type } = typeObject;
    const constantFromType = parseValueTypeConstant(type);
    if (constantFromType)
      return defaultValuesByType[constantFromType];
  }
  return typeDefinition;
};
var valueDescriptorForTokenAndTypeDefinition = function(payload) {
  const { token, typeDefinition } = payload;
  const key = `${dasherize(token)}-value`;
  const type = parseValueTypeDefinition(payload);
  return {
    type,
    key,
    name: camelize(key),
    get defaultValue() {
      return defaultValueForDefinition(typeDefinition);
    },
    get hasCustomDefaultValue() {
      return parseValueTypeDefault(typeDefinition) !== undefined;
    },
    reader: readers[type],
    writer: writers[type] || writers.default
  };
};
var writeJSON = function(value) {
  return JSON.stringify(value);
};
var writeString = function(value) {
  return `${value}`;
};

class EventListener {
  constructor(eventTarget, eventName, eventOptions) {
    this.eventTarget = eventTarget;
    this.eventName = eventName;
    this.eventOptions = eventOptions;
    this.unorderedBindings = new Set;
  }
  connect() {
    this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
  }
  disconnect() {
    this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
  }
  bindingConnected(binding) {
    this.unorderedBindings.add(binding);
  }
  bindingDisconnected(binding) {
    this.unorderedBindings.delete(binding);
  }
  handleEvent(event) {
    const extendedEvent = extendEvent(event);
    for (const binding of this.bindings) {
      if (extendedEvent.immediatePropagationStopped) {
        break;
      } else {
        binding.handleEvent(extendedEvent);
      }
    }
  }
  hasBindings() {
    return this.unorderedBindings.size > 0;
  }
  get bindings() {
    return Array.from(this.unorderedBindings).sort((left, right) => {
      const leftIndex = left.index, rightIndex = right.index;
      return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;
    });
  }
}

class Dispatcher {
  constructor(application) {
    this.application = application;
    this.eventListenerMaps = new Map;
    this.started = false;
  }
  start() {
    if (!this.started) {
      this.started = true;
      this.eventListeners.forEach((eventListener) => eventListener.connect());
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      this.eventListeners.forEach((eventListener) => eventListener.disconnect());
    }
  }
  get eventListeners() {
    return Array.from(this.eventListenerMaps.values()).reduce((listeners, map) => listeners.concat(Array.from(map.values())), []);
  }
  bindingConnected(binding) {
    this.fetchEventListenerForBinding(binding).bindingConnected(binding);
  }
  bindingDisconnected(binding, clearEventListeners = false) {
    this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
    if (clearEventListeners)
      this.clearEventListenersForBinding(binding);
  }
  handleError(error2, message, detail = {}) {
    this.application.handleError(error2, `Error ${message}`, detail);
  }
  clearEventListenersForBinding(binding) {
    const eventListener = this.fetchEventListenerForBinding(binding);
    if (!eventListener.hasBindings()) {
      eventListener.disconnect();
      this.removeMappedEventListenerFor(binding);
    }
  }
  removeMappedEventListenerFor(binding) {
    const { eventTarget, eventName, eventOptions } = binding;
    const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
    const cacheKey = this.cacheKey(eventName, eventOptions);
    eventListenerMap.delete(cacheKey);
    if (eventListenerMap.size == 0)
      this.eventListenerMaps.delete(eventTarget);
  }
  fetchEventListenerForBinding(binding) {
    const { eventTarget, eventName, eventOptions } = binding;
    return this.fetchEventListener(eventTarget, eventName, eventOptions);
  }
  fetchEventListener(eventTarget, eventName, eventOptions) {
    const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
    const cacheKey = this.cacheKey(eventName, eventOptions);
    let eventListener = eventListenerMap.get(cacheKey);
    if (!eventListener) {
      eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
      eventListenerMap.set(cacheKey, eventListener);
    }
    return eventListener;
  }
  createEventListener(eventTarget, eventName, eventOptions) {
    const eventListener = new EventListener(eventTarget, eventName, eventOptions);
    if (this.started) {
      eventListener.connect();
    }
    return eventListener;
  }
  fetchEventListenerMapForEventTarget(eventTarget) {
    let eventListenerMap = this.eventListenerMaps.get(eventTarget);
    if (!eventListenerMap) {
      eventListenerMap = new Map;
      this.eventListenerMaps.set(eventTarget, eventListenerMap);
    }
    return eventListenerMap;
  }
  cacheKey(eventName, eventOptions) {
    const parts = [eventName];
    Object.keys(eventOptions).sort().forEach((key) => {
      parts.push(`${eventOptions[key] ? "" : "!"}${key}`);
    });
    return parts.join(":");
  }
}
var defaultActionDescriptorFilters = {
  stop({ event, value }) {
    if (value)
      event.stopPropagation();
    return true;
  },
  prevent({ event, value }) {
    if (value)
      event.preventDefault();
    return true;
  },
  self({ event, value, element }) {
    if (value) {
      return element === event.target;
    } else {
      return true;
    }
  }
};
var descriptorPattern = /^(?:(?:([^.]+?)\+)?(.+?)(?:\.(.+?))?(?:@(window|document))?->)?(.+?)(?:#([^:]+?))(?::(.+))?$/;
var allModifiers = ["meta", "ctrl", "alt", "shift"];

class Action {
  constructor(element, index, descriptor, schema) {
    this.element = element;
    this.index = index;
    this.eventTarget = descriptor.eventTarget || element;
    this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error("missing event name");
    this.eventOptions = descriptor.eventOptions || {};
    this.identifier = descriptor.identifier || error("missing identifier");
    this.methodName = descriptor.methodName || error("missing method name");
    this.keyFilter = descriptor.keyFilter || "";
    this.schema = schema;
  }
  static forToken(token, schema) {
    return new this(token.element, token.index, parseActionDescriptorString(token.content), schema);
  }
  toString() {
    const eventFilter = this.keyFilter ? `.${this.keyFilter}` : "";
    const eventTarget = this.eventTargetName ? `@${this.eventTargetName}` : "";
    return `${this.eventName}${eventFilter}${eventTarget}->${this.identifier}#${this.methodName}`;
  }
  shouldIgnoreKeyboardEvent(event) {
    if (!this.keyFilter) {
      return false;
    }
    const filters = this.keyFilter.split("+");
    if (this.keyFilterDissatisfied(event, filters)) {
      return true;
    }
    const standardFilter = filters.filter((key) => !allModifiers.includes(key))[0];
    if (!standardFilter) {
      return false;
    }
    if (!hasProperty(this.keyMappings, standardFilter)) {
      error(`contains unknown key filter: ${this.keyFilter}`);
    }
    return this.keyMappings[standardFilter].toLowerCase() !== event.key.toLowerCase();
  }
  shouldIgnoreMouseEvent(event) {
    if (!this.keyFilter) {
      return false;
    }
    const filters = [this.keyFilter];
    if (this.keyFilterDissatisfied(event, filters)) {
      return true;
    }
    return false;
  }
  get params() {
    const params = {};
    const pattern = new RegExp(`^data-${this.identifier}-(.+)-param\$`, "i");
    for (const { name, value } of Array.from(this.element.attributes)) {
      const match = name.match(pattern);
      const key = match && match[1];
      if (key) {
        params[camelize(key)] = typecast(value);
      }
    }
    return params;
  }
  get eventTargetName() {
    return stringifyEventTarget(this.eventTarget);
  }
  get keyMappings() {
    return this.schema.keyMappings;
  }
  keyFilterDissatisfied(event, filters) {
    const [meta, ctrl, alt, shift] = allModifiers.map((modifier) => filters.includes(modifier));
    return event.metaKey !== meta || event.ctrlKey !== ctrl || event.altKey !== alt || event.shiftKey !== shift;
  }
}
var defaultEventNames = {
  a: () => "click",
  button: () => "click",
  form: () => "submit",
  details: () => "toggle",
  input: (e) => e.getAttribute("type") == "submit" ? "click" : "input",
  select: () => "change",
  textarea: () => "input"
};

class Binding {
  constructor(context, action) {
    this.context = context;
    this.action = action;
  }
  get index() {
    return this.action.index;
  }
  get eventTarget() {
    return this.action.eventTarget;
  }
  get eventOptions() {
    return this.action.eventOptions;
  }
  get identifier() {
    return this.context.identifier;
  }
  handleEvent(event) {
    const actionEvent = this.prepareActionEvent(event);
    if (this.willBeInvokedByEvent(event) && this.applyEventModifiers(actionEvent)) {
      this.invokeWithEvent(actionEvent);
    }
  }
  get eventName() {
    return this.action.eventName;
  }
  get method() {
    const method = this.controller[this.methodName];
    if (typeof method == "function") {
      return method;
    }
    throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`);
  }
  applyEventModifiers(event) {
    const { element } = this.action;
    const { actionDescriptorFilters } = this.context.application;
    const { controller } = this.context;
    let passes = true;
    for (const [name, value] of Object.entries(this.eventOptions)) {
      if (name in actionDescriptorFilters) {
        const filter = actionDescriptorFilters[name];
        passes = passes && filter({ name, value, event, element, controller });
      } else {
        continue;
      }
    }
    return passes;
  }
  prepareActionEvent(event) {
    return Object.assign(event, { params: this.action.params });
  }
  invokeWithEvent(event) {
    const { target, currentTarget } = event;
    try {
      this.method.call(this.controller, event);
      this.context.logDebugActivity(this.methodName, { event, target, currentTarget, action: this.methodName });
    } catch (error2) {
      const { identifier, controller, element, index } = this;
      const detail = { identifier, controller, element, index, event };
      this.context.handleError(error2, `invoking action "${this.action}"`, detail);
    }
  }
  willBeInvokedByEvent(event) {
    const eventTarget = event.target;
    if (event instanceof KeyboardEvent && this.action.shouldIgnoreKeyboardEvent(event)) {
      return false;
    }
    if (event instanceof MouseEvent && this.action.shouldIgnoreMouseEvent(event)) {
      return false;
    }
    if (this.element === eventTarget) {
      return true;
    } else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {
      return this.scope.containsElement(eventTarget);
    } else {
      return this.scope.containsElement(this.action.element);
    }
  }
  get controller() {
    return this.context.controller;
  }
  get methodName() {
    return this.action.methodName;
  }
  get element() {
    return this.scope.element;
  }
  get scope() {
    return this.context.scope;
  }
}

class ElementObserver {
  constructor(element, delegate) {
    this.mutationObserverInit = { attributes: true, childList: true, subtree: true };
    this.element = element;
    this.started = false;
    this.delegate = delegate;
    this.elements = new Set;
    this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
  }
  start() {
    if (!this.started) {
      this.started = true;
      this.mutationObserver.observe(this.element, this.mutationObserverInit);
      this.refresh();
    }
  }
  pause(callback) {
    if (this.started) {
      this.mutationObserver.disconnect();
      this.started = false;
    }
    callback();
    if (!this.started) {
      this.mutationObserver.observe(this.element, this.mutationObserverInit);
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      this.mutationObserver.takeRecords();
      this.mutationObserver.disconnect();
      this.started = false;
    }
  }
  refresh() {
    if (this.started) {
      const matches = new Set(this.matchElementsInTree());
      for (const element of Array.from(this.elements)) {
        if (!matches.has(element)) {
          this.removeElement(element);
        }
      }
      for (const element of Array.from(matches)) {
        this.addElement(element);
      }
    }
  }
  processMutations(mutations) {
    if (this.started) {
      for (const mutation of mutations) {
        this.processMutation(mutation);
      }
    }
  }
  processMutation(mutation) {
    if (mutation.type == "attributes") {
      this.processAttributeChange(mutation.target, mutation.attributeName);
    } else if (mutation.type == "childList") {
      this.processRemovedNodes(mutation.removedNodes);
      this.processAddedNodes(mutation.addedNodes);
    }
  }
  processAttributeChange(element, attributeName) {
    if (this.elements.has(element)) {
      if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
        this.delegate.elementAttributeChanged(element, attributeName);
      } else {
        this.removeElement(element);
      }
    } else if (this.matchElement(element)) {
      this.addElement(element);
    }
  }
  processRemovedNodes(nodes) {
    for (const node of Array.from(nodes)) {
      const element = this.elementFromNode(node);
      if (element) {
        this.processTree(element, this.removeElement);
      }
    }
  }
  processAddedNodes(nodes) {
    for (const node of Array.from(nodes)) {
      const element = this.elementFromNode(node);
      if (element && this.elementIsActive(element)) {
        this.processTree(element, this.addElement);
      }
    }
  }
  matchElement(element) {
    return this.delegate.matchElement(element);
  }
  matchElementsInTree(tree = this.element) {
    return this.delegate.matchElementsInTree(tree);
  }
  processTree(tree, processor) {
    for (const element of this.matchElementsInTree(tree)) {
      processor.call(this, element);
    }
  }
  elementFromNode(node) {
    if (node.nodeType == Node.ELEMENT_NODE) {
      return node;
    }
  }
  elementIsActive(element) {
    if (element.isConnected != this.element.isConnected) {
      return false;
    } else {
      return this.element.contains(element);
    }
  }
  addElement(element) {
    if (!this.elements.has(element)) {
      if (this.elementIsActive(element)) {
        this.elements.add(element);
        if (this.delegate.elementMatched) {
          this.delegate.elementMatched(element);
        }
      }
    }
  }
  removeElement(element) {
    if (this.elements.has(element)) {
      this.elements.delete(element);
      if (this.delegate.elementUnmatched) {
        this.delegate.elementUnmatched(element);
      }
    }
  }
}

class AttributeObserver {
  constructor(element, attributeName, delegate) {
    this.attributeName = attributeName;
    this.delegate = delegate;
    this.elementObserver = new ElementObserver(element, this);
  }
  get element() {
    return this.elementObserver.element;
  }
  get selector() {
    return `[${this.attributeName}]`;
  }
  start() {
    this.elementObserver.start();
  }
  pause(callback) {
    this.elementObserver.pause(callback);
  }
  stop() {
    this.elementObserver.stop();
  }
  refresh() {
    this.elementObserver.refresh();
  }
  get started() {
    return this.elementObserver.started;
  }
  matchElement(element) {
    return element.hasAttribute(this.attributeName);
  }
  matchElementsInTree(tree) {
    const match = this.matchElement(tree) ? [tree] : [];
    const matches = Array.from(tree.querySelectorAll(this.selector));
    return match.concat(matches);
  }
  elementMatched(element) {
    if (this.delegate.elementMatchedAttribute) {
      this.delegate.elementMatchedAttribute(element, this.attributeName);
    }
  }
  elementUnmatched(element) {
    if (this.delegate.elementUnmatchedAttribute) {
      this.delegate.elementUnmatchedAttribute(element, this.attributeName);
    }
  }
  elementAttributeChanged(element, attributeName) {
    if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
      this.delegate.elementAttributeValueChanged(element, attributeName);
    }
  }
}

class Multimap {
  constructor() {
    this.valuesByKey = new Map;
  }
  get keys() {
    return Array.from(this.valuesByKey.keys());
  }
  get values() {
    const sets = Array.from(this.valuesByKey.values());
    return sets.reduce((values, set) => values.concat(Array.from(set)), []);
  }
  get size() {
    const sets = Array.from(this.valuesByKey.values());
    return sets.reduce((size, set) => size + set.size, 0);
  }
  add(key, value) {
    add(this.valuesByKey, key, value);
  }
  delete(key, value) {
    del(this.valuesByKey, key, value);
  }
  has(key, value) {
    const values = this.valuesByKey.get(key);
    return values != null && values.has(value);
  }
  hasKey(key) {
    return this.valuesByKey.has(key);
  }
  hasValue(value) {
    const sets = Array.from(this.valuesByKey.values());
    return sets.some((set) => set.has(value));
  }
  getValuesForKey(key) {
    const values = this.valuesByKey.get(key);
    return values ? Array.from(values) : [];
  }
  getKeysForValue(value) {
    return Array.from(this.valuesByKey).filter(([_key, values]) => values.has(value)).map(([key, _values]) => key);
  }
}
class SelectorObserver {
  constructor(element, selector, delegate, details) {
    this._selector = selector;
    this.details = details;
    this.elementObserver = new ElementObserver(element, this);
    this.delegate = delegate;
    this.matchesByElement = new Multimap;
  }
  get started() {
    return this.elementObserver.started;
  }
  get selector() {
    return this._selector;
  }
  set selector(selector) {
    this._selector = selector;
    this.refresh();
  }
  start() {
    this.elementObserver.start();
  }
  pause(callback) {
    this.elementObserver.pause(callback);
  }
  stop() {
    this.elementObserver.stop();
  }
  refresh() {
    this.elementObserver.refresh();
  }
  get element() {
    return this.elementObserver.element;
  }
  matchElement(element) {
    const { selector } = this;
    if (selector) {
      const matches = element.matches(selector);
      if (this.delegate.selectorMatchElement) {
        return matches && this.delegate.selectorMatchElement(element, this.details);
      }
      return matches;
    } else {
      return false;
    }
  }
  matchElementsInTree(tree) {
    const { selector } = this;
    if (selector) {
      const match = this.matchElement(tree) ? [tree] : [];
      const matches = Array.from(tree.querySelectorAll(selector)).filter((match2) => this.matchElement(match2));
      return match.concat(matches);
    } else {
      return [];
    }
  }
  elementMatched(element) {
    const { selector } = this;
    if (selector) {
      this.selectorMatched(element, selector);
    }
  }
  elementUnmatched(element) {
    const selectors = this.matchesByElement.getKeysForValue(element);
    for (const selector of selectors) {
      this.selectorUnmatched(element, selector);
    }
  }
  elementAttributeChanged(element, _attributeName) {
    const { selector } = this;
    if (selector) {
      const matches = this.matchElement(element);
      const matchedBefore = this.matchesByElement.has(selector, element);
      if (matches && !matchedBefore) {
        this.selectorMatched(element, selector);
      } else if (!matches && matchedBefore) {
        this.selectorUnmatched(element, selector);
      }
    }
  }
  selectorMatched(element, selector) {
    this.delegate.selectorMatched(element, selector, this.details);
    this.matchesByElement.add(selector, element);
  }
  selectorUnmatched(element, selector) {
    this.delegate.selectorUnmatched(element, selector, this.details);
    this.matchesByElement.delete(selector, element);
  }
}

class StringMapObserver {
  constructor(element, delegate) {
    this.element = element;
    this.delegate = delegate;
    this.started = false;
    this.stringMap = new Map;
    this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
  }
  start() {
    if (!this.started) {
      this.started = true;
      this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true });
      this.refresh();
    }
  }
  stop() {
    if (this.started) {
      this.mutationObserver.takeRecords();
      this.mutationObserver.disconnect();
      this.started = false;
    }
  }
  refresh() {
    if (this.started) {
      for (const attributeName of this.knownAttributeNames) {
        this.refreshAttribute(attributeName, null);
      }
    }
  }
  processMutations(mutations) {
    if (this.started) {
      for (const mutation of mutations) {
        this.processMutation(mutation);
      }
    }
  }
  processMutation(mutation) {
    const attributeName = mutation.attributeName;
    if (attributeName) {
      this.refreshAttribute(attributeName, mutation.oldValue);
    }
  }
  refreshAttribute(attributeName, oldValue) {
    const key = this.delegate.getStringMapKeyForAttribute(attributeName);
    if (key != null) {
      if (!this.stringMap.has(attributeName)) {
        this.stringMapKeyAdded(key, attributeName);
      }
      const value = this.element.getAttribute(attributeName);
      if (this.stringMap.get(attributeName) != value) {
        this.stringMapValueChanged(value, key, oldValue);
      }
      if (value == null) {
        const oldValue2 = this.stringMap.get(attributeName);
        this.stringMap.delete(attributeName);
        if (oldValue2)
          this.stringMapKeyRemoved(key, attributeName, oldValue2);
      } else {
        this.stringMap.set(attributeName, value);
      }
    }
  }
  stringMapKeyAdded(key, attributeName) {
    if (this.delegate.stringMapKeyAdded) {
      this.delegate.stringMapKeyAdded(key, attributeName);
    }
  }
  stringMapValueChanged(value, key, oldValue) {
    if (this.delegate.stringMapValueChanged) {
      this.delegate.stringMapValueChanged(value, key, oldValue);
    }
  }
  stringMapKeyRemoved(key, attributeName, oldValue) {
    if (this.delegate.stringMapKeyRemoved) {
      this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);
    }
  }
  get knownAttributeNames() {
    return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
  }
  get currentAttributeNames() {
    return Array.from(this.element.attributes).map((attribute) => attribute.name);
  }
  get recordedAttributeNames() {
    return Array.from(this.stringMap.keys());
  }
}

class TokenListObserver {
  constructor(element, attributeName, delegate) {
    this.attributeObserver = new AttributeObserver(element, attributeName, this);
    this.delegate = delegate;
    this.tokensByElement = new Multimap;
  }
  get started() {
    return this.attributeObserver.started;
  }
  start() {
    this.attributeObserver.start();
  }
  pause(callback) {
    this.attributeObserver.pause(callback);
  }
  stop() {
    this.attributeObserver.stop();
  }
  refresh() {
    this.attributeObserver.refresh();
  }
  get element() {
    return this.attributeObserver.element;
  }
  get attributeName() {
    return this.attributeObserver.attributeName;
  }
  elementMatchedAttribute(element) {
    this.tokensMatched(this.readTokensForElement(element));
  }
  elementAttributeValueChanged(element) {
    const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);
    this.tokensUnmatched(unmatchedTokens);
    this.tokensMatched(matchedTokens);
  }
  elementUnmatchedAttribute(element) {
    this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
  }
  tokensMatched(tokens) {
    tokens.forEach((token) => this.tokenMatched(token));
  }
  tokensUnmatched(tokens) {
    tokens.forEach((token) => this.tokenUnmatched(token));
  }
  tokenMatched(token) {
    this.delegate.tokenMatched(token);
    this.tokensByElement.add(token.element, token);
  }
  tokenUnmatched(token) {
    this.delegate.tokenUnmatched(token);
    this.tokensByElement.delete(token.element, token);
  }
  refreshTokensForElement(element) {
    const previousTokens = this.tokensByElement.getValuesForKey(element);
    const currentTokens = this.readTokensForElement(element);
    const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));
    if (firstDifferingIndex == -1) {
      return [[], []];
    } else {
      return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
    }
  }
  readTokensForElement(element) {
    const attributeName = this.attributeName;
    const tokenString = element.getAttribute(attributeName) || "";
    return parseTokenString(tokenString, element, attributeName);
  }
}

class ValueListObserver {
  constructor(element, attributeName, delegate) {
    this.tokenListObserver = new TokenListObserver(element, attributeName, this);
    this.delegate = delegate;
    this.parseResultsByToken = new WeakMap;
    this.valuesByTokenByElement = new WeakMap;
  }
  get started() {
    return this.tokenListObserver.started;
  }
  start() {
    this.tokenListObserver.start();
  }
  stop() {
    this.tokenListObserver.stop();
  }
  refresh() {
    this.tokenListObserver.refresh();
  }
  get element() {
    return this.tokenListObserver.element;
  }
  get attributeName() {
    return this.tokenListObserver.attributeName;
  }
  tokenMatched(token) {
    const { element } = token;
    const { value } = this.fetchParseResultForToken(token);
    if (value) {
      this.fetchValuesByTokenForElement(element).set(token, value);
      this.delegate.elementMatchedValue(element, value);
    }
  }
  tokenUnmatched(token) {
    const { element } = token;
    const { value } = this.fetchParseResultForToken(token);
    if (value) {
      this.fetchValuesByTokenForElement(element).delete(token);
      this.delegate.elementUnmatchedValue(element, value);
    }
  }
  fetchParseResultForToken(token) {
    let parseResult = this.parseResultsByToken.get(token);
    if (!parseResult) {
      parseResult = this.parseToken(token);
      this.parseResultsByToken.set(token, parseResult);
    }
    return parseResult;
  }
  fetchValuesByTokenForElement(element) {
    let valuesByToken = this.valuesByTokenByElement.get(element);
    if (!valuesByToken) {
      valuesByToken = new Map;
      this.valuesByTokenByElement.set(element, valuesByToken);
    }
    return valuesByToken;
  }
  parseToken(token) {
    try {
      const value = this.delegate.parseValueForToken(token);
      return { value };
    } catch (error2) {
      return { error: error2 };
    }
  }
}

class BindingObserver {
  constructor(context, delegate) {
    this.context = context;
    this.delegate = delegate;
    this.bindingsByAction = new Map;
  }
  start() {
    if (!this.valueListObserver) {
      this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
      this.valueListObserver.start();
    }
  }
  stop() {
    if (this.valueListObserver) {
      this.valueListObserver.stop();
      delete this.valueListObserver;
      this.disconnectAllActions();
    }
  }
  get element() {
    return this.context.element;
  }
  get identifier() {
    return this.context.identifier;
  }
  get actionAttribute() {
    return this.schema.actionAttribute;
  }
  get schema() {
    return this.context.schema;
  }
  get bindings() {
    return Array.from(this.bindingsByAction.values());
  }
  connectAction(action) {
    const binding = new Binding(this.context, action);
    this.bindingsByAction.set(action, binding);
    this.delegate.bindingConnected(binding);
  }
  disconnectAction(action) {
    const binding = this.bindingsByAction.get(action);
    if (binding) {
      this.bindingsByAction.delete(action);
      this.delegate.bindingDisconnected(binding);
    }
  }
  disconnectAllActions() {
    this.bindings.forEach((binding) => this.delegate.bindingDisconnected(binding, true));
    this.bindingsByAction.clear();
  }
  parseValueForToken(token) {
    const action = Action.forToken(token, this.schema);
    if (action.identifier == this.identifier) {
      return action;
    }
  }
  elementMatchedValue(element, action) {
    this.connectAction(action);
  }
  elementUnmatchedValue(element, action) {
    this.disconnectAction(action);
  }
}

class ValueObserver {
  constructor(context, receiver) {
    this.context = context;
    this.receiver = receiver;
    this.stringMapObserver = new StringMapObserver(this.element, this);
    this.valueDescriptorMap = this.controller.valueDescriptorMap;
  }
  start() {
    this.stringMapObserver.start();
    this.invokeChangedCallbacksForDefaultValues();
  }
  stop() {
    this.stringMapObserver.stop();
  }
  get element() {
    return this.context.element;
  }
  get controller() {
    return this.context.controller;
  }
  getStringMapKeyForAttribute(attributeName) {
    if (attributeName in this.valueDescriptorMap) {
      return this.valueDescriptorMap[attributeName].name;
    }
  }
  stringMapKeyAdded(key, attributeName) {
    const descriptor = this.valueDescriptorMap[attributeName];
    if (!this.hasValue(key)) {
      this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));
    }
  }
  stringMapValueChanged(value, name, oldValue) {
    const descriptor = this.valueDescriptorNameMap[name];
    if (value === null)
      return;
    if (oldValue === null) {
      oldValue = descriptor.writer(descriptor.defaultValue);
    }
    this.invokeChangedCallback(name, value, oldValue);
  }
  stringMapKeyRemoved(key, attributeName, oldValue) {
    const descriptor = this.valueDescriptorNameMap[key];
    if (this.hasValue(key)) {
      this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);
    } else {
      this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);
    }
  }
  invokeChangedCallbacksForDefaultValues() {
    for (const { key, name, defaultValue, writer } of this.valueDescriptors) {
      if (defaultValue != null && !this.controller.data.has(key)) {
        this.invokeChangedCallback(name, writer(defaultValue), undefined);
      }
    }
  }
  invokeChangedCallback(name, rawValue, rawOldValue) {
    const changedMethodName = `${name}Changed`;
    const changedMethod = this.receiver[changedMethodName];
    if (typeof changedMethod == "function") {
      const descriptor = this.valueDescriptorNameMap[name];
      try {
        const value = descriptor.reader(rawValue);
        let oldValue = rawOldValue;
        if (rawOldValue) {
          oldValue = descriptor.reader(rawOldValue);
        }
        changedMethod.call(this.receiver, value, oldValue);
      } catch (error2) {
        if (error2 instanceof TypeError) {
          error2.message = `Stimulus Value "${this.context.identifier}.${descriptor.name}" - ${error2.message}`;
        }
        throw error2;
      }
    }
  }
  get valueDescriptors() {
    const { valueDescriptorMap } = this;
    return Object.keys(valueDescriptorMap).map((key) => valueDescriptorMap[key]);
  }
  get valueDescriptorNameMap() {
    const descriptors = {};
    Object.keys(this.valueDescriptorMap).forEach((key) => {
      const descriptor = this.valueDescriptorMap[key];
      descriptors[descriptor.name] = descriptor;
    });
    return descriptors;
  }
  hasValue(attributeName) {
    const descriptor = this.valueDescriptorNameMap[attributeName];
    const hasMethodName = `has${capitalize(descriptor.name)}`;
    return this.receiver[hasMethodName];
  }
}

class TargetObserver {
  constructor(context, delegate) {
    this.context = context;
    this.delegate = delegate;
    this.targetsByName = new Multimap;
  }
  start() {
    if (!this.tokenListObserver) {
      this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);
      this.tokenListObserver.start();
    }
  }
  stop() {
    if (this.tokenListObserver) {
      this.disconnectAllTargets();
      this.tokenListObserver.stop();
      delete this.tokenListObserver;
    }
  }
  tokenMatched({ element, content: name }) {
    if (this.scope.containsElement(element)) {
      this.connectTarget(element, name);
    }
  }
  tokenUnmatched({ element, content: name }) {
    this.disconnectTarget(element, name);
  }
  connectTarget(element, name) {
    var _a;
    if (!this.targetsByName.has(name, element)) {
      this.targetsByName.add(name, element);
      (_a = this.tokenListObserver) === null || _a === undefined || _a.pause(() => this.delegate.targetConnected(element, name));
    }
  }
  disconnectTarget(element, name) {
    var _a;
    if (this.targetsByName.has(name, element)) {
      this.targetsByName.delete(name, element);
      (_a = this.tokenListObserver) === null || _a === undefined || _a.pause(() => this.delegate.targetDisconnected(element, name));
    }
  }
  disconnectAllTargets() {
    for (const name of this.targetsByName.keys) {
      for (const element of this.targetsByName.getValuesForKey(name)) {
        this.disconnectTarget(element, name);
      }
    }
  }
  get attributeName() {
    return `data-${this.context.identifier}-target`;
  }
  get element() {
    return this.context.element;
  }
  get scope() {
    return this.context.scope;
  }
}

class OutletObserver {
  constructor(context, delegate) {
    this.started = false;
    this.context = context;
    this.delegate = delegate;
    this.outletsByName = new Multimap;
    this.outletElementsByName = new Multimap;
    this.selectorObserverMap = new Map;
    this.attributeObserverMap = new Map;
  }
  start() {
    if (!this.started) {
      this.outletDefinitions.forEach((outletName) => {
        this.setupSelectorObserverForOutlet(outletName);
        this.setupAttributeObserverForOutlet(outletName);
      });
      this.started = true;
      this.dependentContexts.forEach((context) => context.refresh());
    }
  }
  refresh() {
    this.selectorObserverMap.forEach((observer) => observer.refresh());
    this.attributeObserverMap.forEach((observer) => observer.refresh());
  }
  stop() {
    if (this.started) {
      this.started = false;
      this.disconnectAllOutlets();
      this.stopSelectorObservers();
      this.stopAttributeObservers();
    }
  }
  stopSelectorObservers() {
    if (this.selectorObserverMap.size > 0) {
      this.selectorObserverMap.forEach((observer) => observer.stop());
      this.selectorObserverMap.clear();
    }
  }
  stopAttributeObservers() {
    if (this.attributeObserverMap.size > 0) {
      this.attributeObserverMap.forEach((observer) => observer.stop());
      this.attributeObserverMap.clear();
    }
  }
  selectorMatched(element, _selector, { outletName }) {
    const outlet = this.getOutlet(element, outletName);
    if (outlet) {
      this.connectOutlet(outlet, element, outletName);
    }
  }
  selectorUnmatched(element, _selector, { outletName }) {
    const outlet = this.getOutletFromMap(element, outletName);
    if (outlet) {
      this.disconnectOutlet(outlet, element, outletName);
    }
  }
  selectorMatchElement(element, { outletName }) {
    const selector = this.selector(outletName);
    const hasOutlet = this.hasOutlet(element, outletName);
    const hasOutletController = element.matches(`[${this.schema.controllerAttribute}~=${outletName}]`);
    if (selector) {
      return hasOutlet && hasOutletController && element.matches(selector);
    } else {
      return false;
    }
  }
  elementMatchedAttribute(_element, attributeName) {
    const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
    if (outletName) {
      this.updateSelectorObserverForOutlet(outletName);
    }
  }
  elementAttributeValueChanged(_element, attributeName) {
    const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
    if (outletName) {
      this.updateSelectorObserverForOutlet(outletName);
    }
  }
  elementUnmatchedAttribute(_element, attributeName) {
    const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
    if (outletName) {
      this.updateSelectorObserverForOutlet(outletName);
    }
  }
  connectOutlet(outlet, element, outletName) {
    var _a;
    if (!this.outletElementsByName.has(outletName, element)) {
      this.outletsByName.add(outletName, outlet);
      this.outletElementsByName.add(outletName, element);
      (_a = this.selectorObserverMap.get(outletName)) === null || _a === undefined || _a.pause(() => this.delegate.outletConnected(outlet, element, outletName));
    }
  }
  disconnectOutlet(outlet, element, outletName) {
    var _a;
    if (this.outletElementsByName.has(outletName, element)) {
      this.outletsByName.delete(outletName, outlet);
      this.outletElementsByName.delete(outletName, element);
      (_a = this.selectorObserverMap.get(outletName)) === null || _a === undefined || _a.pause(() => this.delegate.outletDisconnected(outlet, element, outletName));
    }
  }
  disconnectAllOutlets() {
    for (const outletName of this.outletElementsByName.keys) {
      for (const element of this.outletElementsByName.getValuesForKey(outletName)) {
        for (const outlet of this.outletsByName.getValuesForKey(outletName)) {
          this.disconnectOutlet(outlet, element, outletName);
        }
      }
    }
  }
  updateSelectorObserverForOutlet(outletName) {
    const observer = this.selectorObserverMap.get(outletName);
    if (observer) {
      observer.selector = this.selector(outletName);
    }
  }
  setupSelectorObserverForOutlet(outletName) {
    const selector = this.selector(outletName);
    const selectorObserver = new SelectorObserver(document.body, selector, this, { outletName });
    this.selectorObserverMap.set(outletName, selectorObserver);
    selectorObserver.start();
  }
  setupAttributeObserverForOutlet(outletName) {
    const attributeName = this.attributeNameForOutletName(outletName);
    const attributeObserver = new AttributeObserver(this.scope.element, attributeName, this);
    this.attributeObserverMap.set(outletName, attributeObserver);
    attributeObserver.start();
  }
  selector(outletName) {
    return this.scope.outlets.getSelectorForOutletName(outletName);
  }
  attributeNameForOutletName(outletName) {
    return this.scope.schema.outletAttributeForScope(this.identifier, outletName);
  }
  getOutletNameFromOutletAttributeName(attributeName) {
    return this.outletDefinitions.find((outletName) => this.attributeNameForOutletName(outletName) === attributeName);
  }
  get outletDependencies() {
    const dependencies = new Multimap;
    this.router.modules.forEach((module) => {
      const constructor = module.definition.controllerConstructor;
      const outlets = readInheritableStaticArrayValues(constructor, "outlets");
      outlets.forEach((outlet) => dependencies.add(outlet, module.identifier));
    });
    return dependencies;
  }
  get outletDefinitions() {
    return this.outletDependencies.getKeysForValue(this.identifier);
  }
  get dependentControllerIdentifiers() {
    return this.outletDependencies.getValuesForKey(this.identifier);
  }
  get dependentContexts() {
    const identifiers = this.dependentControllerIdentifiers;
    return this.router.contexts.filter((context) => identifiers.includes(context.identifier));
  }
  hasOutlet(element, outletName) {
    return !!this.getOutlet(element, outletName) || !!this.getOutletFromMap(element, outletName);
  }
  getOutlet(element, outletName) {
    return this.application.getControllerForElementAndIdentifier(element, outletName);
  }
  getOutletFromMap(element, outletName) {
    return this.outletsByName.getValuesForKey(outletName).find((outlet) => outlet.element === element);
  }
  get scope() {
    return this.context.scope;
  }
  get schema() {
    return this.context.schema;
  }
  get identifier() {
    return this.context.identifier;
  }
  get application() {
    return this.context.application;
  }
  get router() {
    return this.application.router;
  }
}

class Context {
  constructor(module, scope) {
    this.logDebugActivity = (functionName, detail = {}) => {
      const { identifier, controller, element } = this;
      detail = Object.assign({ identifier, controller, element }, detail);
      this.application.logDebugActivity(this.identifier, functionName, detail);
    };
    this.module = module;
    this.scope = scope;
    this.controller = new module.controllerConstructor(this);
    this.bindingObserver = new BindingObserver(this, this.dispatcher);
    this.valueObserver = new ValueObserver(this, this.controller);
    this.targetObserver = new TargetObserver(this, this);
    this.outletObserver = new OutletObserver(this, this);
    try {
      this.controller.initialize();
      this.logDebugActivity("initialize");
    } catch (error2) {
      this.handleError(error2, "initializing controller");
    }
  }
  connect() {
    this.bindingObserver.start();
    this.valueObserver.start();
    this.targetObserver.start();
    this.outletObserver.start();
    try {
      this.controller.connect();
      this.logDebugActivity("connect");
    } catch (error2) {
      this.handleError(error2, "connecting controller");
    }
  }
  refresh() {
    this.outletObserver.refresh();
  }
  disconnect() {
    try {
      this.controller.disconnect();
      this.logDebugActivity("disconnect");
    } catch (error2) {
      this.handleError(error2, "disconnecting controller");
    }
    this.outletObserver.stop();
    this.targetObserver.stop();
    this.valueObserver.stop();
    this.bindingObserver.stop();
  }
  get application() {
    return this.module.application;
  }
  get identifier() {
    return this.module.identifier;
  }
  get schema() {
    return this.application.schema;
  }
  get dispatcher() {
    return this.application.dispatcher;
  }
  get element() {
    return this.scope.element;
  }
  get parentElement() {
    return this.element.parentElement;
  }
  handleError(error2, message, detail = {}) {
    const { identifier, controller, element } = this;
    detail = Object.assign({ identifier, controller, element }, detail);
    this.application.handleError(error2, `Error ${message}`, detail);
  }
  targetConnected(element, name) {
    this.invokeControllerMethod(`${name}TargetConnected`, element);
  }
  targetDisconnected(element, name) {
    this.invokeControllerMethod(`${name}TargetDisconnected`, element);
  }
  outletConnected(outlet, element, name) {
    this.invokeControllerMethod(`${namespaceCamelize(name)}OutletConnected`, outlet, element);
  }
  outletDisconnected(outlet, element, name) {
    this.invokeControllerMethod(`${namespaceCamelize(name)}OutletDisconnected`, outlet, element);
  }
  invokeControllerMethod(methodName, ...args) {
    const controller = this.controller;
    if (typeof controller[methodName] == "function") {
      controller[methodName](...args);
    }
  }
}
var getOwnKeys = (() => {
  if (typeof Object.getOwnPropertySymbols == "function") {
    return (object) => [...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)];
  } else {
    return Object.getOwnPropertyNames;
  }
})();
var extend = (() => {
  function extendWithReflect(constructor) {
    function extended() {
      return Reflect.construct(constructor, arguments, new.target);
    }
    extended.prototype = Object.create(constructor.prototype, {
      constructor: { value: extended }
    });
    Reflect.setPrototypeOf(extended, constructor);
    return extended;
  }
  function testReflectExtension() {
    const a = function() {
      this.a.call(this);
    };
    const b = extendWithReflect(a);
    b.prototype.a = function() {
    };
    return new b;
  }
  try {
    testReflectExtension();
    return extendWithReflect;
  } catch (error2) {
    return (constructor) => class extended extends constructor {
    };
  }
})();

class Module {
  constructor(application, definition) {
    this.application = application;
    this.definition = blessDefinition(definition);
    this.contextsByScope = new WeakMap;
    this.connectedContexts = new Set;
  }
  get identifier() {
    return this.definition.identifier;
  }
  get controllerConstructor() {
    return this.definition.controllerConstructor;
  }
  get contexts() {
    return Array.from(this.connectedContexts);
  }
  connectContextForScope(scope) {
    const context = this.fetchContextForScope(scope);
    this.connectedContexts.add(context);
    context.connect();
  }
  disconnectContextForScope(scope) {
    const context = this.contextsByScope.get(scope);
    if (context) {
      this.connectedContexts.delete(context);
      context.disconnect();
    }
  }
  fetchContextForScope(scope) {
    let context = this.contextsByScope.get(scope);
    if (!context) {
      context = new Context(this, scope);
      this.contextsByScope.set(scope, context);
    }
    return context;
  }
}

class ClassMap {
  constructor(scope) {
    this.scope = scope;
  }
  has(name) {
    return this.data.has(this.getDataKey(name));
  }
  get(name) {
    return this.getAll(name)[0];
  }
  getAll(name) {
    const tokenString = this.data.get(this.getDataKey(name)) || "";
    return tokenize(tokenString);
  }
  getAttributeName(name) {
    return this.data.getAttributeNameForKey(this.getDataKey(name));
  }
  getDataKey(name) {
    return `${name}-class`;
  }
  get data() {
    return this.scope.data;
  }
}

class DataMap {
  constructor(scope) {
    this.scope = scope;
  }
  get element() {
    return this.scope.element;
  }
  get identifier() {
    return this.scope.identifier;
  }
  get(key) {
    const name = this.getAttributeNameForKey(key);
    return this.element.getAttribute(name);
  }
  set(key, value) {
    const name = this.getAttributeNameForKey(key);
    this.element.setAttribute(name, value);
    return this.get(key);
  }
  has(key) {
    const name = this.getAttributeNameForKey(key);
    return this.element.hasAttribute(name);
  }
  delete(key) {
    if (this.has(key)) {
      const name = this.getAttributeNameForKey(key);
      this.element.removeAttribute(name);
      return true;
    } else {
      return false;
    }
  }
  getAttributeNameForKey(key) {
    return `data-${this.identifier}-${dasherize(key)}`;
  }
}

class Guide {
  constructor(logger) {
    this.warnedKeysByObject = new WeakMap;
    this.logger = logger;
  }
  warn(object, key, message) {
    let warnedKeys = this.warnedKeysByObject.get(object);
    if (!warnedKeys) {
      warnedKeys = new Set;
      this.warnedKeysByObject.set(object, warnedKeys);
    }
    if (!warnedKeys.has(key)) {
      warnedKeys.add(key);
      this.logger.warn(message, object);
    }
  }
}

class TargetSet {
  constructor(scope) {
    this.scope = scope;
  }
  get element() {
    return this.scope.element;
  }
  get identifier() {
    return this.scope.identifier;
  }
  get schema() {
    return this.scope.schema;
  }
  has(targetName) {
    return this.find(targetName) != null;
  }
  find(...targetNames) {
    return targetNames.reduce((target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName), undefined);
  }
  findAll(...targetNames) {
    return targetNames.reduce((targets, targetName) => [
      ...targets,
      ...this.findAllTargets(targetName),
      ...this.findAllLegacyTargets(targetName)
    ], []);
  }
  findTarget(targetName) {
    const selector = this.getSelectorForTargetName(targetName);
    return this.scope.findElement(selector);
  }
  findAllTargets(targetName) {
    const selector = this.getSelectorForTargetName(targetName);
    return this.scope.findAllElements(selector);
  }
  getSelectorForTargetName(targetName) {
    const attributeName = this.schema.targetAttributeForScope(this.identifier);
    return attributeValueContainsToken(attributeName, targetName);
  }
  findLegacyTarget(targetName) {
    const selector = this.getLegacySelectorForTargetName(targetName);
    return this.deprecate(this.scope.findElement(selector), targetName);
  }
  findAllLegacyTargets(targetName) {
    const selector = this.getLegacySelectorForTargetName(targetName);
    return this.scope.findAllElements(selector).map((element) => this.deprecate(element, targetName));
  }
  getLegacySelectorForTargetName(targetName) {
    const targetDescriptor = `${this.identifier}.${targetName}`;
    return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
  }
  deprecate(element, targetName) {
    if (element) {
      const { identifier } = this;
      const attributeName = this.schema.targetAttribute;
      const revisedAttributeName = this.schema.targetAttributeForScope(identifier);
      this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}="${identifier}.${targetName}" with ${revisedAttributeName}="${targetName}". ` + `The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);
    }
    return element;
  }
  get guide() {
    return this.scope.guide;
  }
}

class OutletSet {
  constructor(scope, controllerElement) {
    this.scope = scope;
    this.controllerElement = controllerElement;
  }
  get element() {
    return this.scope.element;
  }
  get identifier() {
    return this.scope.identifier;
  }
  get schema() {
    return this.scope.schema;
  }
  has(outletName) {
    return this.find(outletName) != null;
  }
  find(...outletNames) {
    return outletNames.reduce((outlet, outletName) => outlet || this.findOutlet(outletName), undefined);
  }
  findAll(...outletNames) {
    return outletNames.reduce((outlets, outletName) => [...outlets, ...this.findAllOutlets(outletName)], []);
  }
  getSelectorForOutletName(outletName) {
    const attributeName = this.schema.outletAttributeForScope(this.identifier, outletName);
    return this.controllerElement.getAttribute(attributeName);
  }
  findOutlet(outletName) {
    const selector = this.getSelectorForOutletName(outletName);
    if (selector)
      return this.findElement(selector, outletName);
  }
  findAllOutlets(outletName) {
    const selector = this.getSelectorForOutletName(outletName);
    return selector ? this.findAllElements(selector, outletName) : [];
  }
  findElement(selector, outletName) {
    const elements = this.scope.queryElements(selector);
    return elements.filter((element) => this.matchesElement(element, selector, outletName))[0];
  }
  findAllElements(selector, outletName) {
    const elements = this.scope.queryElements(selector);
    return elements.filter((element) => this.matchesElement(element, selector, outletName));
  }
  matchesElement(element, selector, outletName) {
    const controllerAttribute = element.getAttribute(this.scope.schema.controllerAttribute) || "";
    return element.matches(selector) && controllerAttribute.split(" ").includes(outletName);
  }
}

class Scope {
  constructor(schema, element, identifier, logger) {
    this.targets = new TargetSet(this);
    this.classes = new ClassMap(this);
    this.data = new DataMap(this);
    this.containsElement = (element2) => {
      return element2.closest(this.controllerSelector) === this.element;
    };
    this.schema = schema;
    this.element = element;
    this.identifier = identifier;
    this.guide = new Guide(logger);
    this.outlets = new OutletSet(this.documentScope, element);
  }
  findElement(selector) {
    return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);
  }
  findAllElements(selector) {
    return [
      ...this.element.matches(selector) ? [this.element] : [],
      ...this.queryElements(selector).filter(this.containsElement)
    ];
  }
  queryElements(selector) {
    return Array.from(this.element.querySelectorAll(selector));
  }
  get controllerSelector() {
    return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
  }
  get isDocumentScope() {
    return this.element === document.documentElement;
  }
  get documentScope() {
    return this.isDocumentScope ? this : new Scope(this.schema, document.documentElement, this.identifier, this.guide.logger);
  }
}

class ScopeObserver {
  constructor(element, schema, delegate) {
    this.element = element;
    this.schema = schema;
    this.delegate = delegate;
    this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
    this.scopesByIdentifierByElement = new WeakMap;
    this.scopeReferenceCounts = new WeakMap;
  }
  start() {
    this.valueListObserver.start();
  }
  stop() {
    this.valueListObserver.stop();
  }
  get controllerAttribute() {
    return this.schema.controllerAttribute;
  }
  parseValueForToken(token) {
    const { element, content: identifier } = token;
    return this.parseValueForElementAndIdentifier(element, identifier);
  }
  parseValueForElementAndIdentifier(element, identifier) {
    const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
    let scope = scopesByIdentifier.get(identifier);
    if (!scope) {
      scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
      scopesByIdentifier.set(identifier, scope);
    }
    return scope;
  }
  elementMatchedValue(element, value) {
    const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;
    this.scopeReferenceCounts.set(value, referenceCount);
    if (referenceCount == 1) {
      this.delegate.scopeConnected(value);
    }
  }
  elementUnmatchedValue(element, value) {
    const referenceCount = this.scopeReferenceCounts.get(value);
    if (referenceCount) {
      this.scopeReferenceCounts.set(value, referenceCount - 1);
      if (referenceCount == 1) {
        this.delegate.scopeDisconnected(value);
      }
    }
  }
  fetchScopesByIdentifierForElement(element) {
    let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
    if (!scopesByIdentifier) {
      scopesByIdentifier = new Map;
      this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
    }
    return scopesByIdentifier;
  }
}

class Router {
  constructor(application) {
    this.application = application;
    this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
    this.scopesByIdentifier = new Multimap;
    this.modulesByIdentifier = new Map;
  }
  get element() {
    return this.application.element;
  }
  get schema() {
    return this.application.schema;
  }
  get logger() {
    return this.application.logger;
  }
  get controllerAttribute() {
    return this.schema.controllerAttribute;
  }
  get modules() {
    return Array.from(this.modulesByIdentifier.values());
  }
  get contexts() {
    return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), []);
  }
  start() {
    this.scopeObserver.start();
  }
  stop() {
    this.scopeObserver.stop();
  }
  loadDefinition(definition) {
    this.unloadIdentifier(definition.identifier);
    const module = new Module(this.application, definition);
    this.connectModule(module);
    const afterLoad = definition.controllerConstructor.afterLoad;
    if (afterLoad) {
      afterLoad.call(definition.controllerConstructor, definition.identifier, this.application);
    }
  }
  unloadIdentifier(identifier) {
    const module = this.modulesByIdentifier.get(identifier);
    if (module) {
      this.disconnectModule(module);
    }
  }
  getContextForElementAndIdentifier(element, identifier) {
    const module = this.modulesByIdentifier.get(identifier);
    if (module) {
      return module.contexts.find((context) => context.element == element);
    }
  }
  proposeToConnectScopeForElementAndIdentifier(element, identifier) {
    const scope = this.scopeObserver.parseValueForElementAndIdentifier(element, identifier);
    if (scope) {
      this.scopeObserver.elementMatchedValue(scope.element, scope);
    } else {
      console.error(`Couldn't find or create scope for identifier: "${identifier}" and element:`, element);
    }
  }
  handleError(error2, message, detail) {
    this.application.handleError(error2, message, detail);
  }
  createScopeForElementAndIdentifier(element, identifier) {
    return new Scope(this.schema, element, identifier, this.logger);
  }
  scopeConnected(scope) {
    this.scopesByIdentifier.add(scope.identifier, scope);
    const module = this.modulesByIdentifier.get(scope.identifier);
    if (module) {
      module.connectContextForScope(scope);
    }
  }
  scopeDisconnected(scope) {
    this.scopesByIdentifier.delete(scope.identifier, scope);
    const module = this.modulesByIdentifier.get(scope.identifier);
    if (module) {
      module.disconnectContextForScope(scope);
    }
  }
  connectModule(module) {
    this.modulesByIdentifier.set(module.identifier, module);
    const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
    scopes.forEach((scope) => module.connectContextForScope(scope));
  }
  disconnectModule(module) {
    this.modulesByIdentifier.delete(module.identifier);
    const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
    scopes.forEach((scope) => module.disconnectContextForScope(scope));
  }
}
var defaultSchema = {
  controllerAttribute: "data-controller",
  actionAttribute: "data-action",
  targetAttribute: "data-target",
  targetAttributeForScope: (identifier) => `data-${identifier}-target`,
  outletAttributeForScope: (identifier, outlet) => `data-${identifier}-${outlet}-outlet`,
  keyMappings: Object.assign(Object.assign({ enter: "Enter", tab: "Tab", esc: "Escape", space: " ", up: "ArrowUp", down: "ArrowDown", left: "ArrowLeft", right: "ArrowRight", home: "Home", end: "End", page_up: "PageUp", page_down: "PageDown" }, objectFromEntries("abcdefghijklmnopqrstuvwxyz".split("").map((c) => [c, c]))), objectFromEntries("0123456789".split("").map((n) => [n, n])))
};

class Application {
  constructor(element = document.documentElement, schema = defaultSchema) {
    this.logger = console;
    this.debug = false;
    this.logDebugActivity = (identifier, functionName, detail = {}) => {
      if (this.debug) {
        this.logFormattedMessage(identifier, functionName, detail);
      }
    };
    this.element = element;
    this.schema = schema;
    this.dispatcher = new Dispatcher(this);
    this.router = new Router(this);
    this.actionDescriptorFilters = Object.assign({}, defaultActionDescriptorFilters);
  }
  static start(element, schema) {
    const application = new this(element, schema);
    application.start();
    return application;
  }
  async start() {
    await domReady();
    this.logDebugActivity("application", "starting");
    this.dispatcher.start();
    this.router.start();
    this.logDebugActivity("application", "start");
  }
  stop() {
    this.logDebugActivity("application", "stopping");
    this.dispatcher.stop();
    this.router.stop();
    this.logDebugActivity("application", "stop");
  }
  register(identifier, controllerConstructor) {
    this.load({ identifier, controllerConstructor });
  }
  registerActionOption(name, filter) {
    this.actionDescriptorFilters[name] = filter;
  }
  load(head, ...rest) {
    const definitions = Array.isArray(head) ? head : [head, ...rest];
    definitions.forEach((definition) => {
      if (definition.controllerConstructor.shouldLoad) {
        this.router.loadDefinition(definition);
      }
    });
  }
  unload(head, ...rest) {
    const identifiers = Array.isArray(head) ? head : [head, ...rest];
    identifiers.forEach((identifier) => this.router.unloadIdentifier(identifier));
  }
  get controllers() {
    return this.router.contexts.map((context) => context.controller);
  }
  getControllerForElementAndIdentifier(element, identifier) {
    const context = this.router.getContextForElementAndIdentifier(element, identifier);
    return context ? context.controller : null;
  }
  handleError(error2, message, detail) {
    var _a;
    this.logger.error(`%s\n\n%o\n\n%o`, message, error2, detail);
    (_a = window.onerror) === null || _a === undefined || _a.call(window, message, "", 0, 0, error2);
  }
  logFormattedMessage(identifier, functionName, detail = {}) {
    detail = Object.assign({ application: this }, detail);
    this.logger.groupCollapsed(`${identifier} #${functionName}`);
    this.logger.log("details:", Object.assign({}, detail));
    this.logger.groupEnd();
  }
}
var defaultValuesByType = {
  get array() {
    return [];
  },
  boolean: false,
  number: 0,
  get object() {
    return {};
  },
  string: ""
};
var readers = {
  array(value) {
    const array = JSON.parse(value);
    if (!Array.isArray(array)) {
      throw new TypeError(`expected value of type "array" but instead got value "${value}" of type "${parseValueTypeDefault(array)}"`);
    }
    return array;
  },
  boolean(value) {
    return !(value == "0" || String(value).toLowerCase() == "false");
  },
  number(value) {
    return Number(value.replace(/_/g, ""));
  },
  object(value) {
    const object = JSON.parse(value);
    if (object === null || typeof object != "object" || Array.isArray(object)) {
      throw new TypeError(`expected value of type "object" but instead got value "${value}" of type "${parseValueTypeDefault(object)}"`);
    }
    return object;
  },
  string(value) {
    return value;
  }
};
var writers = {
  default: writeString,
  array: writeJSON,
  object: writeJSON
};

class Controller {
  constructor(context) {
    this.context = context;
  }
  static get shouldLoad() {
    return true;
  }
  static afterLoad(_identifier, _application) {
    return;
  }
  get application() {
    return this.context.application;
  }
  get scope() {
    return this.context.scope;
  }
  get element() {
    return this.scope.element;
  }
  get identifier() {
    return this.scope.identifier;
  }
  get targets() {
    return this.scope.targets;
  }
  get outlets() {
    return this.scope.outlets;
  }
  get classes() {
    return this.scope.classes;
  }
  get data() {
    return this.scope.data;
  }
  initialize() {
  }
  connect() {
  }
  disconnect() {
  }
  dispatch(eventName, { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true } = {}) {
    const type = prefix ? `${prefix}:${eventName}` : eventName;
    const event = new CustomEvent(type, { detail, bubbles, cancelable });
    target.dispatchEvent(event);
    return event;
  }
}
Controller.blessings = [
  ClassPropertiesBlessing,
  TargetPropertiesBlessing,
  ValuePropertiesBlessing,
  OutletPropertiesBlessing
];
Controller.targets = [];
Controller.outlets = [];
Controller.values = {};

// bridge.js
class Bridge {
  #adapter;
  #lastMessageId;
  #pendingMessages;
  #pendingCallbacks;
  constructor() {
    this.#adapter = null;
    this.#lastMessageId = 0;
    this.#pendingMessages = [];
    this.#pendingCallbacks = new Map;
  }
  start() {
    this.notifyApplicationAfterStart();
  }
  notifyApplicationAfterStart() {
    document.dispatchEvent(new Event("web-bridge:ready"));
  }
  supportsComponent(component) {
    if (this.#adapter) {
      return this.#adapter.supportsComponent(component);
    } else {
      return false;
    }
  }
  send({ component, event, data, callback }) {
    if (!this.#adapter) {
      this.#savePendingMessage({ component, event, data, callback });
      return null;
    }
    if (!this.supportsComponent(component))
      return null;
    const message = {
      id: event,
      component,
      event,
      data: data || {}
    };
    this.#adapter.receive(message);
    if (callback)
      this.#pendingCallbacks.set(event, callback);
    return event;
  }
  receive(message) {
    this.executeCallbackFor(message);
  }
  executeCallbackFor(message) {
    const callback = this.#pendingCallbacks.get(message.id);
    if (callback) {
      callback(message);
    }
  }
  removeCallbackFor(messageId) {
    if (this.#pendingCallbacks.has(messageId)) {
      this.#pendingCallbacks.delete(messageId);
    }
  }
  removePendingMessagesFor(component) {
    this.#pendingMessages = this.#pendingMessages.filter((message) => message.component != component);
  }
  setAdapter(adapter) {
    this.#adapter = adapter;
    document.documentElement.dataset.bridgePlatform = this.#adapter.platform;
    this.adapterDidUpdateSupportedComponents();
    this.#sendPendingMessages();
  }
  adapterDidUpdateSupportedComponents() {
    if (this.#adapter) {
      document.documentElement.dataset.bridgeComponents = this.#adapter.supportedComponents.join(" ");
    }
  }
  #savePendingMessage(message) {
    this.#pendingMessages.push(message);
  }
  #sendPendingMessages() {
    this.#pendingMessages.forEach((message) => this.send(message));
    this.#pendingMessages = [];
  }
}

// controllers/terminal_controller.js
var import_xterm = __toESM(require_xterm(), 1);
var import_unescape_js = __toESM(require_dist(), 1);

// debounce.js
var debounce_default = (callback, wait) => {
  let timeoutId = null;
  return (...args) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      callback.apply(null, args);
    }, wait);
  };
};

// controllers/terminal_controller.js
var import_color = __toESM(require_color(), 1);
var import_xterm_addon_fit = __toESM(require_xterm_addon_fit(), 1);
var import_xterm_addon_web_links = __toESM(require_xterm_addon_web_links(), 1);

// LigaturesAddon.js
var import_npezza93_font_ligatures = __toESM(require_dist2(), 1);

class LigaturesAddon_default {
  activate(terminal) {
    this._terminal = terminal;
    this.font = undefined;
    this.looking = false;
    this._characterJoinerId = this.enable();
  }
  dispose() {
    if (this._characterJoinerId !== undefined) {
      this._terminal?.deregisterCharacterJoiner(this._characterJoinerId);
      this._characterJoinerId = undefined;
    }
  }
  enable() {
    return this._terminal.registerCharacterJoiner((text) => {
      const termFont = this._terminal.options.fontFamily;
      if (!this.looking && termFont && this.font?.name !== termFont) {
        this.looking = true;
        let font = JSON.parse(window.fonts.find((font2) => JSON.parse(font2).name == termFont));
        if (!font.ligatures) {
          let uint8Array = new Uint8Array(font.raw);
          font.ligatures = import_npezza93_font_ligatures.loadBuffer(uint8Array.buffer, { cacheSize: 1e5 });
        }
        this.font = font;
        this._terminal.refresh(0, this._terminal.rows - 1);
        this.looking = false;
      }
      if (this.font) {
        return this.font.ligatures.findLigatureRanges(text).map((range) => [range[0], range[1]]);
      }
    });
  }
}

// controllers/terminal_controller.js
var import_xterm_addon_webgl = __toESM(require_xterm_addon_webgl(), 1);

// bell-sound.js
var AudioContext = window.AudioContext || window.webkitAudioContext;
var audioCtx = new AudioContext;
var bell_sound_default = new Audio("data:audio/mpeg;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//tUwAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAAPAAAX0AAoKCgoKCg8PDw8PDw8UFBQUFBQZGRkZGRkZHh4eHh4eHiJiYmJiYmZmZmZmZmZqampqampqbm5ubm5ucfHx8fHx8fV1dXV1dXV4eHh4eHh7e3t7e3t7fv7+/v7+/v///////8AAAAATGF2YzU4LjEzAAAAAAAAAAAAAAAAJAMAAAAAAAAAF9AQ1MI2AAAAAAAAAAAAAAAAAAAA//vUxAAABsABP7QAAARuQ2u/NZBITckum8krJEQfKAgCAJg+H4nBAAHCgJvg+8P8uH+CDvlwfd/g/BCUdT//lHCd+UBD8P/4YWfp692rzNmcloaUzYEIhAIYAOyPDh5xyRATKSYQHhowAIuCYEijSMDkNI6XhNU1JABah5KdQwvkvAGj6WPDxftvmcoevLAEONPuRdA9dtWvVpHgWJRXpocKabLOUgwsknX1vv6sQ/dnZS7L8sBwlsPvv2ApqKO/fsT/WCqq0dSnzpX5swLCI/T5fypYl+sLl76Ws+qwrg3N5/Xyjj3apLFSxucr25ZjDUPZ2a9y1b3Alibxu3MYpHaj+//87/P/8KSxBURqV6aM2dVIDdp3hCLc/6fe/397kyMH2JXL38vfzP8/7Sc//z/XP///////0O6aKtkwuVDFKpdTXpTLSoCXrpc/3ZaVD0a////////J04Guarfz/1XXKiNONqVt/+qYhDqAABAHzScumpVACNYcBwZhPpHmkxgNnONiATcjHUykyRSTraaoH7Xo0nSSJoMvBsa1OgtnpIr1IKTMUJkbMfQRO0jdqJknRRW26qKtS6S1so6hOpIl0lCWIkpdHSfMjFOiZImzIouqtbKXSS6W3Wkmqguqipquyan7usumohMBogDYodxZMUTBJCcZVqj6tX/6iOFgJwsmqM7/bdxMKMBrvzRwUOMkhMMTBhk0wAKhIuIRjdgMjHAUCLrYQo2yWKsFjjtQfHFeOq12hvZyrkT1JKa9upVtVKWZwk9KVGo6Ghuam4Iqs0iQGNue7jN0dlY3iH1oeLhdnVEk+V9drtyXMioy7YH7JDjxo75ines0zG/Xoras4jsLi5CuAdgrjvX4bDm/ktAiuURE6nusq1UJ1dOe8Yz8xo8ONEziLqFPNeBdTsWceuFLnS0sm+m78ouXpXO2N02FillzsK3nFSIkUXZVDNBfsy/dikl1XWGVBb1Tb/////96pKkvSVYrEahP8CCzlXzN6amGTAAAQA7SMvSY//ukxMyAk8XNSf2JgAOwuWc5p+todK54CVmEFoCAVGAykWE3g4MyUGBUqkJ5alLxXK8mCzkarNxcptnagmEKDJus0Xs5MC1cLVL+cA2OTDTjKBA6apGelEaxdmMxJ64Q/1+dhU07bkvVbpbz/SmX0rDpO110m7t6xJuz3SlfU3AtivGYjYi1fCmzvVudlN2no5ZLo7Q40r4LzMM+VKYUkMhWBtZWG3Wga9JIBc1/rS7nbTtcCUTNAtpm1Fl+OsspnC1VuZdlt6mm71rtm1hWx19DYnu0sZgh+4Q5UdlE9QUPatW5AMBNbX0azGHA7gIyRcQYgQ9Kggm62+T5JIEsJytf//dJWuKXal3///0bEorLCcaytE9lQ0K9IABMiPAOhMcQVABRI1MaZisAWGMoJdDQVts0bDLWOyyB15SuVQREGqvO8jmXItPxezAT87r5cs6jV3VM/Bka0ZCOs2hmU1sbNyZlcqlUCU1ufduzp236lcPQ3GLFuUP3IafB83pe6NxivRS65R35XU+h/6CVRaCZumkcdeG9HaCcwaImoYBLBCgVhqekWeJpEunseNiS7Xxc1KW6KsYgshajQ2ZRCj1T172vu08Vv/+Uoiud6zTVLe7uGFX+bu/8u1/P+3el//ukxOyAYaXxN+1pecvHOSX9na84se5MflcqspBASYZUBxM7oenGZoNQ6kyCTDrihc6v/////5WOBLJ/3eu3h1yAAFABZ4YAHmetBjRQCiUoNS6QFIjDAUQgAsFooouuOXxbKttsTIKSknHKfVnS7XFmJT7xUtuPwma3Y3+FSOVcrTojMc3oxq8zPSWtds3JFTQ7YlV6NVW40n08aj8SiO4VqGpZlYiNLfp6ecx7Yqy21ap6L85qPUlrtNKZruEzL5VM0z0mhNDVlV65XWSdSQgL/wgJorT2Yo9rDspalAaOZftrrfyavymr45dwqSruH46xzsZZW8u9sWqP62dyftavbz/4zf3Vwzw3cmXgSLOa7JiD3KtH1KkUygmGklWSl/KK////1QaM028zJmmXAAAIA4IFRSC5UZcXiwoYWCITAgeEQGDQ8tQDSNFAZAqs6wdkkZXAy+evt2ZS+sC1aaIaoO3m5UWPf/DGM1quLvDxKZ4HNNfq31ehpCShrXD1GtXnqo9/QlGgeLly9iGXjocwQhQy+I0cDNKVN9ifY1NyCFV31nR5LBASoVicJgBw0HUQcTNHH8cglmrWTUhrE4QMpC5igXUTNNA8swNS66jY3OmqjWZUzyJ1Zmx+amp4//ukxNKAHcnHL+3pecOCOKW9tlNQxPKNVMgtNRuYrP2NUEygSoygBY0MbmhOpEOIGidJIsmJFWKvyw3/84OyW4vaqHVsgAAwDkC5wCiSEqGDy3Dtw+YIuYsnBhfVGp4yUMpvAWDzOlL4KlHxqPQpwpyz8OxOrNsi1W1U7ayqau8BLo4Rmkkc5anqXs7LY5OUl+US6SQxT0NLOxS9GdUcHsidKI/YhqHKTeOsN49o862HI1qxau9+nprupm3KIxH/GY5M4BxaNSKAX87/7p4BsalrSF5Q7EncmmIxO12rnSXLFbL6vK+WX/qk5nMzVTl/VX7uWfb9zmWvv75rH//8O1I+ZVkyL0rHFGz1jCmHsr1dG7+BlqtvbiXbIEEYgnhA0xrLDrQ8ssHL0Lgc2KgNIBTSEtkAqIzd4pt0oQu2Ivg/bGoEpIavyjtFrCJvJlnu7yapojllGVYwWLc6itWabtL9uKwPDM8/NmW3qfDCMXqa/8fl2U60lysICxsZ28avOYVaKrhLe4asc7utTX/5Wp+2ndMHRRxDAyYbV4dh6c59RMF9nlXmrDAjNV1IMl+XAoF3I41cqW9jujs61Sbu2OfurYxzs7/K5fLqzptRMDbOP/5mQIBdCTpQegfSscSM//ukxNCAGqmpK+1o2cNHtCW9nVL5HSNVzEIE1UqcyqqaesAAcAqoSlYh4DGsxEDPPKkxeoZXQ4lAwQSW/bd2kwVoMgavIIbf59EeUgYNrUdakoqWbiku7Ult6zydl2O4kIGxVyS8rSm1frY2p+kp41TUVaNTcfpo/EYhPV5TN1rF2hmozUrVdat2s8uXK9nW+W7uXd0lbL9VakRhhbYV+iUsxAosmmu0AuvVsfBSJygzuqUoOsFdKHotNLSS9R9aM+kbJGyCjqFFd111HTzVIsZKTQSUvUf/6iiO0DzB3FovHi6yKzyKZ4yQMnoVmDVn7t5jN2CCCAa+L+GsydQIBjMgQzhjETXyXTWIy1Q5kKa7AF/qRctyXat9uSaBfsZZv5IpRWgGd+vVt0127WxxlQoFCUax27ha+/UnewVJnayv5yiGKe3ORmg7fvxCBJfHmi16kscaPxiI3uVd481rDlfOMwbWsYSn///eW21ZcRoiuRoQN4BS5AyGCnmf//631FY8gZHHqM3WgZrY6jTScqtSOJzbOFtN/6ZQIcB3IIayro13WzHpYsd/KHre3NqovwIoZArqyYvAhGYIKCgEYyEmGBBggKYiCDxcgBQge1iKCFaTdV1J7skgOw7sE5py//uUxOIAGkWnK+zqWwLzMyX9nc58BAyudlMtoJ3spizvVrm7PKaNUuWUypcAQWGqX6USUwyuyGe0uezz3EBVVW56FjixHIh6NSDHLoEba79rfp0vUtImxNwGIwANPgDiI5xOjNByJdf/1N+a8zpGikrNst2XrMH0qlfdD/pkYBQGd3zZo9n/lkvf/buqnwIEQABl2ABDUzoUyaILkxEOMSKMKWS0YoDhTVUb1bHUaCrNB9I6ztS90F/S6HpiTyihptv3MbsfYpcb1Fv/xEAkDYn713BoXhZZg1wqxJBtNTJLSNLJ8AHGHHyaliaTvrpManfWc9RTKiZ4c8LGAMatADHQMABBYZEFACdwyITD/+cH2fp82MGOmTonVGqzVKlosvU69te3f/sTIDgoSRmyr/+VZ63dzKufAQAgDgvCEaEHHuMYBlo6YNOXLgpVopJyMIR5X8kUztQGNtlbvYm67So5MwO/L80edeloK9mmwz7i/saxqxJWw1wp/bWPcqnn//uUxNAAFQGNL+2mmoKoMCY9o1dURGWpDREoeXKEq0bBsmaRpAzSA4dRFl0clkUWPJLmHr+o4dNi0MkLJAxyQwGoCCIHDsKBGiRF7/6xytBDWZ77Htbs3oI/f6mnv/WaFsBgDjImwrXlbf9S1e5m5MR0CSKgYS7gA704ChbsqAA4USaGFwgNSI4FARgBs4XMpwxuPYvVF+P6z1/YNzn6mFrUsnZHzHWsOyqz3KIpjHMfDlXV5hTTFmUEkN0YEYqSIxoGxCQNCthDZYkxJGPmuJZNIdkpnX6yv8jS2pxagagMAxUgDEkEAAE9jjGIHzFc8//LIcSeHwmOo1LizFzhsmibGuzmyXQOJoOgktF/7f+o3NAbdJNrla4p3e7r2q8CLHQHn5CaoSpCUUs8IFTBAJhhAIBA05VeKWoyqjiD1MNcmMY2XUsMSgaIX6TVNUpbsXz1nvdyls5ZXUZRPOD6LvXPtnnGkyq85t3BgmcgUgJFFSVEI0YgLhLo2m1Sdris//uUxNyAFJWBL+0muqK0sCX9lNdU3/nSt/ZImRlwPWQWuA2QLmxC4pARmOar86XygVDMRwRMWog4vT6M66jU7dtNr3RqWtA8dXb///MQzxVKRt1d3MT0CCKADHERRKox2DRqTREIgBhHQRUM0AGELpbGjq5cEp0Pg/7c5RYljQm5Syilr8auTcohWeX5arXqWXWZS3ZTQKWOzNflFmPcnGhWkuZRtvI1CWJouMChCedMOlSUcWFaOO7GCkuYeYt+pY1hO4iQBNYP2C0UcgiBCjtG8/6hbBag3wX5ARkBZgmoySRu69lKW1JBTMgkp2UZIMtfmn//qNgtfJFaN6zMu8edAARySLgq8HICoBEBcOPQMMgxYcHEEjw5G7KxREHchLxRdX79I99pOvu9ULjFLM1Lcnscmrduczwqy7D/rgkMeYO1C3U71v7rxSqKZxxNZBjTjBMIFe0aXYFLEyrnrTy0Oc7/+ikP6IqIGvggoNAsTGYHQLSH7D8j9ag2IawW//uUxOkAFFV/MeymeqKsr+U9lNNV1DHYgEGNhRxDFKY7Uy1GbXYxSZI+8womta1tWj//6ZcDBIwlVje7cvKz0NMZkfhEiE1w6RWI4GFFAEEJjGAE85IGkAwpUSnENMNZ8zlgkQq0ruuw8b9x+t3GzaoJ788PxppFFcq0dZmb5MPY5fUZSaidi43VlVkhXZOky25M2fCS5OJHXEuk9Jqv///9R0uDHgCVwGFYAAoPnFziyBHZE2/WTJ4mnRLtUzNW1a3bMjqnqapjJu1f//9YjKpqzMzbyZ6BLCQN2jMydC8Qt4QMDRlzCIUslqjAAxIVspdhDZl6cq6YBbLG3bopZF6zsuBHpVSz9JUuUlB+v/+Ut/lWSK9N+ad+kz1O02YzzqS1pMrFeTCIlWGSBkhBFwkIwbDkhGwaqCs///+pJE2J0QWA21wC4oCQEkzMmhnTH//5Rb9bdk0kq0lpLO/q///pC/UbRM1ETD9gABFmoJxboaHluNRMTAkWgcUGIgSF//uExPeAFQl/Ke0mmqpcL6X9lNNUyA6GHATFacrY/KPFLAjLuSGVzlXB9oYgSIy6UZy6BMMtVtVZZLsZS8RZ46YUSZi1nspIXNfmNti8KCiOFgwU4Ulz7NNdXpj9azeAvS7FB0zP/2cyLJGCRgkDgMU1oDFgUBv4gIMwMmJ0Kj/////OJ/Qeo36Lf//qOjOhoA7zWjqcusqprsJoIsxI0cUczwCl4qqZhJOCpoCoWwtZdxTZNdVVvHlXPG5PDkCXHiay5LT9xuOyS1N0MOc3vHl+RSHKs2FmZiUvpd1uklSNeeWjYZIh0dQYHqBcNm2QLJTbLBjVZ0wvSBmeqT//1LRPniXDzANhwrcBYeKUIAR4rBh////+p/od//r//USoN5kFusy8yaz4NIVQUiEwJNcxSQ049XBILMERFAgcEFlKgyEuDWeaa0yB8HIfyAaR//uExPUAEmV/Ke0mmqJpsCQ9tldUy3AhFuPQbCq1bKZrUm8K37mI7X/8FcC7Jz73eWUQMhaYNpR2j9IwZwDpRiiVQ5bVyyJjOzd4//7ImRRH0GSgYBbIGEACAKBhax7FhD1iJHn/////+nq//We/+pxQ5IU5m8zLuK6EcDbBOWrjmTRowHAQTKMDXHitFDEo9BQDdS37OC+2cblraTkl5NPpD1+vF8q+XOTH/z/5YtY1YKZMetQzW3qa04ItjPOMplnNtnEgdQHng+gFT0gPLB8sglOcmFpf0v/+gbkUDL4Gu+gMnwGBAgmMuMoJvM2//////6m/+tv/2KSwiLmamXjoEAFIxMQToMFBDDwUhAhkWBoeYuBJMK2q5kgcBMgJgqHmRKLRaYnm7bga85TXYlORCtGZ/dSCe9y5+dqzatLbC4qc0ZpcQ/SZw84Kwgk6//t0xPuAEdF/J+ymmqIwr+U9o1dUcFE3kJBFAMljhcVxqbTzkm4qXC5JwnuGX/opF4ukWFagLgIDK0IA1iBAGgKPZcGcEIS6/////60P002X/9P/2nCVQUu8u6y6ngJMRwbOmCAmECAaoYg6JHQwCJfU4yYYsZ60q2U24SpmTFw4O20NQXYhuHmexGXZRLl2euVI7///9p7GVJBpbQ5415sdf09SUm+OZSvWNYU+lmIuHVQ8TwUhTaqBqpZOFI1//1mBfEIAMKrADAACAJA4lwh4ncWBB/////1t9aZgmhq2dPW7p636maQFzR5u7vKq45CKAUMV4ePJhTNSHszQZNQVnjS1NnbXShOL5JUsFfZiW32i1DUnn1ltSlkj9TMO//t0xPOAEPF/KewmmqJdL+P9tNdU0D/U8t3jrtWlmreNeQg1Q5UmL4Z+5fqyMErI7LaaicFXswSSdiVkkyMEtliTU6Nf/2SRLYrAIjgeHiNBCxGEuZG3////9b/SdaT6nqq1qdu/Utll42fmEQwRGwQAsBZmo77fm/0OnHf+bHhShbBFCFT250KpCGcisifH+45V/1cY3aHKjGPzy3xxEmh//0HxoI4AIQAmGRUIoQb//r///oVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uExOmAEmmBJ+0muqIrMCS9k09UVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//sUxPgDyVDvC0Ok+MAAAD/AAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV");

// node_modules/@hotwired/strada/dist/strada.js
var __defProp2 = Object.defineProperty;
var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var Bridge2 = class {
  #adapter;
  #lastMessageId;
  #pendingMessages;
  #pendingCallbacks;
  constructor() {
    this.#adapter = null;
    this.#lastMessageId = 0;
    this.#pendingMessages = [];
    this.#pendingCallbacks = new Map;
  }
  start() {
    this.notifyApplicationAfterStart();
  }
  notifyApplicationAfterStart() {
    document.dispatchEvent(new Event("web-bridge:ready"));
  }
  supportsComponent(component) {
    if (this.#adapter) {
      return this.#adapter.supportsComponent(component);
    } else {
      return false;
    }
  }
  send({ component, event, data, callback }) {
    if (!this.#adapter) {
      this.#savePendingMessage({ component, event, data, callback });
      return null;
    }
    if (!this.supportsComponent(component))
      return null;
    const id = this.generateMessageId();
    const message = { id, component, event, data: data || {} };
    this.#adapter.receive(message);
    if (callback) {
      this.#pendingCallbacks.set(id, callback);
    }
    return id;
  }
  receive(message) {
    this.executeCallbackFor(message);
  }
  executeCallbackFor(message) {
    const callback = this.#pendingCallbacks.get(message.id);
    if (callback) {
      callback(message);
    }
  }
  removeCallbackFor(messageId) {
    if (this.#pendingCallbacks.has(messageId)) {
      this.#pendingCallbacks.delete(messageId);
    }
  }
  removePendingMessagesFor(component) {
    this.#pendingMessages = this.#pendingMessages.filter((message) => message.component != component);
  }
  generateMessageId() {
    const id = ++this.#lastMessageId;
    return id.toString();
  }
  setAdapter(adapter) {
    this.#adapter = adapter;
    document.documentElement.dataset.bridgePlatform = this.#adapter.platform;
    this.adapterDidUpdateSupportedComponents();
    this.#sendPendingMessages();
  }
  adapterDidUpdateSupportedComponents() {
    if (this.#adapter) {
      document.documentElement.dataset.bridgeComponents = this.#adapter.supportedComponents.join(" ");
    }
  }
  #savePendingMessage(message) {
    this.#pendingMessages.push(message);
  }
  #sendPendingMessages() {
    this.#pendingMessages.forEach((message) => this.send(message));
    this.#pendingMessages = [];
  }
};
var BridgeElement = class {
  constructor(element) {
    this.element = element;
  }
  get title() {
    return (this.bridgeAttribute("title") || this.attribute("aria-label") || this.element.textContent || this.element.value).trim();
  }
  get enabled() {
    return !this.disabled;
  }
  get disabled() {
    const disabled = this.bridgeAttribute("disabled");
    return disabled === "true" || disabled === this.platform;
  }
  enableForComponent(component) {
    if (component.enabled) {
      this.removeBridgeAttribute("disabled");
    }
  }
  hasClass(className) {
    return this.element.classList.contains(className);
  }
  attribute(name) {
    return this.element.getAttribute(name);
  }
  bridgeAttribute(name) {
    return this.attribute(`data-bridge-${name}`);
  }
  setBridgeAttribute(name, value) {
    this.element.setAttribute(`data-bridge-${name}`, value);
  }
  removeBridgeAttribute(name) {
    this.element.removeAttribute(`data-bridge-${name}`);
  }
  click() {
    if (this.platform == "android") {
      this.element.removeAttribute("target");
    }
    this.element.click();
  }
  get platform() {
    return document.documentElement.dataset.bridgePlatform;
  }
};
var { userAgent } = window.navigator;
var isStradaNativeApp = /bridge-components: \[.+\]/.test(userAgent);
var BridgeComponent = class extends Controller {
  static get shouldLoad() {
    return isStradaNativeApp;
  }
  pendingMessageCallbacks = [];
  initialize() {
    this.pendingMessageCallbacks = [];
  }
  connect() {
  }
  disconnect() {
    this.removePendingCallbacks();
    this.removePendingMessages();
  }
  get component() {
    return this.constructor.component;
  }
  get platformOptingOut() {
    const { bridgePlatform } = document.documentElement.dataset;
    return this.identifier == this.element.getAttribute(`data-controller-optout-${bridgePlatform}`);
  }
  get enabled() {
    return !this.platformOptingOut && this.bridge.supportsComponent(this.component);
  }
  send(event, data = {}, callback) {
    data.metadata = {
      url: window.location.href
    };
    const message = { component: this.component, event, data, callback };
    const messageId = this.bridge.send(message);
    if (callback) {
      this.pendingMessageCallbacks.push(messageId);
    }
  }
  removePendingCallbacks() {
    this.pendingMessageCallbacks.forEach((messageId) => this.bridge.removeCallbackFor(messageId));
  }
  removePendingMessages() {
    this.bridge.removePendingMessagesFor(this.component);
  }
  get bridgeElement() {
    return new BridgeElement(this.element);
  }
  get bridge() {
    return window.Strada.web;
  }
};
__publicField(BridgeComponent, "component", "");
if (!window.Strada) {
  const webBridge = new Bridge2;
  window.Strada = { web: webBridge };
  webBridge.start();
}

// keystroke_for_keyboard_event.js
var __guard__ = function(value, transform) {
  return typeof value !== "undefined" && value !== null ? transform(value) : undefined;
};
var currentKeymaps = (init_current_keymaps(), __toCommonJS(exports_current_keymaps));
var MODIFIERS = new Set(["ctrl", "alt", "shift", "cmd"]);
var KEY_NAMES_BY_KEYBOARD_EVENT_CODE = {
  Space: "space",
  Backspace: "backspace"
};
var NON_CHARACTER_KEY_NAMES_BY_KEYBOARD_EVENT_KEY = {
  Control: "ctrl",
  Meta: "cmd",
  ArrowDown: "down",
  ArrowUp: "up",
  ArrowLeft: "left",
  ArrowRight: "right"
};
var NUMPAD_KEY_NAMES_BY_KEYBOARD_EVENT_CODE = {
  Numpad0: "numpad0",
  Numpad1: "numpad1",
  Numpad2: "numpad2",
  Numpad3: "numpad3",
  Numpad4: "numpad4",
  Numpad5: "numpad5",
  Numpad6: "numpad6",
  Numpad7: "numpad7",
  Numpad8: "numpad8",
  Numpad9: "numpad9"
};
var isASCIICharacter = (character) => character != null && character.length === 1 && character.charCodeAt(0) <= 127;
var isLatinCharacter = (character) => character != null && character.length === 1 && character.charCodeAt(0) <= 591;
var isUpperCaseCharacter = (character) => character != null && character.length === 1 && character.toLowerCase() !== character;
var isLowerCaseCharacter = (character) => character != null && character.length === 1 && character.toUpperCase() !== character;
var normalizeKeystroke = function(keystroke) {
  let keyup;
  if (keyup = isKeyup(keystroke)) {
    keystroke = keystroke.slice(1);
  }
  const keys = parseKeystroke(keystroke);
  if (!keys) {
    return false;
  }
  let primaryKey = null;
  const modifiers = new Set;
  for (let i = 0;i < keys.length; i++) {
    const key = keys[i];
    if (MODIFIERS.has(key)) {
      modifiers.add(key);
    } else {
      if (i === keys.length - 1) {
        primaryKey = key;
      } else {
        return false;
      }
    }
  }
  if (keyup) {
    if (primaryKey != null) {
      primaryKey = primaryKey.toLowerCase();
    }
  } else {
    if (isUpperCaseCharacter(primaryKey)) {
      modifiers.add("shift");
    }
    if (modifiers.has("shift") && isLowerCaseCharacter(primaryKey)) {
      primaryKey = primaryKey.toUpperCase();
    }
  }
  keystroke = [];
  if (!keyup || keyup && primaryKey == null) {
    if (modifiers.has("ctrl")) {
      keystroke.push("ctrl");
    }
    if (modifiers.has("alt")) {
      keystroke.push("alt");
    }
    if (modifiers.has("shift")) {
      keystroke.push("shift");
    }
    if (modifiers.has("cmd")) {
      keystroke.push("cmd");
    }
  }
  if (primaryKey != null) {
    keystroke.push(primaryKey);
  }
  keystroke = keystroke.join("-");
  if (keyup) {
    keystroke = `^${keystroke}`;
  }
  return keystroke;
};
var parseKeystroke = function(keystroke) {
  const keys = [];
  let keyStart = 0;
  for (let index = 0;index < keystroke.length; index++) {
    const character = keystroke[index];
    if (character === "-") {
      if (index > keyStart) {
        keys.push(keystroke.substring(keyStart, index));
        keyStart = index + 1;
        if (keyStart === keystroke.length) {
          return false;
        }
      }
    }
  }
  if (keyStart < keystroke.length) {
    keys.push(keystroke.substring(keyStart));
  }
  return keys;
};
var keystroke_for_keyboard_event_default = (event) => {
  let characters;
  let { key, code, ctrlKey, altKey, shiftKey, metaKey } = event;
  if (key === "Dead") {
    if (characters = __guard__(currentKeymaps, (x) => x[event.code])) {
      if (altKey && shiftKey && characters.withAltGraphShift != null) {
        key = characters.withAltGraphShift;
      } else if (altKey && characters.withAltGraph != null) {
        key = characters.withAltGraph;
      } else if (shiftKey && characters.withShift != null) {
        key = characters.withShift;
      } else if (characters.unmodified != null) {
        key = characters.unmodified;
      }
    }
  }
  if (NUMPAD_KEY_NAMES_BY_KEYBOARD_EVENT_CODE[code] != null && event.getModifierState("NumLock")) {
    key = NUMPAD_KEY_NAMES_BY_KEYBOARD_EVENT_CODE[code];
  }
  if (KEY_NAMES_BY_KEYBOARD_EVENT_CODE[code] != null) {
    key = KEY_NAMES_BY_KEYBOARD_EVENT_CODE[code];
  }
  const isNonCharacterKey = key.length > 1;
  if (isNonCharacterKey) {
    key = NON_CHARACTER_KEY_NAMES_BY_KEYBOARD_EVENT_KEY[key] != null ? NON_CHARACTER_KEY_NAMES_BY_KEYBOARD_EVENT_KEY[key] : key.toLowerCase();
  } else {
    if (shiftKey) {
      key = key.toUpperCase();
    } else {
      key = key.toLowerCase();
    }
    if (event.getModifierState("AltGraph") || altKey) {
      let nonAltModifiedKey;
      if (event.code) {
        nonAltModifiedKey = nonAltModifiedKeyForKeyboardEvent(event);
        if (nonAltModifiedKey && (ctrlKey || metaKey || !isASCIICharacter(key))) {
          key = nonAltModifiedKey;
        } else if (key !== nonAltModifiedKey) {
          altKey = false;
        }
      }
    }
  }
  let keystroke = "";
  if (key === "ctrl" || ctrlKey && event.type !== "keyup") {
    keystroke += "ctrl";
  }
  if (key === "alt" || altKey && event.type !== "keyup") {
    if (keystroke.length > 0) {
      keystroke += "-";
    }
    keystroke += "alt";
  }
  if (key === "shift" || shiftKey && event.type !== "keyup" && (isNonCharacterKey || isLatinCharacter(key) && isUpperCaseCharacter(key))) {
    if (keystroke) {
      keystroke += "-";
    }
    keystroke += "shift";
  }
  if (key === "cmd" || metaKey && event.type !== "keyup") {
    if (keystroke) {
      keystroke += "-";
    }
    keystroke += "cmd";
  }
  if (!MODIFIERS.has(key)) {
    if (keystroke) {
      keystroke += "-";
    }
    keystroke += key;
  }
  if (event.type === "keyup") {
    keystroke = normalizeKeystroke(`^${keystroke}`);
  }
  return keystroke;
};
var nonAltModifiedKeyForKeyboardEvent = function(event) {
  let characters;
  if (event.code && (characters = __guard__(currentKeymaps, (x) => x[event.code]))) {
    if (event.shiftKey) {
      return characters.withShift;
    }
    return characters.unmodified;
  }
};
var isKeyup = (keystroke) => keystroke.startsWith("^") && keystroke !== "^";

// controllers/terminal_controller.js
class terminal_controller_default extends BridgeComponent {
  static component = "terminal";
  initialize() {
    this.fit = debounce_default(this.fit.bind(this), 50);
  }
  connect() {
    super.connect();
    this.fitAddon = new import_xterm_addon_fit.FitAddon;
    this.webglAddon = new import_xterm_addon_webgl.WebglAddon;
    this.ligaturesAddon = new LigaturesAddon_default;
    this.send("connect", {}, ({ data }) => {
      this.profile = data;
      this.xterm = new import_xterm.Terminal(this.settings());
      window.xterm = this.xterm;
      this.xterm.loadAddon(this.fitAddon);
      this.resetKeymaps();
      document.documentElement.style.setProperty("--background-color", this.profile.theme.background);
      document.documentElement.style.setProperty("--terminal-padding", this.profile.padding);
      this.attach();
    });
    this.send("profileChanged", {}, ({ data }) => {
      this.profile = data;
      this.xterm.options.allowTransparency = this.settings().allowTransparency;
      this.xtermSettings().forEach((property) => {
        this.xterm.options[property] = data[property];
      });
      this.resetKeymaps();
      document.documentElement.style.setProperty("--background-color", this.profile.theme.background);
      document.documentElement.style.setProperty("--terminal-padding", this.profile.padding);
    });
    this.send("settingChanged", {}, ({ data }) => {
      if (this.xtermSettings().includes(data.property)) {
        this.xterm.options[data.property] = data.value;
      } else if (data.property === "keybindings") {
        this.profile = data.value;
        this.resetKeymaps();
      } else if (data.property === "padding") {
        document.documentElement.style.setProperty("--terminal-padding", data.value);
      } else if (data.property.startsWith("theme.")) {
        this.profile = data.value;
        this.xterm.options.allowTransparency = this.settings().allowTransparency;
        this.xterm.options.theme = this.settings().theme;
        document.documentElement.style.setProperty("--background-color", this.settings().theme.background);
      } else if (data.property == "hideContextMenu") {
        this.profile.hideContextMenu = data.value == true || data.value == "true";
      }
    });
  }
  disconnect() {
    this.send("disconnect");
    super.disconnect();
    this.xterm?.dispose();
    this._wrapperElement?.remove();
    this._wrapperElement = null;
    this.xterm = null;
  }
  onContextMenu(event) {
    if (this.profile.hideContextMenu) {
      event.preventDefault();
    }
  }
  send(event, data = {}, callback) {
    data.metadata = { url: "archipelago-1" };
    const message = { component: this.component, event, data, callback };
    const messageId = this.bridge.send(message);
    if (callback) {
      this.pendingMessageCallbacks.push(messageId);
    }
  }
  attach() {
    if (!this._wrapperElement) {
      this._wrapperElement = document.createElement("div");
      this._wrapperElement.classList = "wrapper";
      this._xtermElement = document.createElement("div");
      this._xtermElement.classList = "wrapper";
      this._wrapperElement.append(this._xtermElement);
      this.element.append(this._wrapperElement);
      this.xterm.open(this._xtermElement);
      this.xterm.loadAddon(this.webglAddon);
      if (this.profile.ligatures) {
        this.xterm.loadAddon(this.ligaturesAddon);
      }
      this.bindListeners();
      this.fit();
      this.xterm.focus();
      return;
    }
    this._wrapperElement.remove();
    this._container = this.element;
    this._container.append(this._wrapperElement);
    this.xterm.focus();
  }
  fit() {
    this.fitAddon.fit();
    this.send("resize", { cols: this.xterm.cols, rows: this.xterm.rows });
  }
  onBinary(callback) {
    return this.xterm.onBinary(callback);
  }
  onData(callback) {
    return this.xterm.onData(callback);
  }
  onBell(callback) {
    return this.xterm.onBell(callback);
  }
  onSelection(callback) {
    return this.xterm.onSelectionChange(callback);
  }
  copySelection() {
    if (this.profile.copyOnSelect && this.xterm.getSelection()) {
      navigator.clipboard.writeText(this.xterm.getSelection());
    }
  }
  settings() {
    return this.applySettingModifiers(this.xtermSettings().reduce((settings, property) => {
      settings[property] = this.profile[property];
      return settings;
    }, {}));
  }
  xtermSettings() {
    return [
      "fontFamily",
      "fontSize",
      "fontWeight",
      "cursorStyle",
      "cursorBlink",
      "scrollback",
      "macOptionIsMeta",
      "rightClickSelectsWord",
      "macOptionClickForcesSelection",
      "theme"
    ];
  }
  allowTransparency(background) {
    const color = new import_color.default(background);
    let allowTransparency;
    allowTransparency = color.alpha() !== 1;
    return allowTransparency;
  }
  applySettingModifiers(defaultSettings) {
    const { background } = defaultSettings.theme;
    defaultSettings.allowTransparency = this.allowTransparency(background);
    defaultSettings.cursorWidth = 2;
    defaultSettings.fontWeightBold = "bold";
    defaultSettings.lineHeight = 1;
    defaultSettings.letterSpacing = "0";
    defaultSettings.tabStopWidth = 8;
    defaultSettings.allowProposedApi = true;
    return defaultSettings;
  }
  get keymaps() {
    if (this._keymaps === undefined) {
      this.resetKeymaps();
    }
    return this._keymaps;
  }
  resetKeymaps() {
    this._keymaps = (this.profile.keybindings || []).reduce((result, item) => {
      result[item.keystroke] = import_unescape_js.default(item.command);
      return result;
    }, {});
  }
  keybindingHandler(event) {
    let caught = false;
    const mapping = this.keymaps[keystroke_for_keyboard_event_default(event)];
    if (mapping) {
      this.send("write", { data: mapping });
      caught = true;
    }
    return !caught;
  }
  bindListeners() {
    const scrollbarFadeEffect = () => {
      clearTimeout(this.scrollbarFade);
      this.scrollbarFade = setTimeout(() => this.xterm.element.classList.remove("scrolling"), 600);
      this.xterm.element.classList.add("scrolling");
    };
    this.xterm.element.addEventListener("wheel", scrollbarFadeEffect.bind(this), { passive: true });
    this.webLinksAddon = new import_xterm_addon_web_links.WebLinksAddon((event, uri) => {
      const anchor = document.createElement("a");
      anchor.href = uri;
      anchor.target = "_blank";
      anchor.click();
    });
    this.xterm.loadAddon(this.webLinksAddon);
    this.xterm.attachCustomKeyEventHandler(this.keybindingHandler.bind(this));
    this.send("data", {}, ({ data }) => this.xterm.write(JSON.parse(data.data)));
    this.onData((data) => this.send("write", { data }));
    this.onBell(() => bell_sound_default.play());
    this.onSelection(this.copySelection.bind(this));
    this.onBinary((data) => {
      console.log("binary-send", { data });
      this.send("binary", { data });
    });
  }
}

// controllers/font_loader_controller.js
class font_loader_controller_default extends BridgeComponent {
  static component = "font-loader";
  connect() {
    super.connect();
    this.fonts = [];
    if (window.font) {
      this.loadFont(window.font);
    }
    this.send("change", {}, ({ data }) => {
      let existingFont = this.fonts.find((font) => font.name == data.name);
      if (!existingFont) {
        this.loadFont(data);
      }
    });
  }
  loadFont(font) {
    let css = `@font-face {
      font-family: '${font.name}';
      src: url('data:font/${font.format};base64,${font.base64}');
    }`;
    let inits = `<div style="position:fixed;top:100000px;left:1000000px;font-family:'${font.name}'">${font.name}</div>`;
    let style = document.createElement("style");
    style.innerHTML = css;
    document.head.appendChild(style);
    document.body.insertAdjacentHTML("beforeend", inits);
    this.fonts = [...this.fonts, font];
  }
  send(event, data = {}, callback) {
    data.metadata = { url: "archipelago-1" };
    const message = { component: this.component, event, data, callback };
    const messageId = this.bridge.send(message);
    if (callback) {
      this.pendingMessageCallbacks.push(messageId);
    }
  }
}

// application.js
var webBridge = new Bridge;
window.Strada = { web: webBridge };
webBridge.start();
var application = Application.start();
application.debug = false;
window.Stimulus = application;
Stimulus.register("terminal", terminal_controller_default);
Stimulus.register("font-loader", font_loader_controller_default);
